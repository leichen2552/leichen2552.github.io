{"posts":[{"title":"深入理解linux内核链表","content":" 双向链表 一般双向链表 Linux内核链表 双向链表 一般双向链表 核心就是一个node结构体，里面有两个指针，指向前后节点，另外包含了一个存储数据的成员变量。 struct Data { int a; }; struct Node { struct Data data; struct Node *prev, *next; } 但是C没有模板，这意味着不同类型的数据，Node结构体都是不同类型，用来实现链表逻辑的函数得为每种类型的都写一遍。 Linux内核链表 linux的实现是反过来，把节点指针存在数据里面。 struct Node { struct Node *next, *prev; }; struct Data { struct Node data_list; int age; }; struct list_head student_list_head; node里面的指针是指向Data里面的data_list成员，所以要获取所在Data的指针，需要做一些指针偏移何强制类型转换。注意，data_list也可以是其他类型的链表，它就是链表的头。 #define offsetof(TYPE, MEMBER) ((int) &amp;((TYPE *)0)-&gt;MEMBER) #define member_size(TYPE, MEMBER) sizeof(((TYPE *)0)-&gt;MEMBER) #ifdef __GNUC__ #define member_type(type, member) __typeof__ (((type *)0)-&gt;member) #else #define member_type(type, member) const void #endif #define container_of(ptr, type, member) ((type *)( \\ (char *)(member_type(type, member) *){ ptr } - offsetof(type, member))) #include &quot;list.h&quot; struct student{ struct list_head entry; int age; }; struct list_head student_list_head; int main() { INIT_LIST_HEAD(&amp;student_list_head); struct student s1={.age = 1}; struct student s2={.age = 2}; struct student s3={.age = 3}; struct student s4={.age = 4}; list_add_tail(&amp;s1.entry, &amp;student_list_head); list_add_tail(&amp;s2.entry, &amp;student_list_head); list_add_tail(&amp;s3.entry, &amp;student_list_head); list_add_tail(&amp;s4.entry, &amp;student_list_head); return 0; } 如下图所示，把几个student用链表链起来的是student结构体中的entry，s1中entry中的next指针指向s2中的entry。通过entry链起来，通过entry来访问每个strudent的其他结构体成员。 ","link":"https://leichen2552.github.io/post/shen-ru-li-jie-linux-nei-he-lian-biao/"},{"title":"Introduction to Programming in Python: An Interdisciplinary Approach","content":"序言 教育的基础在最后的一千年里面是“读、写和算数”，但是现在时“读、写和计算”。在科学与工程的学科中，学习编程是每个学生教育中必不可少的一部分。除了直接应用之外，这是理解计算机科学对现代世界不可否认的影响的本质的第一步。这本书旨在帮助那些想要在科学背景下学习编程的人。 我们的目标是授予学生通过提供经验和必要的基础工具来有效地计算。我们的方法是告诉学生组建一个程序是自然的、令人满意的、并且是有创造性体验的。我们会从应用数学和科学的角度来对概念进行举例，并且提供机会让学生写程序来解决吸引人的程序，从而循序渐进得介绍必要的概念和拥抱经典的应用程序。 在本书中我们对所有的程序使用Python编程语言——我们在标题中的“Programming”中机上“Python”是为了强调本书是关于编程的基本概念，而不是Python本身。这本书教授计算问题的基本技能应用与现代的计算环境，并且是为之前没有相关编程经验的人准备的的课程。 这本书是传统计算机课程的跨学科方法，我们强调计算在其他学科中的作用，从材料科学到基因组学到天体物理学到网络系统。这个方法向学生强调数学、科学、工程和计算在现代世界中是交织在一起的基本思想。虽然它是对数学、科学或者工程感兴趣的一年级学生准备的教科书，同时他也被用来自学或者是作为与其他领域结合编程课程的补充。 课程内容：这本书围绕着学习编程的四个阶段：基础元素、函数、面向对象编程和算法。我们提供读者需要的基础的信息，在移动到下个等级之前，需要再当前等级下组成自己的程序来建立信心。我们方法最基本的期望是使用样例程序来解决有趣的问题，支持练习从自学的需求到对有挑战性问题的创造性思路。 基础元素保罗变量，赋值表达式，内置数据类型，控制流，数组，输入和输出，包括图形和声音。 函数和模块是学生第一次接触模块化编程。我们依赖于熟悉的数学函数来介绍Python函数，并且考虑函数式编程的含义，包括函数和递归的库。我们强调把一个程序划分成不同的块的基本思想，这些块需要能欧独立调试、维护并且服用。 面向对象编程是我们介绍的数据抽象部分。我们强调数据类型的概念和使用Python类机制的实现。我们教授学生如何使用、创建、设计数据类型。模块、封装和其他现代的编程范例是这个阶段的中心思想。 算法和数据结构是为了现代的应用，把现代编程范例和传统高效组织和处理数据的方法相组成。我们提供排序和查找的传统算法的介绍以及基础的数据结构和他们的应用。强调了使用科学方法来理解性能特征的实现。 在科学和工程中应用是本书的一个关键特征。我们通过检查特定应用的影响来激励我们所处理每一个程序概念。我们从应用数学、物理学和仿生学、和计算机科学本身，和物理系统仿真、数值计算、数据可视化、声音合成、图像处理、金融仿真和信息技术这些学科中抽取样例。具体样例包括马尔科夫链在第一章中对网页排名的处理、以及解决渗流问题、n体问题和小世界现象的案例研究。这些应用是本书的必要部分。他们吸引学生到材料中，例证编程概念的重要性，并且提供关键性的证据，证明计算在现代科学与工程中扮演的关键角色。 我们主要的目标是教授面对任何编程问题开发有效的解决方案所需的的特定的机制与技能。我们将使用完整的Python程序并且鼓励读者使用它们。我们专注于个人编程，而不是大规模编程。 课程中使用：这本书适用于大学一年级课程，旨在帮助新手们在科学应用下编程。从这本书中，任何科学与工程中的领域中的未来专业都都可以在相似的场景中编程。基本这本书完成的学生将为他们的技能应用与在后续的科学与工程的课程做好充分的准备，并认识到在接下来的计算机科学课程中可能收益。 特别是未来的计算科学专业的学生，可以从未来的科学应用背景下编程获益。一个计算机科学家就要像生物学家、工程师、物理学家一样，具备相同的科学方法中基础背景，并了解计算在科学中的重要作用。 事实上，我们跨学科方法使大学和学院在同一门课程中教授未来计算机专业、科学与工程中的其他领域的未来专业。我们涵盖了CS1中的规定的材料，但我们聚焦的应用程序给生活带来了生命，并且激发学生学习的动力。我们的跨学科方法给学生展示了在许多不同学科的问题，帮助他们更明智得选择专业。 不管是什么具体的机制，这本书的使用最早在课程的早期。首先，我们可以在高中数学与科学中充分利用熟悉的材料。第二，在课程中早期学习的编程的学生在进入专业课程中时将会更有效地学习计算机。就像阅读和写作，对任何科学家或者工程师来说，编程被认为是一项必须的技能。已经掌握本书概念的学生将会在一生中继续发展这个技能，收获利用计算用来解决或者更好得理解在他们选择的领域中出现的问题和项目的好处。 预备知识：本书适合典型的大学一年级的科学与工程的学生，也就是说，我们不希望准备工作超出其他入门级科学和数学课程通常要求的范围。 数学成熟度很重要。虽然我们不会纠结于数学材料，但是我们会参考学生在高中时的数学课程，包括代数、集合与三角。我们目标受众中的大部分学生自动满足这些需求。我们利用他们对基础课程的熟悉度来介绍基础的编程概念。 科学好奇心也是一个必要的组成部分。理工科的学生带着一种对科学探究能力的迷恋，帮助他们解释自然界发生的事情。我们充分利用简单程序的例子来利用这些嗜好，这些简单程序充分说明的自然界。我们不假设任何超出典型高中课程提供的数学、物理、生物或化学课程提供的特定知识。 编程经验不是必要的，但也不是有害的。教授编程是我们主要的目标，所以我们假设没有预先的编程经验。但是组成程序来解决一个新问题是一个很有挑战的智力问题，所以那些在高中能写出大型程序的学生可以基于此书在次入门的编程课中收益。这本书可以支持教授具有不同背景的学生，因为这些应用程序对新手和专家都有吸引力。 使用计算机的经验也不是必须的，但也完全不是问题。大学生经常使用计算机，用来和亲朋交流、听音乐、处理照片，并且是许多其他活动中的一部分。意识到他们能够以有趣和重要的方式使用它们的电脑是一件意义深远的事情。 最后，几乎所有科学与工程领域的学生会以此书为基础准备这个课程作为他们第一学期课程的一部分。 目标：理工科告诫课程的教师对学完基本本书开设课程的学生有什么期待？ 我们覆盖了CS1的课程，但是任何教授过这个编程入门课的人都知道后续课程中对教师的期待通常都很高：每一个教师期待所有的学生都熟悉计算环境和他们想使用的方法。一个物理教授可能期待一些学生在周末设计一个程序来跑一个仿真实验；一个工程教授可能期望其他学生使用一个特定的包来求解数值微分方程；或者一个计算机科学教授可能期待了解一个特定编程环境的知识。满足如此之多的期待现实吗？是否应该为不同组的学生开设不同的入门课程？ 学院和大学已经在努力克服这些问题因为20世纪末期计算机已经广泛使用。我们对他们的回答体现在这种常见的编程入门教程中，这类似于数学、物理、生物和化学等领域普遍认可的入门课程。《Python编程导论》致力于为所有理工科学生提供所需的基础准备，同时传达一个明确的信息：关于计算机科学，需要理解的远不止编程。使用本书授课的教师可以期望学生掌握必要的知识和经验，使他们能够适应新的计算环境，并在各种应用中有效地利用计算机。 学完基于这本书的课程的学生，在后续课程中有望实现什么目标呢？ 我们要传达的信息是，编程并不难学，而且驾驭计算机的能力会带来回报。掌握本书内容的学生，已准备好应对日后职业生涯中可能出现的任何计算难题。他们会了解到，像Python所提供的现代编程环境，有助于开启解决他们日后可能遇到的任何计算问题的大门，并且他们会获得学习、评估和使用其他计算工具的信心。对计算机科学感兴趣的学生将为追求这一兴趣做好充分准备；理工科的学生也将为将计算融入他们的学习做好准备。 图书网站：大量补充本文的信息可在以下网站找到： 为简便起见，我们在全文中将此网站称为“图书网站”。该网站包含供教师、学生以及本书普通读者使用的资料。我们在此简要介绍这些资料，不过，正如所有网络用户所知，最好的了解方式是自行浏览。除了少数用于支持测试的内容外，这些资料全部公开可用。 该网站最重要的意义之一在于，它使教师和学生能够使用自己的电脑来教授和学习相关内容。任何拥有电脑和浏览器的人，只需按照网站上的一些说明操作，就可以开始学习编程。这个过程并不比下载一个媒体播放器或一首歌曲难。和任何网站一样，我们的网站也在不断发展。对于拥有这本书的每个人来说，它都是必不可少的资源。特别是，补充材料对于我们将计算机科学纳入所有科学家和工程师教育体系这一目标至关重要。 对于教师而言，图书网站包含有关教学的信息。这些信息主要围绕我们在过去十年中形成的一种教学风格进行组织，即我们每周面向众多学生开设两次讲座，同时每周安排两次小组课，学生在小组课上与教师或助教进行交流。图书网站上有讲座的演示幻灯片，这些幻灯片奠定了教学基调。 对于助教而言，该图书网站包含详细的习题集和编程项目，这些内容基于书中的练习，但包含更多细节。每个编程作业旨在通过有趣的应用场景传授相关概念，同时为每位学生提供富有吸引力且引人入胜的挑战。作业的逐步推进体现了我们教授编程的方法。该图书网站全面规定了所有作业，并提供详细、有条理的信息，帮助学生在规定时间内完成作业，包括建议方法的描述以及课堂教学内容的大纲。 对于学生而言，本图书网站提供了便捷获取书中大部分内容的途径，包括源代码，还有额外的有助于自学的资料。书中许多练习题都配有答案，包括完整的程序代码和测试数据。与编程作业相关的信息也极为丰富，涵盖建议的方法、清单、常见问题解答以及测试数据。 ","link":"https://leichen2552.github.io/post/introduction-to-programming-in-python-an-interdisciplinary-approach/"},{"title":"Make小结","content":" overview overview 其实用make作为工程管理其实是一件很难受的事情，因为现在各种的IDE都把编译链接这些东西封装起来，导致用make的人越来越少，而且学习make是一件时间成本很高的事情，以至于很多人都不愿意去学。 //test.c #include &lt;stdio.h&gt; int main(){ int distance = 100; printf(&quot;You are %d miles away.\\n&quot;, distance); } 上面是一个test.c文件，在命令行执行make test，再执行./test你能看到如下的显示： make test cc test.c -o test ./test You are 10 miles away. 很奇怪对不对，我们都没有写Makefile，为什么能编译出我们想要的。make里面内建了一些规则，它就是一个规则机器。规则说，在给定了一个target后，所以在make test中，test就是目标，make会去当前目录下寻找同名但是不同后缀名的文件，从而进行编译，但是目标test的依赖我们并没有去指明。这是远古传说中的隐含依赖，这些远古传说来自于几十年的C代码构建经验，我们不需要告诉make所有事情，make本来就知道怎么构建C文件。 我们可以去指定一个Makefile文件： CFLAGS=-Wall -g all: clean test clean: rm -rf test 执行make all显示如下： make all rm -rf test cc -Wall -g test.c -o test 显然对于目标all来说，有两个依赖，一个是clean，还有一个是test。对于目标clean来说，是删除test文件，但是目标test的依赖仍然没有指定，上面已经解释过是隐含依赖。 CFLAGS是一个环境变量，可以用来设置参数，把Makefile中CFLAGS那行代码前面加个#后注释掉，然后执行CFLAGS=&quot;-Wall&quot; make all CFLAGS=&quot;-Wall&quot; make all rm -rf test cc -Wall test.c -o test ","link":"https://leichen2552.github.io/post/make-xiao-jie/"},{"title":"正则表达式汇总","content":"匹配任意字符 .字符，也就是英文句号，可以匹配任何一个单个的字符 ","link":"https://leichen2552.github.io/post/zheng-ze-biao-da-shi-hui-zong/"},{"title":"笔记：NULL、null、nullptr三者的区别","content":" 1. NULL 2. nullptr 3. &quot;&quot; 其实null和NULL都是字符串（没啥区别，欢迎高手纠错！），具体看它们宏定义被定义成为什么值。 在VS中NULL被定义为0，因为习惯上把宏定义的所有字符都大写，当把NULL它赋值给指针时意思为空，当然你也可以把null定义为0了，都一样。 它们都没定义时都只能叫符号了，定义后就有另外的意思了，你把0直接赋值给指针也行，只要指针指向0就为空。 其实NULL在有些编译器中是赋为0了，这时你不能再去#define定义它了，否则就重定义了！ 1. NULL #ifdef __cplusplus #define NULL 0 #else #define NULL ((void *)0) #endif 在C语言环境下，由于不存在函数重载等问题，直接将NULL定义为一个void的指针就可以完美的解决一切问题。 但是在C++环境下情况就变得复杂起来，首先我们不能写这样的代码： FILE fp = (void*)0; //将void*直接赋值给一个指针是不合法的，编译器会报错。 我们只能这样写代码 FILE* fp = (FILE*)0; // or FILE* fp = 0; 2. nullptr C++11，其中有一个是新的关键字nullptr 如果我们的编译器是支持nullptr的话，那么我们应该直接使用nullptr来替代NULL的宏定义。正常使用过程中他们是完全等价的。 3. &quot;&quot; &quot;&quot; 也表示空，但是和null有很大区别：null没有分配空间，&quot;&quot;分配了空间 String str1 = null; //str引用为空 String str2 = &quot;&quot;; //str引用一个空串 也就是null没有分配空间，&quot;&quot;分配了空间，因此str1还不是一个实例化的对象，而str2已经实例化。 注意： 因为null不是对象，&quot;&quot;是对象。所以比较的时候必须是 if(str1==null){...}和if(str2.equals(&quot;&quot;)){...}。 对象用equals比较，null用等号比较。 因此，如果str1=null;下面的写法错误： if(str1.equals(&quot;&quot;)||str1==null){//如果str1没有值，则.... } 正确的写法是 if(str1==null||str1.equals(&quot;&quot;)){//先判断是不是对象，如果是，再判断是不是空字符串} 打个比方：一个空玻璃杯，你不能说它里面什么都没有，因为里面有空气，当然也可以把它弄成真空，null与&quot; &quot;的区别就象真空与空气一样。 ","link":"https://leichen2552.github.io/post/bi-ji-nullnullnullptr-san-zhe-de-qu-bie/"},{"title":"数字0、字符0、\"0\"、'0'、'\\0'的区别","content":"首先把上面5种分下类，分成4类 数字0：这个0是整型，int a = 0，ASCII表里面，对应的就是0； 字符0、'0'：这这两个是char型，char c = '0'，ASCII表里面，对应的就是0x30，也就是48； '\\0'：这个是转义字符，意义是空字符(NULL)，也是字符串结束符，ASCII表里面，对应的就是0，所以'\\0' == 数字0； &quot;0&quot;：这个是字符串0，看似只有一个字符其实有两个，是字符0和转义字符'\\0'的结合，&quot;0&quot; =={ '0', '\\0' }。 ","link":"https://leichen2552.github.io/post/shu-zi-0zi-fu-0000de-qu-bie/"},{"title":"stm32f4外部晶振更换为8M时","content":"程序上设置的晶振频率跟实际外部用的晶振频率不一致，会导致时钟紊乱，比如定时器定时不准，还会导致串口传输数据错误。 将晶振频率设置成12M的步骤如下： 将stm32f4xx.h中语句 #define HSE_VALUE ((uint32_t)25000000)改作#define HSE_VALUE ((uint32_t)8000000) (这一步可能需要也可能不需要)将system_stm32f4xx.c中的语句 #define HSE_BYPASS_INPUT_FREQUENCY 25000000改作 #define HSE_BYPASS_INPUT_FREQUENCY 8000000 将system_stm32f4xx.c中 #define PLL_M 25 改作 #define PLL_M 8 ","link":"https://leichen2552.github.io/post/stm32f4-wai-bu-jing-zhen-geng-huan-wei-8m-shi/"},{"title":"五次实验记录","content":"3月27日第一次实验记录 开学以来的第一次试验，地点是在解放军301医院那边的码头。 获取测深仪的数据，为学长的实验作准备，水深大概是5米。期间还看到大水母。关于测深仪真是一言难尽，测深仪的上位机是用老古董VC++6.0开发的，所以要使用上位机的话，必须安装VC++6.0.幸好我的电脑是win7系统，还可与之一战。就后续实验，他们的电脑是win10，没有一个能把VC++6.0企业版装成功的。因为301医院地处原因，期间有个做水下设备的人员与我们探讨，并且还给我们指了一条明路。 水下图像数据获取。 4月4日第二次实验记录 第二次实验，地点是红塘湾，也是教训最为惨痛的一次。 学长的设备可以下水了。这次做了一个接插件(如图)，利用12个螺丝在周围压紧固定。 因为之前那个设备拧不开，包括头部拧上去太难了。这次接插件的只要目的就是衔接上下，然后用螺丝固定。接插件的内嵌部分采用双层的密封圈挤压防水，两层衔接部分采用一层密封圈防水。 本以为层层防水之下不会再漏水，科是整个设备刚如水，就推进器在水面短暂地旋转之后就停止工作，数据也没有出现。急忙拉上来之后，原来是进水了。主板也烧了。心情异常复杂 后来导师提议把所有内部东西拆了，先检测防水。试验之后，漏水量挺多。初步怀疑是密封圈的尺寸太小导致的漏水。 这次来回搬设备真的挺累，26千克的东西，下次得带个小车托运。 4月17日第三次实验记录 千呼万唤始出来，地点还是红塘湾，依稀记得那天的太阳仍然是那么毒辣，跟清明节那天的比起来，热度丝毫不减 在这个实验开始之前，学长更换了不同类型的防水密封圈，可是在7~8米水深下，依然漏水。这真的不知道是什么原因了。但是作为看过所有柯南剧场版的我来说，”排除所有的不可能，剩下的即使再难以相信，那也是真相“。所以要么就是头部的胶开裂漏水，要么就是尾部的胶开裂漏水。 4月24日第四次实验记录 这回真的是背水一战了，毫无退路。环氧树脂AB胶在头部以及尾部完完全全封了一层，并且在水缸中测试了一遍。这次依旧是红塘湾，在设备下水呆了近十分钟之后，拉上来看，还是漏水，但是此时进水不多，很少。 学长提议把电池啥的装进去，因为装进去盖上的操作，然后衔接器的内嵌部分抵住电池盖，其实一开始并没有抱太大希望，因为水这个东西，无孔不入。所以先让学长准备，然后我们去做了另一个实验。回来把电池盖安装好，在电池盖的背面加上了配重块，然后再放下去测试。 很意外，舱内没有进水！ 结果非常好，没有漏水！ 非常好，没有漏水！ 紧接着，我们又把控制电路放进设备中，姿态数据完全出来了，但是深度闭环数据并没有出来！也不知道是什么原因，所以这次算50%的成功！ 4月30日第五次实验记录 赶在四月的最后一天，因为上次深度数据没有出来，所以没办法完成推进器的PWM与深度的闭环。经过这几天的修改程序，应该差不多吧。 两点半出发，到那三点，整理东西到场地三点半，就在准备下水的时候，忘记带数据线了，也就是开发板和电脑的数据线。这里提一下，开发板和潜水器是通过485总线来通信的。电脑和开发板通过USB转串口的线来通信，线的接口类型是MINI-USB，这种接口在也被称为老式的USB接口。本以为老师的车上有，同门去拿过来的线是micro-usb，途中还撞得头破血流。没办法，老师开车带着我去离着最近的镇上去买，也不知道跑了多少家中国移动、中国电信、华为体验店、文具商行，最后在一家中国移动的维修处那里买到了两根线。 开始实验，从一开始计算的浮力数据来看，只需要加四个配重块就可以进行闭环控制。但是实验结果并不对。后来把配重块卸了，继续实验，还是不行。原因就是设备太重，推进器反推最大也没办法浮起来，这个设计上的缺陷，没办法改变。而且设备旋转的很厉害，那么就把后面绕的绳子不停地上劲，打结，甚至推进器在水下被485的线缠绕，甚至推进器缠绕上了水中垃圾。 其实从去年跟学长讨论闭环的时候，我就提议，这个闭环应该是深度和PWM之间构成的闭环。什么意思呢？因为电脑通过上位机发指令给开发板，开发板把指令发给水中的潜水器，然后潜水器执行操作。 ","link":"https://leichen2552.github.io/post/di-san-ci-shi-yan-ji-lu/"},{"title":"美的修冰箱维权","content":"记一次修美的冰箱的事件 3月25日美的冰箱第一次出现问题 冷冻室制冷达不到效果，本来应该零下18度，可是却只有零下四五度的样子。初步判断是温控器的问题 在美的公众号上报修。 3月28日第一次维修 3月28日维修师傅来换了一个温控器，一分钱没有收。本以为好了，发现还是不行。 3月29日美的冰箱第二次出现问题 现象是压缩机一直不停工作，冷藏室还是没有达到应有的制冷效果。冰箱内存储物很少，冷藏室结很厚一层冰，温控器失灵，压缩机一直工作不停。维修师傅把冰箱运回去维修。 4月6日第二次维修 售后维修在电源处加接了一个冰箱知音(在网上可查其功用)，它一个旋钮调冰箱压缩机运行时间{电接通〉，另一个旋钮调压缩机停止时间(电断开)，而冰箱自己的温控失灵问题没有解决;另一个问题就是压缩机不停的运行而冰箱冰冻室只有零下8度左右的问题，我看到压缩机两侧管道有重新焊接的痕迹，可能加了制冷制。 又继续联系维修师傅，维修师傅问我们是不是压缩机一会儿工作一会儿停止，冷藏室温度降了下来。现象确实是，但是冷藏室的温度只有4摄氏度，压缩机工作一会儿工作一会儿停下来是因为加了人工定时器（就是前面说的冰箱知音）。 其实维修师傅就是在糊弄我们，本来冰箱是没有人工定时器的，我们直接打售后。他说继续来维修。 4月8日第三次维修 维修师傅来电告知换台新冰箱，需要十几天时间。要走了淘宝订单号，换台新的。可是迟迟没有动静，等了小半个月，都没啥动静。 事情继续发展 4月25日售后来人说只能折旧退款，退659。但是我拒绝了，这不是折旧退款的事情，是现在售后修不好的事情，整机维修一年，核心零部件三年。这不满足核心零部件三年的这项条款。继续报修投诉，打400投诉，过了两天仍无动静。 4月28日6点半我又打美的400客服冰箱报修投诉。她说是25日报修投诉的？我说是的，但这几天也没人答理我，冰箱又被他们拖走了。她说需了解一下情况再回复。 4月28日8点多维修师傅打电话来说上午来送线。10点多美的客服又来电询问情况。11点58分维修师傅终于来电说在万塔街等我。我去在冰箱收回退款959元的机打印收条上签字，还在一张也是机打印的内容是冰箱收回什么的上面有许多空挌(内需填写型号丶退货原因之类，维修师傅说由他们填写)签字，这张维修师傅说需要贴在回收冰箱上。 然而4月25日那天来人只是要我写一张659元的手写收据，两一对比我怀疑是维修处擅自退款659元，然后再在机打印的两个文件上签上我的名字去美的厂家领取959元，这样近300元就到维修处的腰包。 这段时间，维修处拖延、蒙骗、暗强迫等方法，尤其25号来拖冰箱送钱时，我打电话质疑维修处的负责人(是固话女的)时，她态度蛮横、嚣张，上消协投诉好了之类。无利不起早，我当时就怀疑里面有诈。不说了，为了这事这一阵挺累的，好了，终于守得云开见月明！ 后记 美的的售后维修并不是美的总部开的，我觉得是一种加盟的方式。比如某个地方有一个修冰箱的小作坊，然后越修店面越大，后来就加盟美的售后维修。从某种程度上说这种开售后维修的方式有点像外包。经此事件，对美的的好感度大减，天下的乌鸦一般黑。 ","link":"https://leichen2552.github.io/post/mei-de-xiu-kong-diao-wei-quan/"},{"title":"PCB 工艺设计规范","content":"PCB 工艺设计规范 1.目的 规范产品PCB工艺设计，规定PCB工艺设计的相关参数，使得PCB的设计满足课生产性，可测试性、安规、EMC、EMI等的技术规范要求，在产品设计过程中构建产品的工艺、技术、质量、成本优势。 2.使用范围 本规范适用于所有的电子产品的PCB工艺设计，运用于但不限于PCB的设计、PCB投板工艺审查、单板工艺审查等活动。 本规范之前的相关标准、规范的内容如与本规范的指定相抵触的，一本规范为准。 3.定义 导通孔(via)：一种用于内层连接的金属化孔，但其中并不用于插入元件或其他增强材料。 盲孔(Blind via)：从印刷板内仅延展到一个表层的导通孔。 埋孔(Buried via)：未延伸到印刷版表面的一种导通孔。 过孔(Through via)：从印制板的一个表面延展到另一层表面的导通孔。 元件孔(Component hole)：用于元件端子固定于印制板及导电图形电器联接的孔。 Stand off：表面贴器件的本体底部到引脚底部的垂直距离。 4.引用/参考标准或资料 TS--S0902010001 《信息技术设备PCB安规设计规范》 TS--SOE0199001 《电子设备的强迫风冷热设计规范》 TS--SOE0199002 《电子设备的自然冷却热设计规范》 IEC60194 《印刷版设计、制造与组装术语与定义》（Printed Circuit Board design manufacture assembly-terms and definituons） IPC--A--600F 《印刷版的验收条件》(Acceptably of printed board) IEC60950 5.规范要求 5.1PCB板材要求 5.1.1确定PCB使用板材以及TG值 确定PCB所选用的板材，例如FR--4、铝基板、陶瓷基板、纸芯板等，若选用高TG值得板材，应在文件中表明厚度公差。 5.1.2确定PCB的表面处理镀层 确定PCB铜箔的表面处理镀层，例如镀锡、镀镶金或OSP等，并在文件中注明 5.2热设计要求 5.2.1 高热器件应该考虑放于出风口或利于对流的位置 PCB在布局中考虑将高热器件放于出风口或利于对流的位置。 5.2.2 较高的元件应考虑放于出风口，且不阻挡封路 5.2.3 散热器的放置应考虑对流 5.2.4 温度敏感器械件应该要考虑热源 对于自身温升高与30摄氏度的热源。一般要求： a. 在风冷条件下，电解电容等温度敏感器件离热源距离要求大于或等于2.5mm； b. 自然冷条件下，电解电容等温度敏感器件离热源距离要求大于或等于4.0mm。 若因为空间的原因不能达到要求距离，则应通过温度测试保证温度敏感器件的温升在降额范围内。 5.2.5 大面积铜箔要求用隔热带鱼焊盘相连 为了保证透锡良好，在大面积铜箔上的元件的焊盘相连，对于需过5A以上的大电流不能采用隔热焊盘，如图所示： 5.2.6 过回流焊的0805以及0805以下片式元件两端焊盘的散热对称性 为了避免器件过回流焊后出现偏位、立碑现象，地回流焊的0805以及0805以下片式元件两端焊盘应保证散热对称性，焊盘与印制导线的连接部位宽度不应大于0.3mm(对于不对称焊盘)，如图1所示。 5.2.7 高热器件的安装方式及是否考虑带散热器 确定高热器件的安装的安装方式易于操作和焊接，原则上党员器件的发热密度超过0.4W/cm3cm^3cm3，单靠元器件的引线腿及器件本省不足充分散热，应采用散热网、汇流条件等措施来提高过电流能力，汇流条的支脚应采用多点连接，尽可能采用铆接后过波峰焊或直接过波峰焊接，以利于装配、焊接；对于较长的汇流条的使用，应考虑过波峰时受热汇流条与PCB热膨胀系数不匹配造成的PCB变形。 为保证搪锡易于操作，锡道宽度应不大于等于2.0mm，锡道边缘间距大于1.5mm。 5.3 器件库选型要求 5.3.1 已有PCB元件封装库的选用应确认无误 PCB上已有元件库器件的选用应保证封装与元器件实物外形轮廓、引脚间距、通孔直径等相符合。 插装器件管脚与通孔配合良好(通孔直径大于管脚直径8 -- 20mil)，考虑公差可适当增加，确保透锡良好。 元件的孔径形成序列化，40mil以上按5mil增加，即40mil、45mil、50mil、55mil......；40mil一下按照4mil递减，即36mil、32mil、28mil、24mil、20mil、16mil、12mil、8mil。 器件引脚直径与PCB焊盘孔径的对应关系，以及二次电源插针焊脚与通孔回流焊的焊盘孔径对应关系如表1： 建立元件封装库存是应将孔径的单位换算为英制(mil)，并使孔径满足序列化要求。 5.3.2 新器件的PCB封装库存应确定无误 PCB上尚无件封装库的器件，应根据器件资料建立打捞的元件封装库，并保证丝印库存与实务相符合，特别是新建立的电磁元件、自制结构件等的元件库存是否与减员的资料(承认书、图纸)相符合。新器件应建立能够满足不同工艺(回流焊、波峰焊、通孔回流焊)要求的元件库 5.3.3 需过波峰焊的SMT器件要求使用表面贴波峰焊盘库。 5.3.4 轴向器件和条线的引脚间距的种类应尽量少，以减少器件的成形和安装工具。 5.3.5 不同PIN间距的兼容要有单独焊盘孔，特别是封装箭筒的继电器之间个兼容焊盘之间要连线。 5.3.6 锰铜丝等作为测量用的跳线的焊盘要做成非金属化，若是金属化焊盘，那么焊接后，焊盘内的那段电阻江北短路，电阻的有效长度将变小而且不一致，从而导致测试结果不准确。 5.3.7 不能用表贴器件作为手工焊的调测器件，表贴器件在手工焊接是容易受热冲击损坏。 5.3.8 除非实验验证没有问题，否则不能选用和PCB热膨胀系数差别太大的无引脚表贴器件，这容易引起焊盘拉托的现象。 5.3.9 除非实验验证没有问题，否则不能选非表贴器件使用。因为这样可能需要手焊接，效果和可靠性都会很低。 5.3.10多层PCB侧面局部镀铜作为用于焊接的引脚时，必须保证每层均有铜箔相连，以增加镀铜的附着强度，同时要有实验验证没有问题，否则双面板不能采用侧面镀铜作为焊接引脚。 5.4 基本布局要求 5.4.1 PCBA加工工序合理 制成板的元件布局应保证制成板的加工工序合理，以便于提高制成板加工效率和直通率。PCB布局选用的加工流程应使加工效率最高。 常用PCBA的6种主流加工流程图如表2： 5.4.2 波峰焊加工的制成板进板方向要求有丝印表明 波峰焊加工的制成板进板方向应在PCB上标明，并使进板方向合理，若PCB可以从两个方向进板，应采用双箭头的进板标识。 5.4.3 两面过回流焊的PCB的BUTTOM面要求无大体积、太重的表贴器件需两面都过回流焊的PCB，第一次回流焊接器件重量限制如下： AAA = 器件重量/引脚与焊盘接触面积 片式器件 A≤0.075g/mm2A \\leq 0.075g/mm^2A≤0.075g/mm2 翼形引脚器件：A≤0.300g/mm2A \\leq 0.300g/mm^2A≤0.300g/mm2 JJJ形引脚器件：A≤0.200g/mm2A \\leq 0.200g/mm^2A≤0.200g/mm2 面阵列器件：A≤0.100g/mm2A \\leq 0.100g/mm^2A≤0.100g/mm2 若有超重的器件必须不在BOTTOM面，则应通过实验验证可行性。 5.4.4 需波峰焊加工的单板背面器件不形成阴影效应的安全距离已考虑波峰焊工艺的SMT器件距离要求如下： 相同类型器件距离(见图2) 5.4.5 大于0805封装的陶瓷电容，布局是尽量靠近传送边或应力较小区域，其轴向尽量与进板方向平行(图4)，尽量不使用1825以上的尺寸的陶瓷电容。(保留意见) 5.4.6 经常插拔器件或板边连接器周围3mm范围内尽量不布置SMD，以防止连接器插拔时产生的应力损坏器件，如图5： 5.4.7 过波峰焊的表面贴器件的stand off符合规范要求 过波峰焊的表面贴器件的stand off应小于0.15mm，否则不能布在B面过波峰焊，若器件的stand off 在 0.15mm 与 0.2mm 之间，可在器件本体底下布铜箔以减少器件本体底部与 PCB 表面的距离。 5.4.8 波峰焊时背面测试点不连锡的最小安全距离已确定 为保证过波峰焊时不连锡，背面测试点边缘间距应大于1.0mm 5.4.9 过波峰焊的插件元件焊盘间距大于1.0mm 为保证过波峰焊时不连锡，过波峰焊的插件元件焊盘边缘间距应大于1.0mm(包括元件本身引脚的焊盘边缘间距)。 优选插件元件间距(pitch) ≥\\geq≥ 2.0mm，焊盘边缘间距 ≥\\geq≥ 1.0mm 在器件本体不相互干涉的前提下，相邻器件焊盘边缘间距满足图6要求： 插件元件没牌引脚为较多，以焊盘排列方向平行于进板方向布置器件时，当相邻盘边缘间距0.6mm -- 1.0mm时，推荐采用椭圆形焊盘或偷加锡焊盘(图7)。 5.4.10 BGA周围3mm内无器件 为了保证可维修性，BGA器件周围需留有3mm禁布区，最佳为5mm禁布区。一般情况下BGA不不允许放置背面(两次过回流焊的单板第第一次过过回流焊面)；当背面有BGA器件时，不能在正面BGA5mm禁布区的投影范围内布器件。 5.4.11 贴片元件之间的最小间距满足要求 机器贴片之间器件距离要求(图8)： 同种器件：≥\\geq≥ 0.3mm 异种器件：≥\\geq≥ 0.13*h+0.3mm(h为周围近邻元件最大高度差) 只能手工贴片的元件之间距离要求：≥\\geq≥ 1.5mm 5.4.12 元器件的外侧距过板轨道接触的两个板边大于、等于5mm。(图9) 为了保证制成板过波峰焊或回流焊，传送轨道的卡抓不到元件，元器件的外侧距板边距离应大于或等于5mm，若达不到要求，则PCB应加工艺边，器件与V--CUT的距离 ≥\\geq≥ 1mm。 5.4.13 可调器件、可插拔器件周围留有足够的空间供调试和维修。 应根据系统或模块的PCBA安装布局以及可调器件的调测方式来综合考虑可调器件的排布方向、调测空间；可插拔器件周围空间预留应根据邻近器件的高度来决定。 5.4.14 所有的插装磁性元件一定要有坚固的底座，禁止使用无底座插装电感。 5.4.15 有极性的变压器的引脚尽量不要设计成对称形式。 5.4.16 安装孔的禁布区内无元器件和走线(不包括安装孔自身的走线和铜箔)。 5.4.17 金属壳体器件和金属件与其他器件的距离满足安规要求。 金属壳体器件和金属件的排布应在空间上保证与其他器件的距离满足安规要求。 5.4.18 对于采用通孔回流焊器件布局的要求 a. 对于非传送边尺寸大于300mm的PCB，较重的器件尽量不要布置在PCB的中间，以减轻由于插装件在重量在焊接过程中对PCB变形的影响，以及插装过程对板上已经贴放的器件的影响。 b. 为方便插装，器件推荐布置在靠近插装操作侧的位置 c. 尺寸较长的器件(如内存条插座等)长度方向推荐与传送方向一致。 d. 通孔回流焊器件焊盘边缘与pitch ≤\\leq≤ 0.65mm的QFN、SOP、连接器及所有的BGA丝印之间要 &gt;&gt;&gt; 10mm，与其他SMT器件间距 &gt;&gt;&gt; 2mm。 e. 通孔回流焊器件本体间距离 &gt;&gt;&gt; 10mm。有夹具扶持的插针焊接不做要求。 f. 通孔回流焊器件焊盘边缘与传送边的距离 &gt;&gt;&gt; 10mm；与非传送边距离 &gt;&gt;&gt; 5mm。 5.4.19 通孔回流焊器件禁布区要求 a. 通孔回流焊器件焊盘周围要留出足够的空间进行焊膏涂布，具体禁布区要求为：对于欧式连接器靠板内的方向10.5mm不能有器件，在禁布区之内不能有器件和过孔。 b. 须放置在禁布区内的过孔要做阻焊塞孔处理。 5.4.20 器件布局要整体考虑单板装配干涉 器件在布局设计时，要考虑单板与单板、单板与机构件的装配干涉问题，尤其是高器件、立体装配的单板等。 5.4.21 器件和机箱的距离要求 器件布局时要考虑尽量不要太靠近机箱壁，以避免将PCB安装到机箱是损坏器件。特别注意安装在PCB边缘的，在冲击和振动时会产生秦伟移动或没有兼顾的外形的器件：如立装电阻、无底座电感变压器等，若无法满足上述要求，就要采取另外的固定措施来满足安规和振动要求。 5.4.22 有过波峰焊接的器件尽量布置在PCB边缘以方便堵孔，若器件布置在PCB边缘，并且式装夹具做的好，在波峰焊接是甚至不需要堵孔。 5.4.23 设计和布局PCB时，应尽量允许器件过波峰焊接。选择器件时尽量少选不能过波峰焊接的器件，另外放在焊接面的器件应尽量少，以减少手工焊接。 5.4.24 裸跳线不能贴板跨越版上的导线或铜皮，以避免和板上的铜皮短路，绿油不能作为有效的绝缘 5.4.25 布局时考虑所有器件在焊接后易于检查和维护。 5.4.26 电缆的焊接端尽量靠近PCB的边缘布置以便插装和焊接，否则PCB上别的器件会阻碍电缆的插装焊接或被电缆碰歪。 5.4.27 多个引脚在同一直线上的器件，象连器件、DIP封装器件、T220封装器件，布局时应使其轴线和波峰焊方向平行。(图11) 5.4.28 较轻的器件如二极管和 1/4W1/4W1/4W 电阻等，布局时应使其轴线和波峰焊方向垂直。这样能防止波峰焊时因一端先焊接凝固而使器件产生浮高现象。(图12) 5.4.29 电缆和周围器件之间要留有一定空间，否则电缆的折弯部分会压迫并损坏收尾器件及其焊点。 5.5 走线要求 5.5.1 印制板边距离：V-CUT 边大于0.75mm，铁槽边大于0.3mm。 为了保证PCB加工时不出现露铜的缺陷，要求所有的走线及铜箔距离板边：V-CUT边大于0.75mm，铁槽边大于0.3mm(铜箔离板边的距离还应满足安装要求)。 5.5.2 散热器正面下方无走线(或已作绝缘处理) 为了保证电器绝缘性，散热器下方周围应无走线(考虑到散热器安装的偏位及安规距离)，若需要在散热器下布线，则应采取绝缘措施使散热器与走线绝缘，或确认走线与散热器是同等点位。 5.5.3 金属拉手条底下无走线 为了保证电气绝缘性，金属拉手条底下应无走线。 5.5.4 各类螺钉孔的禁布区范围要求 各种规格的螺钉的禁布区范围如以下表 5 所示(此禁布区的范围只适用于保证电气绝缘的安装空间，未考虑安规距离，而且只是用圆孔) 本体范围内有安装孔的器件，例如插座的铆钉孔、螺钉安装孔等，为了保证电器绝缘性，夜莺在元件库中将也的禁布区标识清楚。 5.5.5 要增加孤立焊盘和走线连接部分的宽度（泪滴焊般）特别是对于单面板的焊盘，以避免过波峰焊接时将焊盘拉脱。 腰形长孔禁步区如下表6： 5.6 固定孔、安装孔、过孔要求 5.6.1 过波峰的 ","link":"https://leichen2552.github.io/post/pcb-gong-yi-she-ji-gui-fan/"},{"title":"《硬件详细设计文档》解析之五 可靠性指标","content":" 可靠性要求分类 定性要求用一种非量化的形式来设计、评价和保证产品的可靠性。 定量要求规定产品的可靠性参数、指标和相应的验证方法。用定量方法进行设计分析，进行可靠性验证，从而保证产品的可靠性。 在详细设计的过程中，需要定量的计算可靠性指标，达成可靠性的定量要求。 ","link":"https://leichen2552.github.io/post/lesslessying-jian-xiang-xi-she-ji-wen-dang-greatergreater-jie-xi-zhi-wu-ke-kao-xing-zhi-biao/"},{"title":"《硬件详细设计文档》解析之四 归一化审查","content":"归一化工作按照层次分类：器件归一化，电路板归一化，硬件平台归一化，网络结构归一化； 平台归一化是：一套硬件平台，通过不同的硬件模块的组合，承载不同的软件加载，可以支持不同的业务，既可以支持这个业务，也可以支持那个业务。例如我们以前开发的硬件平台，业务类型支持：彩信、彩铃、短信，呼叫中心、统一通信等场景。 硬件归一化其实是做出来的硬件模块，或者说硬件电路板，相同的功能模块可以支持多种功能场景，例如我们把语音编解码模块单独独立出来，作为各种编解码的处理，可以根据客户需求，处理不同的编解码的转换，同时系统也支持用户规格，选择电路模块的数量，支持不同客户规格的需求。 器件归一化 硬件工程师一般都能够理解，在一个板子上面的，尽可能的选择成本更低的器件，选择更少种类的器件，便于集中采购，同时也便于加工。但是其他公司可能没有对器件归一化的工作做得那么细致和严格。 第一， 由于华为整个公司使用的器件种类非常的多，所以如果减小一个器件编码，带来的收益是十万人民币到几百万，而其他公司可能达不到这个高的收益。所以如果能减少一个编码，宁愿选择可能成本更高的器件。但是这个也需要按照每年的器件直接成本收益*器件发货数量，与编码成本+加工成本差异，进行对比的。不过器件归一化之后，器件的价格又可以跟供应商重新谈价格，这个收益是迭代的。所以，有时即使是成本占优，也会倾向选择器件归一化的结论。例如，逐步去除了5%精度的电阻，归一化到1%。 第二， 器件归一化，都是需要进行专题分析的。因为也有工程师为了归一化，对电路原理没有充分分析，导致的归一化带来“问题引入”。所以，当时我的部门当时有一个表格，“器件归一化分析.xls”的excel表格，把每个器件，原来选型，归一化的选型，更改的原因，都做好记录和原因分析。一是让每个归一化的员工都充分考虑分析，二是问题都有记录，便于评审，三是出了问题，好打板子。 单板归一化 除了器件归一化，更高一个层次的归一化，就是单板归一化。（单板这个概念，我稍微澄清一下，我刚到华为的时候，也觉得这个词很奇怪。因为通信设备，都是机框，背板，加各个功能模块的电路板，各个功能模块的电路就叫做“单板”，硬件工程师，一般也叫做“单板硬件”） 单板归一化带来的好处，首先是电路的种类少，电路的种类少的好处有两个：一是生产成本降低，二是硬件维护成本降低，三是软件开发和维护的成本降低。 第一、单板归一化的先决条件首先是处理器归一化。其实，华为的有的产品这点做得其实不好，X86、MIPS、ARM、PPC全部都用个遍，所以一个硬件平台，需要配备各种软件人员，操作系统搞N套，VxWorks和Linux，BIOS各种配套。 第二、单板的归一化，要注意产品的衍生。第一个版本的机框上的单板所实现的功能，如果后续的产品可以使用，应该直接可以用，不需要再开发。如果不注意这点，第一个版本的单板，到第二版本时，发现不能相互借用。反过来，再修改第一个版本的电路板，来适应新版本。有时问题更糟糕，就是完全不能兼容，只好重新开发。单板的规划显得非常重要。 第三、单板归一化时，虽然电路部分兼容了，但是结构件不兼容。对于市场人员的配置来说，仍然是两种配置。一样是失败的。 平台归一化 那么如果发现不同的硬件平台的架构雷同，功能类似。那么机框也可以归一化。只需要制作不同的电路功能模块，就可以实现不同的功能需求。 但是不同的硬件形态都是有他存在的意义的，如果强行归一，市场未必会接受这种事情的发生。例如用一个运营商的平台去归一一个企业应用或者家庭应用的产品，可能就未必能够成功。 网络架构归一化 这个说法是我自己想的，早在08年的时候，华为就在讨论“云管端战略”了，当时不是很理解。当我们一个运营商平台部门，跟“服务器”的部门合并的时候，似乎理解了点什么。 当X86处理器足够强大的时候，所有的运算，不管是否性价比最高，都送到云端进行处理，那么所有中间的存储和计算都显得不重要了。那么整个网络的结构，就是终端+管道+云存储和云计算。 既然计算和存储设备都是一样的，那作为运算和存储的设备，也就不需要那么多样化了。这时网络存储设备，和服务器就显得尤为重要。 这也是华为成立IT产品线，做重点战略投资的重要原因。 所以现在也就不需要那么多网络节点和网络平台了，只需要超强的处理和存储能力和宽广的通道，多样的终端。 我们为什么需要归一化？ 第一、 减少不必要的人力投入。 以前在研究所工作的时候，由于“技术不传染”，项目组之间没有什么技术沟通，相互之间的原理图、PCB、文档、案例、基本不共享，不交流，但是大家的一些模块，功能是一样的，但是设计结果各式各样，在设计阶段就重复劳动，当出了问题之后，其实大家面对相同的功能模块，在解决不同的问题。例如，音频的放大模块，频率其实基本上是0kHz~30kHz的有效信号，都是交流耦合，按照单电源、双电源；高电源电压，低电源电压；R-8，RM-8等不同的情况，有限的分类，我们进行一致性的设计；找到一些可以进行多厂家器件兼容，设计考虑几种容限的情况。做几种类型的设计。从设计上面来说，所有人都有参考标准。如果碰到新问题，现有的设计模块不能满足时，再引入新器件及新设计。例如平时大家的放大量都是100，按照增益带宽积，已有设计能够满足很多场景的带宽（同时单位时间的电压上升率也满足）；出现10000倍放大需求的时候再评估是否需要引入新模块设计。 但是实际的设计，都是放羊式设计，你喜欢ADI的，我喜欢TI的，他喜欢用MAX的，我喜欢用FET搭。所有每人手上一套放大电路，每个人的滤波电路都不一样，ADC选型和设计也是各式各样。如果有人出了问题，没有借鉴，也没有讨论，因为一开始就没有讨论。 第二、 降低总体的采购成本。 举个例子，大家都知道，贴片电阻，如果按照一盘进行采购，大约25元左右，有5000片。按时你只买100颗相同的电阻，可能拿到的采购价格是5元。 我们可以简单对比单价：按整盘采购单价是0.5分，按照散装采购价格是5分；单价相差10倍；其实通过这样的简单对比，我们很容易理解，批发价比零售价便宜很多在器件采购这个方面，有非常明显的特性。 除了类似于电容、电阻、电感等分立器件，有这个特性；在半导体器件采购，这个特性更明显。为什么呢？因为大家知道，半导体的主要原料是二氧化硅，也就是这个世界上取之不尽用之不竭的物质“沙子”；在一个芯片被成功设计和量产之后，其原料成本是非常有限的，主要的成本都是早期投入，例如研发投入，生产线投入，而这两部分的投入支出都非常的庞大。 几乎所有的芯片都是阶梯价，也就是你采购量越大，得到的价格就越便宜。 曾经待在华为的硬件平台部门。其实在硬件平台部门，主要的目标就是把公司各个业务承载在相同的硬件上，用最少量的硬件研发人力承载最大的营收。减少重复的研发投入，并且降低总体的采购成本。但是其实我们阶段性的成果，造成的局面是一个硬件平台，处理有7、8种，X86多种、单核PPC、多核PPC、MIPS、ARM……从器件采购上面来说没有形成优势，从研发上面来说，每套开发的人员需要的技能都不一样，在开发和维护阶段的人力投入都非常巨大。在器件采购上面，每种器件的使用量都比较有限，在商务上没有特别的突破。 同时降低，管理成本、资金占用成本，库存成本。 第三、 更高的产品质量。 如果产品设计形成合力，相同的器件、相同的模块、相同的电路，其的发货量比较巨大，暴露出来的问题往往也是概率性的，层次也比较深入。一些低级的问题，由于涉及的人员比较多，投入度也得到保证，所以在设计早期就已经解决的比较充分，并且当设计新电路的时候，可借鉴参考的内容也比较多，可讨论的同事也比较多。如果你选用一款器件，而这款器件被同事选用，已经产品化，并且海量发货。那么你选用这颗芯片的时候，不但这颗芯片被大批量验证过了，而且设计已经解决了已经发现的问题，同时由于你的选用，可能增加这颗芯片的发货量，也进一步增加商务谈判的砝码。 我们如何实施归一化？ 平台归一化，这个设计场景比较少，架构师在考虑平台归一化的时候，往往是业务驱动。通过现有产品发现，哪些业务可以通过重新规划电路的功能集合，完成新的电路模块的划分，实现新的硬件平台可以涵盖更多的使用场景。例如经典的硬件平台ATCA。 ATCA（Advanced TelecomComputing Architecture）标准即先进的电信计算平台，它脱胎于在电信、航天、工业控制、医疗器械、智能交通、军事装备等领域应用广泛的新一代主流工业计算技术——CompactPCI标准。是为下一代融合通信及数据网络应用提供的一个高性价比的，基于模块化结构的、兼容的、并可扩展的硬件构架。 ATCA总线主要针对电信运营级应用，为下一代通信及数据网络应用提供了一个高性价比、模块化、兼容性强、并可扩展的硬件构架，同时以模块结构的形式呈现，以符合现代对高速数据传输的需求，为新一代电信运营设备提供了一个“可靠、可用、适用”的解决方案。 正是由于ATCA优越的“高性价比，模块化合理，兼容性强，可扩展性强”的特点，所以具备特别强的生命力。与ATCA的类似的还有其他种类的硬件平台，往往没有这么长的生命周期，或者没有这么大的市场占有率。 硬件单板归一化，强调的是在架构设计的时候，模块划分比较合理，模块的复用度高，模块间的耦合度低。ATCA这样的硬件平台归一化的时候，合理的拆分功能模块，才能实现其可扩展性和兼容性的特点。在硬件单板设计的时候，模块设计的时候，就需要考虑规格设计，涵盖场景等等因素。 器件归一化，是硬件工程师，经常需要面对的问题，此处做重点描述。 第一、 处理器选型归一化。 需要考虑软件归一化。如果选用相同的处理器，那么软件即使功能模块可能不一样，但是其大多数公用模块都可以借用，相同的处理器，操作系统可以保持一致，同时驱动等底层软件都可以借用。给软件开发的便利性带来了很大的优势。特别是多版本的大规模发货的产品，由于产品本身有很多的沉淀需要传承。当操作系统的变更，会导致很多功能可能需要重新开发。 例如，华为在变革操作系统的过程，部分业务从VxWorks切换到Linux的过程，非常痛苦，首先大量的业务软件是运行在Dopra(Dopra是在不同OS之上的一层封装，提供统一接口，提供编程框架。)当你选用新的Linux版本的时候，Dopra都需要跟随进行补丁，或者重新确立版本。另外，大量的生产测试，是基于VxWorks上进行开发的，如果需要移植到Linux，则需要花费大量的人力物力。一些运行Linux的电路板就运行双操作系统，在业务状态下，电路启动之后就先进入VxWorks，如果需要进入生产装备等状态，则相关按键进入。如果是正常业务，再次引导Linux进入Linux进行业务运行。 所以我们成熟平台上，进行处理器选型，尤其要注意电路的继承性。 第二、 内存类型的选型归一化 一个平台的生命周期需要考虑其所有器件的生命周期的健康性。而内存类的器件，往往生命周期并没有平台的生命周期长。所以在器件选型的时候，需要注意两个生命周期的配合。选型某款DSP的时候，其外围的存储器件只能选用SDRAM,但是同一平台的其他器件已经进入DDR2时代；但是由于X86更新换代比较快，很快配套内存选用DDR3。当平台发布没多久，几个大的存储器件厂家宣布SDARAM停产了。但是由于整个平台只有这么一个设计的位置选用了SDRAM，导致备货都无法开展。根据发货量预测到平台生命周期结束，对SDRAM进行备货。所以我们在选型的时候，哪怕有各种规格的DDR，但是也需要考虑归一化，这样哪怕备货的时候，也能形成批量采购获得价格优势，或者发货量大去影响其生命周期，或者扶持一些小的器件厂商进行替代。 第三、 电阻、电容、电感等无源器件归一化 电阻，我们需要在电阻精度上面进行归一化，若干年前，当生产电阻时，其精度还不那么容易控制的时候，我们需要根据设计，选用精度相对不那么高的电阻以降低成本。但是目前来说1%精度的电阻，与5%精度电阻的价格差异不再那么大的时候。我们可以统一选用1%，不但增加了统一采购的数量，以此来获得批量采购的价格优势，同时由于减少了器件的种类，降低了生产的时间。在阻值方面也可以做一些归一化的工作，例如一些对阻值不是那么敏感的设计中，我们可以进行一些器件归一化的，例如一些远离有用信号的RC滤波，相对不需要那么准确的精度，我们27欧姆归一化到33欧姆，这种对滤波结果影响不大的场景，可以选择归一化。同时，有些电阻阻值在整板，只有一个器件（20k），我们可以选择两个电阻的阻值之和（两个10k）来实现，来实现归一化。 但是我们不能为了归一化而归一化，在减少器件种类或者减少器件数量的时候，一定需要考虑归一化之后对电路的影响。当年我们开发Corei7嵌入式版本开发，第一版的时候工作都正常的，调测完成之后，进入产品化阶段。但是回板之后，电路无法正常工作。原来是硬件人员没有进行评估，把处理器的外围晶振的对地电容18pF归一化到30pF，导致的晶振不起振。 第四、通用化IC归一化 电源、时钟、运放、分立器件等这些通用性很强的器件，可以考虑归一化。同时做好不同厂家最好是PIN2PIN的替代方案。 例如电源，我们选定了一种规格，例如12V输入，5V输出，电流10A，整个公司都可以选择同一种解决方案。不需要不同的工程师选择各种厂家的解决方案，电路设计、芯片选型都不一致，但是功能完全一致的电路方案。但是，我们需要关心，即使是不同厂家的相同型号，也有可能有一些微弱的差异。以下以706看门狗为例，虽然各个厂家型号、封装、管脚定义都一样。但是具体规格却是有比较大的差异。 ","link":"https://leichen2552.github.io/post/lesslessying-jian-xiang-xi-she-ji-wen-dang-greatergreater-jie-xi-zhi-si-gui-yi-hua-shen-cha/"},{"title":"《硬件详细设计文档》解析之三 单元详细描述","content":"单元详细描述 这部分内容，一般是大家都敷衍的一个内容。因为总体设计阶段，已经写了一些专题分析，例如电源专题、时钟专题，都是套套模板，然后例行公事。所以，这时候很多工程师，都是从总体设计里面摘录一些内容，填上，就完事儿了。把总体设计的一些内容，直接填充到这个章节，就自然形成了各个单元模块的内容。 专题分析如何做，我们在之前的文章做过分享： 第一、 例行的，每个电路一般都会做几个必选的专题：电源、时钟、小系统；把每个管脚怎么用，怎么接，对接的管脚的电平是否满足要求，都需要文档化，分析清楚。在选用新器件的话，对应硬件工程师的工作量还是比较大的。但是如果是其他公司，直接按照推荐电路设计就完事了。电源专题，需要分析电源需求，每种电源的电压范围，电流需求，动态响应，上电时序；时钟专题，针对每个时钟的输入的电平标准，频率，抖动等参数，时钟时序，并按照各种时钟解决方案进行优化； 第二、 当电路设计过程中，碰到一些新的问题，之前团队中没有接触过的问题，或者认为是重点，难点的内容，会专门做这个问题点的专题分析：例如我们做过的一些双BIOS启动，摄像头的红外LED的驱动，主备倒换啊，之类的，就会把一个问题点分析透，然后再动手做画原理图。 第三、 那么在开发硬件的时候，Demo只是作为参考，每一个依据都是来自于datasheet，除了看芯片的数据手册之外，还要仔细查看数据手册的勘误表errata，核对datasheet与Demo的差一点，如果器件有checklist还得核对checklist。曾经开发AMD的时候，datasheet、Demo、checklist，三个文档对不上的情况。也出现过，一个比较难复现的问题，后来查看了Errata，发现是厂家芯片升级了，修正了bug，而我们还在采购老版本的芯片。 本次在解析详细设计文档，咱们再补充几点： 1、例行的电源、时钟、复位专题，即使是套模板，也是需要例行公事的，去认真的去套模板。这是前人摸索出来的经验和套路，我们按照模板填写就可以了，在填写模板的过程中，肯定会有新发现和新收获。模板是最好的积累。 例如在电源专题中，需要整理所有组件的电压和功耗。在我们整理电压的时候，其实会重新考虑我们的电源需求，是否有需要合并的电源，是否有更简洁的设计。在整理功耗的时候，会重新审视电源的负载能力，以及整个电路的散热能力。 再例如，下图的电源树。通过这种拓扑的方式，能够更直观的检查电源设计是否合理，能力是否满足，时序是否正确。 2、一些新问题，如果在例行的专题没有分析，可以单独设立“专题分析”，特别是新电路、新设计、新接口等。 当我们在设计的过程中，模板中没有内容，往往就会在大脑中完成了设计。而在反复评审的文档中，并没有体现。此时我们需要单独设立专题分析，把设计过程显性化。此处再一次强调文档的重要性。 对于写作者，是对设计过程的复盘，系统的思考。 特别是一些没有成熟电路可以借鉴的设计，我们一定要把设计过程文档化，一是便于评审，二是，写文档的过程会提高设计质量，避免设计错误，提升设计的逻辑严谨性。 3、在写专题分析的时候，是孤立的思考。例如电源专题可能是一个人做的，而时钟专题是另外一个人做的。所以在整合的时候，我们需要系统的思考，一些单元之间是有耦合关系的。在整合的时候，我们会有单元之间的信息交互，此处内容整合到一起之后，容易发现一些单元之间可能忽视的问题。例如时钟模块的供电需求，很可能被忽略，但是在时钟专题的时候可能提到。在整合信息的时候，发现我们提供的电源虽然基本数据满足要求，但是纹波可能不能满足时钟单元的要求。 ","link":"https://leichen2552.github.io/post/lesslessying-jian-xiang-xi-she-ji-wen-dang-greatergreater-jie-xi-zhi-san/"},{"title":"《硬件详细设计文档》解析之二 单板上电、复位设计","content":"&lt;详细说明单元间复位顺序、Watchdog设计、复位单元加载顺序。如果提供局部及全局分级复位请说明其层次关系。需要给出图示和文字解释。给出单板复位、断电重启的流程图。并粗略估计各流程所需的时间。需要结合故障管理方案，考虑在故障情况下的复位重启要求&gt; &lt;复位重启时间指系统从运行状态，经历系统复位，重新恢复进入正常运行态的时间。复位类型通常包括：软件复位、硬件复位。主要考虑单板的软、硬件复位。复位一般包括基本的底层启动、自检、配置等。通常复位时间应在5min内。断电重启时间 指系统从运行状态，经历断电/通电，重新恢复进入正常运行态的时间。应考虑系统断电和单板断电重启，重启一般包括：基本的底层启动、自检、配置；系统通常重启时间在0.5小时之内。单板通常重启时间在10min之内。&gt; 电路板复位机制分类（3种软复位1种硬复位） 4种复位机制：reboot、BSP_ResetBoard、BSP_PowerOff、硬件狗 BSP_ResetBoard 由底层软件BSP实现，实现机制是下拉CPU管脚复位CPU（软复位）。 reboot，OS系统默认实现机制是指令跳转，重新引导系统。但目前BSP通过注册钩子接管了reboot的复位行为，接管后的复位机制与BSP_ResetBoard一样，也是下拉CPU管脚（软复位）。 BSP_PowerOff 底层软件BSP实现，实现机制是下拉电源管脚复位硬件系统（掉电复位）。 硬件狗，复位机制由硬件实现，由软件定时喂狗来保活软件系统的正常运行，复位类型为CPU复位（软复位）。 可靠复位机制（软件复位和硬件狗复位的双重保护+设计关键点：记录复位原因前，首先停止喂狗） 上述4种复位机制中，reboot、BSP_ResetBoard、BSP_PowerOff是由软件实现的，因此存在机制失效的风险，硬件狗为硬件实现可以确保系统的复位。但是硬件狗复位无法通过软件主动记录复位定位信息，因此软件复位机制也是必要的。为了既能够主动记录完善的复位定位信息又能够确保复位的真正执行，设计采用下述双层复位机制。 可靠复位机制 上述设计的一个关键点是：在记录复位原因之前，首先要停止喂狗，如果在记录复位原因或者软件复位接口出现问题没有复位成功，至少可以确保系统在延迟一段时间后看门狗复位。 复位设计的时候，电路和软件设计不但需要支持各种机制的复位方式，同时需要支持复位原因的记录。需要在主动复位之前，先发送一个不可屏蔽中断让CPU做一些复位前的准备工作，同时让CPU做一些内容记录作为电路板复位或者下电前的临终遗言。 ","link":"https://leichen2552.github.io/post/lesslessying-jian-xiang-xi-she-ji-wen-dang-greatergreater-jie-xi-zhi-er/"},{"title":"C++调试小结【C++】error:cannot declare variable ‘l’ to be of abstract type ‘xxx’","content":"问题 【C++】error: cannot declare variable ‘l’ to be of abstract type ‘xxx’ 解答 追根溯源可能是某个抽象类的纯虚函数没有得到实现！ ","link":"https://leichen2552.github.io/post/C-调试小结/"},{"title":"《硬件详细设计文档》解析之一","content":" 运行环境 单板功耗 硬件详设是硬件开发过程中最重要的、最正式的文档。 在单板硬件进入到详细设计阶段，应提交单板硬件详细设计报告。在单板硬件详细设计中应着重体现： 单板逻辑框图及各功能模块详细说明，各功能模块实现方式、地址分配、控制方式、接口方式、存贮器空间、中断方式、接口管脚信号详细定义、时序说明、性能指标、 指示灯说明、外接线定义、可编程器件图、功能模块说明、原理图、详细物料清单以及单板 测试、调试计划。 有时候一块单板的硬件和软件分别由两个开发人员开发，因此这时候单板 硬件详细设计便为软件设计者提供了一个详细的指导，因此单板硬件详细设计报告至关重要。尤其是地址分配、控制方式、接口方式、中断方式是编制单板软件的基础，一定要详细写出。 运行环境 第一就是考虑硬件的运行环境：单板长期工作环境温度为0°C～45°C，湿度为10%～90%；短期工作环境温度为–5°C～55°C，湿度为5%～95%；存储环境温度为–40°C～70°C，湿度为10%～100%；运输环境温度为–40°C～70°C。需注意的是短期工作条件是指华为SDH设备连续工作不超过96小时和全年累计工作不超过15天。 我们在做热仿真的时候，需要考虑两个时间长度的不同的环境温度对单板的热冲击。这个55度的环境温度对器件选型还是有很大影响的，特别是内存，X86的处理器，都面临挑战。 由于低温需要考虑-5℃，对于一些商业级器件选型时，需要考虑其低于0℃时的一些场景。 如果开发军品、航空、航海，对于更多苛刻的应用场景的要求，不但需要考虑不同的应用场景，行业标准，还需要实际环境情况的地理特征。比如刚刚说的IPC，如果安装在俄罗斯、非洲等严寒或者酷暑的场景，则需要根据实际情况和当地特点，进一步修改参数指标。 我们需要罗列单板的一些重要指标。一方面检查关键指标是否满足应用场景要求，另外展示单板的一些特点，利于后续开发维护者掌握关键信息。 单板功耗 如前文所述，我们会明确电路板的应用场景和环境的要求。当我们的场景确定之后，有些功耗则变成了一些硬件设计的硬性要求。 对于盒式设备来说，盒子的大小以及产品系列选择适配器或者内置电源的规格，是我们总功耗的一个硬性要求。 对于框式设备来说，每个单板槽位的功率上限也是有要求的。一方面供电要满足要求，并满足余量；另一方面散热要满足要求并满足余量。 对于特殊供电设备，例如USB供电、PoE供电等设备功耗由协议确定了的，功耗上限也是电路板关键指标。关于功耗，有些情况下，板子不组装出来调试，功耗不能确定，就考虑额定功率。 ","link":"https://leichen2552.github.io/post/lesslessying-jian-xiang-xi-she-ji-wen-dang-greatergreater-jie-xi-zhi-yi/"},{"title":"转载科普文章：你需要减肥吗？","content":"以前恭维人有一句成语，叫做心宽体胖，其实那个“胖”字是多音字，应该读作pan2，意思是安详，这个成语原本的意思是一个人心胸宽广，外貌就显得安详，后来大家都读错、理解错了，当成了一个人心情愉快，身体就发胖。在以前胖人很少，身体发胖被认为是因为有足够的食物吃，有条件享受，有福气，所以身体发胖被叫做发福。现在再用心宽体胖来形容一个人，可能就把人得罪了。现在大家都不认为肥胖是什么好事，不仅是因为审美观念不一样了，而且是因为有很多的证据表明肥胖有害健康，是一种病。 肥胖的意思是体内有太多的脂肪，并不只是指体重超重。我们身体的重量来自肌肉、骨骼、脂肪和体液，如果重量超出了正常范围，就叫做超重，但是超重到了一定程度，脂肪含量太多了，才算是肥胖。根据世界卫生组织的数据，2016年全世界有19亿成年人体重超重，占成年人人口的39%，其中有6.5亿人属于肥胖，占成年人人口的13%。女人比男人超重和肥胖的比例稍微多一些，女人超重的比例是40%，男人是39%。女人肥胖的比例是15%，男人是11%。儿童的肥胖现在也是一个严重的问题，全世界有380万5岁以下的儿童体重超重或者肥胖，3.4亿5-19岁的人超重或肥胖。 体重超重和肥胖都对身体有害，只不过肥胖的害处更大更明显。体重超重和肥胖增加了许多疾病的风险。首先会增加心血管疾病的风险，主要是高血压、心脏病和脑卒中；其次会增加二型糖尿病的风险；第三会增加肌肉骨骼疾病的风险，特别是骨关节炎；还会增加某些癌症的风险，包括子宫内膜癌、乳腺癌、卵巢癌、前列腺癌、肝癌、膀胱癌、肾癌、结肠癌；此外还增加了膀胱疾病、睡眠呼吸暂停综合症以及某些精神疾病例如抑郁症、焦虑症的风险。总的来说，体重超重和肥胖增加了死亡率。儿童肥胖同样有健康风险，例如导致呼吸困难，增加了骨折、高血压、心血管疾病、胰岛素抵抗、心理疾病的风险，而且也增加了成年以后肥胖、过早死亡和残疾的概率。 那么你怎么知道自己体重超重或肥胖呢？一个简单的办法是测量腰围。测量的时候要站着，拿一根皮尺，围绕刚好在髋骨以上的腰部一圈，皮尺要跟地面平行，贴着腰部，但是不要挤压皮肤，在刚刚呼出一口气时测量。女性的腰围大于86厘米，男性的腰围大于98厘米，则患与肥胖有关的疾病的风险增加了。更准确的方法是算体质指数，简称BMI。BMI测量的是体重与身高的比例，计算公式是体重除以身高的平方，其中体重的单位是千克，身高的单位是米。比如我的体重68千克，身高1.8米，算下来BMI等于21。BMI少于18.5属于体重太轻，BMI=18.5～24.9属于健康范围；BMI=25～29.9属于超重；BMI在30以上属于肥胖。所以我的BMI 21属于健康范围。这个算法只适用于成年人，儿童是不是体重超重，要查生长曲线，跟同一年龄的中间值做比较。 如果你测量的结果发现自己体重超重甚至肥胖了，那就应该考虑减肥了。怎么减肥比较合适，我们后面再谈。 ","link":"https://leichen2552.github.io/post/zhuan-zai-ke-pu-wen-zhang-ni-xu-yao-jian-fei-ma/"},{"title":"转载科普文章：怎样才能成功减肥？","content":"减肥是一个巨大的产业，市场上风行着各种各样的减肥方案，这些方案的关键都是控制饮食。控制饮食方案又有很多种，但是基本上可以分成这么三大类：低热量方案，低碳水化合物方案，低脂肪方案。这些控制饮食方案哪一种减肥效果比较好呢？研究表明，不管是什么样的方案，减肥能有效果的关键都在于减少了食物能量的摄入。如果不减少能量摄入，什么方案都没有效果，如果减少了能量的摄入，不管采取什么样的方案，都会有相似的效果。所以不管采取什么饮食方案，它们的减肥效果其实都是一样的。但是不同的饮食方案对健康的影响是不一样的。比如说低碳水化合物方案，在强调尽量少吃碳水化合物食物的同时，又认为脂肪的摄入可以不受限制，这种饮食，长期来看对身体健康是有害的。低脂肪方案往往是用高含量的碳水化合物取代了脂肪，对健康同样不利。有的低热量方案属于极低热量，摄入的热量低到不能满足人体正常功能的需要，这也很危险。所以控制饮食不仅要减少能量的摄入，而且还要保证足够的能量和营养，要注意饮食均衡。 我们前面谈到（《为什么减肥很难？》），减肥不能急于求成，否则很容易反弹，甚至变得更胖。减肥要慢慢地减，最好每周体重的下降不要超过1千克。要减掉这么多的体重，需要减少多少能量呢？假定少掉的都是脂肪，1克脂肪的能量大约是9千卡，1千克脂肪就是9000千卡，不过脂肪细胞并不是全都都是脂肪，脂肪大概占了87%，这样算下来，要减掉1千克脂肪细胞，只要减少能量7800千卡，这是一周要减掉的量，分摊到一天，就是一天要减少能量大约1000千卡。你可以通过减少食物能量摄入，和通过增加运动消耗能量，来达到这个目的。 但是实际上没有这么简单。有多种因素会影响到体重减轻的速度。在人体获得的能量减少时，身体不仅会燃烧脂肪，而且还会减少一部分肌肉，这样就会影响减肥的效果。减肥的同时要通过肌肉增强锻炼防止肌肉损失。随着体重的减少，身体的新陈代谢速率会随之降低，这样减肥的效果就又受影响，长期下去还会反弹。所以即使你一天减少1000千卡能量，也不一定一周就能减少1千克体重，而且越往后越难减。 美国研究人员曾经做过试验，把800 多个体重超重的人分成三组，不同组的饮食结构不一样，有的蛋白质多一些，有的脂肪多一些，有的碳水化合物多一些，但是他们每天摄入的能量都比平时少750大卡。试验的结果发现，不同的饮食结构的减肥效果是一样的，6个月后平均体重减少了6千克。如果按我们上面的算法，每天减少能量750大卡，每周减少5250大卡，相当于减少0.67千克体重，那么6个月后应该减少16千克，但是实际平均只减少了6千克，可见减肥要比预想的困难。而且一年以后参加试验的人体重开始反弹，等两年后试 验结束时，平均减少的体重变成了只有4千克了。 所以减肥要有效果是不容易的，要维持减肥效果更不容易。那些减肥成功的人，非常注意饮食控制，坚持比较低的能量摄入，例如每天只摄入1300千卡到1500千卡的能量，尽量避免高热量食品，随时注意观察体重的变化，而且养成了每天至少锻炼30分钟的习惯。每周还应该至少做两次肌肉增强锻炼，肌肉发达了，平时的能量消耗也增加了，有助于保持体重。 ","link":"https://leichen2552.github.io/post/zhuan-zai-ke-pu-wen-zhang-zen-yang-cai-neng-cheng-gong-jian-fei/"},{"title":"转载科普文章：为什么减肥很难？","content":"前面我们谈到了体重超重和肥胖对身体的各种危害，以及自己怎么判断是不是体重超重或肥胖。对体重超重和肥胖的人来说，当然会关心要怎么减肥。减肥在现在是一个巨大的产业，但是减肥的效果却往往很不理想，肥胖仍然是一种流行病。减肥为什么这么难呢？ 肥胖是因为身体摄入的能量超过了身体消耗的能量，多余的能量转变成脂肪储存了起来。如果摄入的能量与消耗的能量差不多，那么体重就会维持不变。如果摄入的能量少于消耗的能量，那么体重就会减轻。所以减肥的原理很简单，要么让摄入的能量减少，要么让消耗的能量增加，要么二者结合起来，总之，就是要设法让摄入的能量少于消耗的能量。要减少摄入的能量，就要控制饮食；要增加消耗的能量，就要增加运动量。所以如果不吃药不做手术的话，各种各样的减肥方法万变不离其宗，本质上都是控制饮食和增加运动量。 减肥的原理虽然简单，实际却很复杂。为什么两个人，饭量差不多，运动量也差不多，却一个胖一个瘦呢？这和基因有关系。有的人天生的新陈代谢效率比较高，摄入的能量消耗速率快，这样的人就不容易长胖，反之就容易长胖。我们现在很羡慕那些怎么吃也长不胖的人，其实这种人在以前是没有生存优势的。在人类历史上，大部分时间人都是吃不饱饭的，经常遇到灾荒，那些新陈代谢效率高的人，更容易挨饿，甚至饿死；而那些新陈代谢效率低的人，消耗的能量少，能把更多的能量储存起来，有助于度过饥荒。所以容易长胖的人，其实在历史上是很有生存优势的，与肥胖有关的基因就容易保存、传播。只不过到了现在，在食品过剩的发达地区，容易长胖才变成了缺点。所以肥胖其实是现代病，是历史遗留给我们的不良遗产。 明白这一点，对如何正确地减肥很有启发。例如有的人有一天下定决心要减肥，开始节食，比平时少吃很多，同时加强运动量，运动量比平时大很多，很快就有了明显的效果，一两个月能够减肥十几、二十几斤，别人看了很羡慕，他也作为经验介绍给别人。但是，他发现再继续减轻体重很难，而且过一段时间后，体重又逐渐上升，反弹得厉害，甚至超过了减肥之前的体重。 这是为什么呢？这是因为你一旦减肥得太猛，迅速减少饭量和增加运动量，导致摄入的能量急剧下降，消耗的能量急剧上升，身体发现需要的能量比平时少很多，就会本能地以为遇到了饥荒，就会把新陈代谢效率调慢，以便度过饥荒。这样就很难再继续减轻体重，容易反弹。如果恢复到以前的饮食、运动习惯，因为新陈代谢效率已经变低了，反而会变得比以前胖。 所以，减肥是一个抗拒人体本能的过程，是很难的，需要有很大的毅力坚持下去，而且要循序渐进，逐渐地减，不要急于求成。 ","link":"https://leichen2552.github.io/post/zhuan-zai-ke-pu-wen-zhang-wei-shi-me-jian-fei-hen-nan/"},{"title":"STM32 VBAT外围电路接法","content":"给大家看几块开发板的VBAT外围电路的设计图： （1） （2） （3） （4） （5） stm32芯片手册要求：（大体上就这两个要求，具体要求看AN2586供电方案） 如果应用中没有使用外部电池，VBAT必须连接到VDD引脚上。 如果没有外部电池，这个引脚必须和100nF的陶瓷电容一起连接到VDD电源上 在VDD上升阶段(tRSTTEMPO)或者探测到PVD之后，VBAT和VDD之间的电源开关仍会保持连接在VBAT。在VDD上升阶段，如果VDD在小于tRSTTEMPO的时间内达到稳定状态(关于tRSTTEMPO可参考数据手册中的相关部分)，且VDD &gt; VBAT + 0.6V时，电流可能通过VDD和VBAT之间的内部二极管注入到VBAT。 第一张图：VBAT引脚直接连接电池，直接没有满足stm32参考手册要求（3），间接没有满足（1）（2）。 为什么说是间接没有满足（1）（2）呢，如果这块开发板上面电池没有接那么就会不满足（1）（2）。 第二张图：这个设计更是简单，直接不接电池了，所以这个设计满足stm32芯片手册要求。 第三张图：是通过jp14跳线帽选择用v3.3供电还是用电池供电，假如跳线帽连接1、2，那么就是选择v3.3供 电，这样就会不满足（2），假如跳线帽连接2、3，那么就是选择电池供电，这样就参考第一张图的答案。 第四张图：这个设计是分开画的，截图没截全，这个设计和第一张图一样，参考第一张图答案。 第五张图：这个设计比较好，当接电池和有v3.3电源时，就会选择v3.3供电。当接电池和没有v3.3电源时， 就会选择电池供电。当不接电池和有v3.3电源时也会选择v3.3供电。 这个设计中，D1的设计非常好，当电池供电时，电池不会给整个电路供电。 ","link":"https://leichen2552.github.io/post/stm32-vbat-wai-wei-dian-lu-jie-fa/"},{"title":"USB接口处D+、D-怎么接","content":"USB信号是什么类型的？ 为什么在D+，D-处要接上拉下拉电阻呢，具体阻值要如何计算。 usb有主从设备之分，主设备有：pc, 现在市面上的那些插u-disk即可播放mp3的“mp3”之类的， usb 信号是差分信号，信号线为D+, D-,。 在usb host 端， D+，D- 各接一个15kohm 的下拉电阻， 而在usb device端，这时就有高速低速设备的区别了。usb1.0, 1.1,2.0协议中都有定义高低速设备以满足不同情况的需求，这些在硬件上的区别就是： 高速设备：d+ 接一个1.5kohm的上拉电阻，d-不接；低速设备则相反。 这样当usb device 插入到host中时，如果是高速设备， 则d+被拉高，d-不变；低速设备则与之相反。 这个上拉过程需要大概2.5us的时间，host这这个时间内便检测到了该信号，即可判断有device plug in，和该device的类型，然后开始通讯，枚举。。。等。 USB OTG（on the go） 就是既可以做host又可以做client 我们一般是作为client接受pc传输数据，作为host时可以接打印机直接把手机中的照片打印出来 判别是host还是client是靠USB_ID这根pin 当作为client时，USB_ID基本是悬空的（内部有上拉） 如果侦测到USB_ID被拉低，就被认为是作为host，向外输出 所以需要外部client设备把USB_ID拉低 ","link":"https://leichen2552.github.io/post/usb-jie-kou-chu-dd-zen-me-jie/"},{"title":"stm32f429移植STemWin总结","content":" 总览 裸机上移植 第一步 第二步 第三步 FreeRTOS上移植 第一步 总览 连续熬了三天夜，各种找资料看文档算是把STemWin移植上了裸机和FreeRTOS上了。 我是按照《安富莱_STM32-V6emWin教程（V2.0）》这份教程来的，安富莱写得很详细，也确实在emWin教程这方面做得很好。但是有几处细节方面着重说一下。 裸机上移植 第一步 在移植之前，板载的SDRAM驱动、触摸驱动、显示屏驱动要先准备好，这些准备好了才能进行下一步工作。 第二步 GUIConf.c与GUIConf.h这两个文件，安富莱已经说得很详细了，这里就不再赘述。 第三步 LCDConf_Lin_Template.c与LCDConf_Lin_Template.h，这两个文件要着重说一下。如果是在STM32Cube_FW_F4_V1.13.0\\Middlewares\\ST\\STemWin\\Config\\这个目录下复制的LCDConf_Lin_Template.c这个文件，你会发现，这个文件的代码量少得可怜，跟安富莱教程里说的大相径庭。但是在STM32Cube_FW_F4_V1.13.0\\Projects\\STM324x9I_EVAL\\Applications\\STemWin\\STemWin_SampleDemo\\Src这个目录下，有一个LCDConf_stm324x9i_eval_MB1063.c这个文件，这个文件是ST官方移植STemWin时的文件，我们把它复制出来然后改成LCDConf_Lin_Template.c，然后替换原来的那个文件。删除掉函数LCD_LL_Init()、HAL_LTDC_MspInit()和HAL_LTDC_MspDelnit()这三个函数，因为ST官方移植的文件中还要初始化RGB屏幕的，但是我们会使用LCD_ Init()函 数初始化RGB屏，所以这三个函数我们不需要。然后再添加两个函数LTDC_IRQHandler() 和DMA2D_IRQHandler()这两个函数，这两个函数在第一步之前就该准备好。 STM32Cube_FW_F4_V1.13.0这个库里面的LCDConf_stm324x9i_eval_MB1063.c已经是HAL库了，跟安富莱的代码有点不一样，安富莱的用的还是寄存器方式。我特意去下载了STM32Cube_FW_F4_V1.1.0的库，这个库用的还是寄存器的，主要是硬盘容量不够了，所以我只能推测安富莱的并不是V1.13的库，因为我看的是emWin2.0的教程，安富莱之前第一版的教程是V1.1.2的库，这就解释的通了。 FreeRTOS上移植 第一步 移植上freeRTOS的时候，由于之前裸机的触摸屏中断用了一个exit线中断，导致一直卡死。后来采用定时器循环扫描的方式，简单实用。关于这个文件GUI_X_FreeRTOS这个文件在Keil的安装目录里面Keil_v526\\ARM\\PACK\\Keil\\MDK-Middleware\\7.7.0\\emWin\\Sample\\GUI_X 大概就这么多，暂时先写到这里！ ","link":"https://leichen2552.github.io/post/stm32f429-yi-zhi-stemwin-zong-jie/"},{"title":"两次出海记录反思与总结","content":" 第一次出海 缺陷 第二次出海前准备 1月16日 1月17日 组装时缺陷 内部电路的缺陷 第二次出海 改进 第一次出海 第一次出海是2020年11月22日礼拜天，据师兄说，第一次出海只是气密性检测，整体设备是一个圆柱导弹型，并没加推进器，从头部到电池箱到主板控制器箱（以下称主板箱）完全密封，只有尾部的推进器箱和主板箱是采用螺纹旋紧的。 缺陷 设计缺陷(一)：采用了旋紧螺纹的连接方式。所谓完全密封，是接近两厘米的螺纹，准确的说是15*1mm，旋转15圈，螺距是1mm。当时这么设计是为了防水，但是工厂的加工师傅说再密的螺纹也是防不了水的，所以为了防水，就用螺纹密封胶，在旋螺纹之前，在螺纹上涂一些螺纹密封胶，再把头部与电池箱拧紧，其他连接处也一样。这确实是可行的解决方案，但是我们低估了拆卸的麻烦，由于是圆形，五个人卸了一个下午，才把头部给卸了下来，剩下连接处的地方根本拆不下来。 设计缺陷(二)：几段圆柱中间留孔走线，真的是个糟糕的设计，完全不顾在拧螺纹的时候中间的线也会被拧紧，并且是越拧越紧，而且还会断。比如深度传感器的线，就断了，断一次就200多块。 设计缺陷(三)：拉扯的线没有滚筒，导致连线很乱，而且线很重。 设计缺陷(四)：虽然设计上说是200米，用了100多米的线，但是接头用了杜邦线，485的接头盒主控板之间使用KF-2.54-2P的接头，这种接头在每次接的时候总是要接头上的拧螺丝，先松开再拧紧，着实麻烦。 低估了海水的浮力，由于第一次没加电池，发现根本沉不下去，头部顶端的深度传感器在海浪的推动下敲打着船底，事后回来检查，深度传感器已经砸坏了。 第二次出海前准备 出海前的组装时的缺陷，组装整整用了一天。本以为1月15号就能组装完成，1月16号就能做完实验，万事大吉，可是命运总是跟你开足了玩笑。 不是有一句话，老天不会亏待痴情的人。是啊，都是往死里整。所以，对于停电，我放弃还不行么！ 1月16日 停电一天，没有电，根本无法组装。我与师兄约定17号什么时候来电，什么时候来实验室组装，争取上午组装好，下午去实验。 1月17日 清晨5点48分，师兄的电话来了，说来电了。然后就和他去实验室，实验室确实有电。 早晨6点33分，停电了，刚热的电烙铁，刚热的热风箱以及刚剪开热缩管。然后和师兄去食堂吃早饭。是的，食堂也没开，超市也没开。 上午7点14分，来电了，以为是全部供电，正打算开工。 上午7点17分，又断电了。看吧，学校就会和你开玩笑。 上午7点34分，发现电梯有电，一楼有电，打电话给后勤，后勤说是发电机在供电，并未完全供电。 上午7点40分，一楼的考研教室有电，把一些必要的器件搬到教室，开工组装。 上午8点07分，导师来了，9栋没有电，看来只能在考研教室组装了。 组装时缺陷 师兄的想法，在本来的电池箱的底板上打个孔，把深度传感器前后旋紧在底板上，又发现之前师兄把底板的另一侧涂上了厚厚的胶，厚厚的胶不好去除，我手大，没办法把手伸进一个直径18cm深50cm里面操作去除胶。 是否加装旋钮开关，本是一个很好的想法，但是开关不防水，在开关后面加装一个防水螺丝，海水密封AB胶初凝固的时间是1-2小时，也就是说，等它凝固那就要等到12点了。但是在安装的时候，那可太费劲了。四根推进器的线再加一根485的通信线在加一个旋钮开关的线，在一个孔里，然后旋紧，真的是太费劲了。最后放弃安装旋钮开关。 安装尾部的时候，我和师兄两个人，我在上面旋转尾部，师兄在底下抖线，目的就是把旋转在线上的劲道给去掉。师兄真的几次都想放弃了，但是么得办法。 终于，推进器的那部分旋进去了。终于旋进去了！旋进去了！进去了！去了！了！是的，在考研教室装完了后半部分。下午3点05分，老师来了，说已经来不及出海做实验了，怎么说都得明天了。正好，来电了，老师提议去9栋实验室。好的！ 内部电路的缺陷 缺陷(一)：本来是打算使用策海科技提供的密封舱套件，接线处使用水密螺丝+灌胶的方法密封，现在时间根本来不及，还是算了。果断放弃二级密封舱防水的方法。 缺陷(二)：电调散热无法解决，虽然也不知道到底会散多少热，但是这个确实算个问题。 缺陷(三)：接线，粗线和细线的重力不一样，会有可能把细线拉断，今天就是，把电调的线打断了。 缺陷(四)：电路板上全是杜邦线接口，设计者第二次接线都会把线接错，更别说用户了，这着实是一个糟糕的设计。 缺陷(五)：接线时需要区分四个推进器顺序，这个缺陷虽然有点牵强，但是设计者还需要利用测试代码来区分推进器，这有点说不过去。 第二次出海 第二次出海是2021年1月18日礼拜一，也就是今天，这是导师催了很久的出海试验。这次的实验，是要完成推进器闭环的深度控制，采集数据。 也就是今天，早上7点30到实验室，再把主板密封舱的时候，那些推进器的粗线压着深度传感器的线，又差点GG，又测试了一遍，没问题，把头部旋紧主板舱，这应该是最后一次下海前把头部拧进去。算是安装完毕了，等老师过来！ 上午9点出发，导师开车上高速之后，一路100码，10点不到就到了测试的海域，船家说现在出海需要派出所证明，导师跟着去开证明了，但是万万没有想到，开证明开了两个半小时。 12点40分，出海，伴随着柴油发电机的轰鸣，我们带着设备去了浅海海域，在安装后面绳子的时候，又出现了一点点小插曲，孔不够大，固定绳子的螺丝塞不进去。搞了半天，可以了。 师兄拿出了电脑，准备开始调试，我把设备头部拧下来，师兄接上电源线。这时候，我最担心的事情发生了，也是昨晚最担心的事情发生了，由于在浅海海域，船晃得厉害，头部拧不紧。 这时候由于之前吸了柴油烟，我开始晕了，可能是晕船，一点力气都没有，只能躺在船头，站不起来，看着师兄和老师在那边操作，加上船家，三个人在那旋转设备头部。 我躺了一会，师兄也在强撑，一共吐了三次。 然后去了一个风小的小地方做实验，当师兄再次检查主控制板的时候，发现电调的线断了，这就没办法了，只能返航！ 改进 接线：尤其是电源出来的供电，之前设计用到导线分流器，但是最近看到分电板，打算用分电板。 水密螺丝：这个不打算用了，还要灌胶。用那种两头插芯的防水螺丝，这个也要灌胶，但是只要灌一次就可以了 板子上的接口，现在打算采用XH2.54的接口。 尤其是设计方面，以后在也不会用螺纹这种连接方式。 一定要留调试接口！ ","link":"https://leichen2552.github.io/post/liang-ci-chu-hai-ji-lu-fan-si-yu-zong-jie/"},{"title":"按键FIFO的代码的思想与编写","content":" 总览 按键对象 按键数量 按键对象类型 按键状态 按键状态存储数据结构 小结 实现方法 一：用宏 定义按键的时钟、端口、引脚 二：定义按键个数和按键的FIFO数据结构 三：用简便的语句实现按键是否被按下 四：往FIFO中写入一个键值 五：从按键FIFO缓冲区读取一个键值 六：获取按键的状态以及设置按键的参数 七：清空按键FIFO缓冲区 八：初始化按键硬件 九：初始化按键变量 十：最重要的检测按键！最重要！ 十一：初始化按键 最后 优点 总览 对安富莱按键FIFO的代码进行了分析综合与运用 首先说一句，面对对象的编程思想真的相当重要。相当后悔毕业之后才接触了面对对象编程的思想，其实在大一大二的时候，就喜欢原子和野火的代码，逻辑简单也好用。看到安富莱的stm32代码，有点懵逼的的，就感觉为什么一个简单的按键检测搞这么麻烦，初始化按键的GPIO之后再加一句简单的GPIO_ReadInputDataBit不就行了么，还搞这搞那这么麻烦！当时也不懂什么叫数据结构，也没有人指导。可是学到后来，就觉得仅仅一个GPIO_ReadInputDataBit真的不能解决所有的事情，当然了，按一下再弹起或许可以，但是如果有长按功能呢？有连续按的功能呢？ 当时觉得STM32还写得不错，就开始向S3C2440进军，看看uboot，玩玩linux，看看内核代码，在看内核的时候，发现充斥着大量的结构体与数据结构，当时就在想，为啥用这么多的结构体呢，好不明白。立马觉得自己阅读代码的能力不够，就把C语言重新回顾了几遍，又去把C++学了一遍。当明白了面对对象的编程思想之后，才发现过去面对过程编写的思想真的是小儿科啊。 其实用结构体的方式，方便就在好管理！ 按键对象 回归正题，编写按键程序的时候，首先想到的就是按键有几种状态，第二是对按键的操作方法。 按键对象 按键状态： 按下 弹起 长按 按键操作： 按一下 长按 连续按 对这个有一个意识之后，面对对象的编程思想就来了，我需要一个按键类型，就像C语言里面的int、char一样，可以声明一种按键类型，那么下面的代码就出来了： 按键数量 开发板上有两个按键，把这两个按键枚举出来： typedef enum { KID_K1 = 0, KID_K2 }KEY_ID_E; //两个按键，再加上组合按键，共有三种方式 //组合键这个可加可不加，加的话这个值就是3，不加就是2 #define KEY_COUNT 3 按键对象类型 利用C语言的typedef和struct： /* 按键滤波时间50ms, 单位10ms。 只有连续检测到50ms状态不变才认为有效，包括弹起和按下两种事件 即使按键电路不做硬件滤波，该滤波机制也可以保证可靠地检测到按键事件 */ #define KEY_FILTER_TIME 5 #define KEY_LONG_TIME 100 /* 单位10ms， 持续1秒，认为长按事件 */ typedef struct { /*下面是一个函数指针*/ uint8_t (*IsKeyDownFunc)(void);/*按键按下的判断函数，1表示按下*/ uint8_t Count; /* 滤波计数器 */ uint16_t LongCount; /* 长按计数器 */ uint16_t LongTime; /* 按键按下的持续时间，0表示不检测长按 */ uint8_t State; /* 按键当前状态（按下还是弹起） */ uint8_t RepeatSpeed; /* 连续按键周期 */ uint8_t RepeatCount; /* 连续按键计时器 */ }KEY_Typedef; 按键状态 利用枚举定义每个按键的状态，按下、弹起、长按： typedef enum { KEY_NONE = 0, KEY_1_DOWN, /* 1键按下 1*/ KEY_1_UP, /* 1键弹起 2*/ KEY_1_LONG, /* 1键长按 3*/ KEY_2_DOWN, /* 2键按下 4*/ KEY_2_UP, /* 2键弹起 5*/ KEY_2_LONG, /* 2键长按 6*/ /*组合键*/ KEY_3_DOWN, /* 组合1、2键按下 7*/ KEY_3_UP, /* 组合1、2键弹起 8*/ KEY_3_LONG /* 组合1、2键长按 9*/ }KEY_ENUM; 按键状态存储数据结构 把按键每次的按下的状态数据存储FIFO数据结构中，然后从这个FIFO中读取按键事件，这个FIFO定义一个长度为10的数组： /* 按键FIFO用到变量 */ #define KEY_FIFO_SIZE 10 typedef struct { uint8_t Buf[KEY_FIFO_SIZE]; /* 键值缓冲区 */ uint8_t Read; /* 缓冲区读指针1 */ uint8_t Write; /* 缓冲区写指针 */ uint8_t Read2; /* 缓冲区读指针2 */ }KEY_FIFO_Typedef; 小结 从按键对象上手，总结出按键对象类型、按键状态以及按键状态存储数据结构，上述代码在头文件中实现。 实现方法 一：用宏 定义按键的时钟、端口、引脚 #define RCC_ALL_KEY (RCC_AHB1Periph_GPIOA|RCC_AHB1Periph_GPIOC) #define GPIO_PORT_K1 GPIOA #define GPIO_PIN_K1 GPIO_Pin_0 #define GPIO_PORT_K2 GPIOC #define GPIO_PIN_K2 GPIO_Pin_13 二：定义按键个数和按键的FIFO数据结构 static KEY_Typedef s_tBtn[KEY_COUNT]; //两个按键和二合一组合键一共三个按键 static KEY_FIFO_Typedef s_tKey; //定义一个FIFO数据结构 三：用简便的语句实现按键是否被按下 //其实本质上，这就是GPIO_ReadInputDataBit实现方法。不过if语句中的判断是否相等，得看硬件电路， //如果按键按下后，引脚检测是低电平，则就是等于0，如果按键按下后，引脚检测是高电平，就不等于0 static uint8_t IsKeyDown1(void) {if((GPIO_PORT_K1-&gt;IDR &amp; GPIO_PIN_K1) != 0) {return 1;} else {return 0;}} static uint8_t IsKeyDown2(void) {if((GPIO_PORT_K2-&gt;IDR &amp; GPIO_PIN_K2) != 0) {return 1;} else {return 0;}} static uint8_t IsKeyDown3(void) {if(IsKeyDown1() &amp;&amp; IsKeyDown2()) {return 1;} else {return 0;}} 四：往FIFO中写入一个键值 void BspPutKey(uint8_t _KeyCode) { s_tKey.Buf[s_tKey.Write] = _KeyCode; if(++s_tKey.Write &gt;= KEY_FIFO_SIZE) { s_tKey.Write = 0; } } 五：从按键FIFO缓冲区读取一个键值 uint8_t BspGetKey(void) { uint8_t ret; if(s_tKey.Read == s_tKey.Write) { return KEY_NONE; } else { ret = s_tKey.Buf[s_tKey.Read]; if(++s_tKey.Read &gt;= KEY_FIFO_SIZE) { s_tKey.Read = 0; } return ret; } } /* ********************************************************************************************************* * 函 数 名: bsp_GetKey2 * 功能说明: 从按键FIFO缓冲区读取一个键值。独立的读指针。 * 形 参: 无 * 返 回 值: 按键代码 ********************************************************************************************************* */ uint8_t BspGetKey2(void) { uint8_t ret; if(s_tKey.Read2 == s_tKey.Write) { return KEY_NONE; } else { ret = s_tKey.Buf[s_tKey.Read2]; if(++s_tKey.Read2 &gt;= KEY_FIFO_SIZE) { s_tKey.Read2 = 0; } return ret; } } 对于这个第二个读指针，从功能说明上看，是独立的读指针，与之前那个读指针有区别。 六：获取按键的状态以及设置按键的参数 /* ********************************************************************************************************* * 函 数 名: bsp_GetKeyState * 功能说明: 读取按键的状态 * 形 参: _ucKeyID : 按键ID，从0开始 * 返 回 值: 1 表示按下， 0 表示未按下 ********************************************************************************************************* */ uint8_t BspGetKeyState(KEY_ID_E _ucKeyID) { return s_tBtn[_ucKeyID].State; } /* ********************************************************************************************************* * 函 数 名: bsp_SetKeyParam * 功能说明: 设置按键参数 * 形 参：_ucKeyID : 按键ID，从0开始 * _LongTime : 长按事件时间 * _RepeatSpeed : 连发速度 * 返 回 值: 无 ********************************************************************************************************* */ void BspSetKeyParam(uint8_t _ucKeyID, uint16_t _LongTime, uint8_t _RepeatSpeed) { s_tBtn[_ucKeyID].LongTime = _LongTime; /* 长按时间 0 表示不检测长按键事件 */ s_tBtn[_ucKeyID].RepeatSpeed = _RepeatSpeed; /* 按键连发的速度，0表示不支持连发 */ s_tBtn[_ucKeyID].RepeatCount = 0; /* 连发计数器 */ } 七：清空按键FIFO缓冲区 /* ********************************************************************************************************* * 函 数 名: bsp_ClearKey * 功能说明: 清空按键FIFO缓冲区 * 形 参：无 * 返 回 值: 按键代码 ********************************************************************************************************* */ void BspClearKey(void) { s_tKey.Read = s_tKey.Write; } 八：初始化按键硬件 static void BspInitKeyHard(void) { GPIO_InitTypeDef GPIO_InitStructure; /*开启按键GPIO口的时钟*/ RCC_AHB1PeriphClockCmd(RCC_ALL_KEY,ENABLE); /* 第2步：配置所有的按键GPIO为浮动输入模式(实际上CPU复位后就是输入状态) */ GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN; GPIO_InitStructure.GPIO_OType = GPIO_OType_PP; GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL; GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; GPIO_InitStructure.GPIO_Pin = GPIO_PIN_K1; GPIO_Init(GPIO_PORT_K1, &amp;GPIO_InitStructure); GPIO_InitStructure.GPIO_Pin = GPIO_PIN_K2; GPIO_Init(GPIO_PORT_K2, &amp;GPIO_InitStructure); } 九：初始化按键变量 /* ********************************************************************************************************* * 函 数 名: bsp_InitKeyVar * 功能说明: 初始化按键变量 * 形 参: 无 * 返 回 值: 无 ********************************************************************************************************* */ static void BspInitKeyVar(void) { uint8_t i; s_tKey.Read = 0; s_tKey.Write = 0; s_tKey.Read2 = 0; for(i = 0; i &lt; KEY_COUNT; i++) { s_tBtn[i].LongTime = KEY_LONG_TIME; /* 长按时间 0 表示不检测长按键事件 */ s_tBtn[i].Count = KEY_FILTER_TIME / 2; /* 计数器设置为滤波时间的一半 */ s_tBtn[i].State = 0; /* 按键缺省状态，0为未按下 */ s_tBtn[i].RepeatSpeed = 0; /* 按键连发的速度，0表示不支持连发 */ s_tBtn[i].RepeatCount = 0; /* 连发计数器 */ } /* 如果需要单独更改某个按键的参数，可以在此单独重新赋值 */ /* 比如，我们希望按键1按下超过1秒后，自动重发相同键值 */ s_tBtn[KID_K1].LongTime = 100; s_tBtn[KID_K1].RepeatSpeed = 5; /* 每隔50ms自动发送键值 */ s_tBtn[KID_K2].LongTime = 100; s_tBtn[KID_K2].RepeatSpeed = 5; /* 每隔50ms自动发送键值 */ s_tBtn[0].IsKeyDownFunc = IsKeyDown1; s_tBtn[1].IsKeyDownFunc = IsKeyDown2; s_tBtn[2].IsKeyDownFunc = IsKeyDown3; } 十：最重要的检测按键！最重要！ static void BspDetectKey(uint8_t i) { KEY_Typedef *pBtn; pBtn = &amp;s_tBtn[i]; if(pBtn-&gt;IsKeyDownFunc()) { /*这个里面执行的是按键按下的处理*/ /* 下面这个if语句主要是用于按键滤波前给Count设置一个初值， 前面说按键初始化的时候，已经设置了Count = KEY_FILTER_TIME / 2 */ if(pBtn-&gt;Count &lt; KEY_FILTER_TIME) { pBtn-&gt;Count = KEY_FILTER_TIME; } /* 这里实现KEY_FILTER_TIME时间长度的延迟 */ else if(pBtn-&gt;Count &lt; 2 * KEY_FILTER_TIME) { pBtn-&gt;Count ++; } /* 这里实现KEY_FILTER_TIME时间长度的延迟 */ /* 个人理解以上两句就是软件消抖 */ else { /* ********************************************************************************** 这个State变量是有其实际意义的，如果按键按下了，这里就将其设置为1，如果没有按下， 这个变量的值就会一直是0，这样设置的目的可以有效的防止一种情况的出现：比如按键K1 在某个时刻检测到了按键有按下，那么它就会做进一步的滤波处理，但是在滤波的过程中， 这个按键按下的状态消失了，这个时候就会进入到上面第二步else语句里面，然后再做按键 松手检测滤波，滤波结束后判断这个State变量，如果前面就没有检测到按下，这里就不会 记录按键弹起。 ********************************************************************************** */ if(pBtn-&gt;State == 0) { pBtn-&gt;State = 1; /* 发送按钮按下的消息 */ BspPutKey((uint8_t)(3 * i + 1)); } if(pBtn-&gt;LongTime &gt; 0) { if(pBtn-&gt;LongCount &lt; pBtn-&gt;LongTime) { /* 发送按钮按下的消息 */ if(++pBtn-&gt;LongCount == pBtn-&gt;LongTime) { /* 键值放入按键FIFO */ BspPutKey((uint8_t)(3 * i + 3)); } } else { if(pBtn-&gt;RepeatSpeed &gt; 0) { if(++pBtn-&gt;RepeatCount &gt;= pBtn-&gt;RepeatSpeed) { pBtn-&gt;RepeatCount = 0; /* 长按键后，每隔10ms发送1个按键 */ BspPutKey((uint8_t)(3 * i + 1)); } } } } } } else { /*这个里面执行的是按键松手的处理或者按键没有按下的处理 */ if(pBtn-&gt;Count &gt; KEY_FILTER_TIME) { pBtn-&gt;Count = KEY_FILTER_TIME; } else if(pBtn-&gt;Count != 0) { pBtn-&gt;Count --; } else { if(pBtn-&gt;State == 1) { pBtn-&gt;State = 0; BspPutKey((uint8_t)(3 * i + 2)); } } pBtn-&gt;LongCount = 0; pBtn-&gt;RepeatCount = 0; } } /* 然后就是逐一扫描按键 */ void BspKeyScan(void) { uint8_t i; for(i = 0; i &lt; KEY_COUNT; i++) { BspDetectKey(i); } } 十一：初始化按键 void BspInitKEY(void) { BspInitKeyVar(); BspInitKeyHard(); } 最后 定时起里对按键进行扫描，主函数对键值进行读取。 //定时器扫描硬件函数部分省略了 while(1) { uint8_t ucKeyCode = BspGetKey(); if(++i &gt; 100000) { printf(&quot; ucKeyCode = %d\\r\\n&quot;,ucKeyCode); i = 0; } if(ucKeyCode != KEY_NONE) { switch (ucKeyCode) { case KEY_1_DOWN : /* User Code 1*/ break; case KEY_2_DOWN : /* User Code 2*/ break; default: break; } } } 优点 可靠地记录每一个按键事件，避免遗漏按键事件。特别是需要实现按键的按下、长按、自动连发、弹起等事件时。 读取按键的函数可以设计为非阻塞的，不需要等待按键抖动滤波处理完毕。 按键FIFO程序在嘀嗒定时器中定期的执行检测，不需要在主程序中一直做检测，这样可以有效地降低系统资源消耗。 ","link":"https://leichen2552.github.io/post/an-jian-fifo-de-dai-ma-de-si-xiang-yu-bian-xie/"},{"title":"推挽输出与开漏输出的区别","content":"转自： https://blog.csdn.net/qq_27016651/article/details/83096126 ","link":"https://leichen2552.github.io/post/tui-wan-shu-chu-yu-kai-lou-shu-chu-de-qu-bie/"},{"title":"串口重映射的思想","content":"标准库函数的默认输出设备是显示器，要实现在串口或LCD输出，必须重定义标准库函数里调用的与输出设备相关的函数。 stm32重映射 ///重定向c库函数printf到串口，重定向后可使用printf函数 int fputc(int ch, FILE *f) { /* 发送一个字节数据到串口 */ USART_SendData(DEBUG_USART, (uint8_t) ch); /* 等待发送完毕 */ while (USART_GetFlagStatus(DEBUG_USART, USART_FLAG_TXE) == RESET); return (ch); } ","link":"https://leichen2552.github.io/post/chuan-kou-chong-ying-she-de-si-xiang/"},{"title":"stm32f429移植FreeRTOS","content":" 第一步 第二步 第三步 第四步 第五步 修改FreeRTOSConfig.h文件内容 第一处：88~91行改成如下 第二处：config开头宏修改 开启F429的FPU 第一处 第二处 工程文件里面不能有有关系统滴答定时器SysTick_Handler的函数，有的话需要屏蔽掉！ 测试 注意 第一步 从官方下载的freertos文件中找到如下目录，我们只需要FreeRTOS目录下的Source目录下的文件，至于FreeRTOS-Plus目录下的，咱们不用管。 第二步 在原有的某工程目录下新建一个FreeRTOS文件夹 在这个文件夹下，把刚才Source目录下的文件全部复制过来 portable目录下只保留三个文件夹 RVDS目录下，我们需要的是M4F这个文件夹 第三步 在原有的工程目录里新建两个组，如图，并把刚才Freertos目录下的文件放入，也如图所示 第四步 把下载下来的FreeRTOS文件夹下Demo（找到CORTEX_M4F_STM32F407ZG-SK这个Demo就可以了）中的的FreeRTOSconfig.h放进工程中新建FreeRTOS文件夹下 第五步 修改FreeRTOSConfig.h文件内容 第一处：88~91行改成如下 #if defined (__ICCARM__)||(__CC_ARM)||(__GNUC__) #include &lt;stdint.h&gt; extern uint32_t SystemCoreClock; #endif 第二处：config开头宏修改 把这四项改成0 开启F429的FPU 第一处 在system_stm32f4xx.c文件的SystemInit函数里，也就是该文件的第478行，有一个__FPU_USED，选中Go To Definetion会跳转core_cm4.h中，把core_cm4.h文件中的第123行修改为__FPU_USED的值修改为1就行 第二处 修改MDK软件的选项 到此为止，修改完成 工程文件里面不能有有关系统滴答定时器SysTick_Handler的函数，有的话需要屏蔽掉！ 测试 #include &quot;bsp.h&quot; #include &quot;FreeRTOS.h&quot; #include &quot;task.h&quot; #define START_TASK_PRIO 1 //任务优先级 #define START_STK_SIZE 256 //任务堆栈大小 TaskHandle_t StartTask_Handler; //任务句柄 void start_task(void *pvParameters); //任务函数 #define LED0_TASK_PRIO 2 //任务优先级 #define LED0_STK_SIZE 256 //任务堆栈大小 TaskHandle_t LED0Task_Handler; //任务句柄 void led0_task(void *p_arg); //任务函数 #define LED1_TASK_PRIO 3 //任务优先级 #define LED1_STK_SIZE 256 //任务堆栈大小 TaskHandle_t LED1Task_Handler; //任务句柄 void led1_task(void*p_arg); //任务函数 #define FLOAT_TASK_PRIO 4 //任务优先级 #define FLOAT_STK_SIZE 256 //任务堆栈大小 TaskHandle_t FLOATTask_Handler; //任务句柄 void float_task(void *p_arg); //任务函数 int main(void) { BspInit(); //创建开始任务 xTaskCreate((TaskFunction_t )start_task, //任务函数 (const char* )&quot;start_task&quot;, //任务名称 (uint16_t )START_STK_SIZE, //任务堆栈大小 (void* )NULL, //传递给任务函数的参数 (UBaseType_t )START_TASK_PRIO, //任务优先级 (TaskHandle_t* )&amp;StartTask_Handler); //任务句柄 vTaskStartScheduler(); //开启任务调度 } //开始任务任务函数 void start_task(void *pvParameters) { taskENTER_CRITICAL(); //进入临界区 //创建LED0任务 xTaskCreate((TaskFunction_t )led0_task, (const char* )&quot;led0_task&quot;, (uint16_t )LED0_STK_SIZE, (void* )NULL, (UBaseType_t )LED0_TASK_PRIO, (TaskHandle_t* )&amp;LED0Task_Handler); //创建LED1任务 xTaskCreate((TaskFunction_t )led1_task, (const char* )&quot;led1_task&quot;, (uint16_t )LED1_STK_SIZE, (void* )NULL, (UBaseType_t )LED1_TASK_PRIO, (TaskHandle_t* )&amp;LED1Task_Handler); //浮点测试任务 xTaskCreate((TaskFunction_t )float_task, (const char* )&quot;float_task&quot;, (uint16_t )FLOAT_STK_SIZE, (void* )NULL, (UBaseType_t )FLOAT_TASK_PRIO, (TaskHandle_t* )&amp;FLOATTask_Handler); vTaskDelete(StartTask_Handler); //删除开始任务 taskEXIT_CRITICAL(); //退出临界区 } //LED0任务函数 void led0_task(void *pvParameters) { while(1) { LED4_TOGGLE; //printf(&quot;==--**\\r\\n&quot;); vTaskDelay(500); } } //LED1任务函数 void led1_task(void *pvParameters) { while(1) { printf(&quot;led1_task--------------\\r\\n&quot;); vTaskDelay(500); } } //浮点测试任务 void float_task(void *pvParameters) { static float float_num=0.00; while(1) { float_num+=0.01f; printf(&quot;float_num的值为: %.4f\\r\\n&quot;,float_num); vTaskDelay(500); } } 配合串口助手，就能看到现象。 注意 给每个任务分配的栈空间尽量大，起码256起步！ ","link":"https://leichen2552.github.io/post/stm32f429-yi-zhi-freertos/"},{"title":"STM32F429的SPI总线驱动AD7606","content":"目录 SPI协议简介 SPI物理层 SPI协议层 SPI基本通讯过程 通讯的起始和停止信号 数据有效性 CPOL/CPHA及通讯模式 STM32的 SPI特性及架构 STM32的 SPI外设简介 STM32的 SPI架构剖析 通讯引脚 AD7606与STM32的连接 AD7606初始化 AD7606复位 小计 代码 SPI协议简介 SPI协议是由摩托罗拉公司提出的通讯协议(Serial Peripheral Interface)，即串行外围设 备接口，是一种高速全双工的通信总线。它被广泛地使用在 ADC、LCD等设备与 MCU间， 要求通讯速率较高的场合。 SPI物理层 SPI通讯使用3条总线及片选线，3条总线分别为SCK、MOSI、MISO，片选线为SS‾\\overline{SS}SS，它们的作用介绍如下： SS‾\\overline{SS}SS( Slave Select)：从设备选择信号线，常称为片选信号线，也称为NSS,CS，以下用 NSS 表示。当有多个 SPI 从设备与 SPI 主机相连时，设备的其它信号线 SCK、MOSI及 MISO同时并联到相同的 SPI总线上，即无论有多少个从设备，都共同只使用这 3条总线；而每个从设备都有独立的这一条 NSS信号线，本信号线独占主机的一个引脚，即有多少个从设备，就有多少条片选信号线。I2C 协议中通过设备地址来寻址、选中总线上的某个设备并与其进行通讯；而 SPI 协议中没有设备地址，它使用 NSS 信号线来寻址，当主机要选择从设备时，把该从设备的 NSS 信号线设置为低电平，该从设备即被选中，即片选有效，接着主机开始与被选中的从设备进行 SPI 通讯。所以SPI通讯以NSS线置低电平为开始信号，以NSS线被拉高作为结束信号。 SCK (Serial Clock)：时钟信号线，用于通讯数据同步。它由通讯主机产生，决定了通讯的速率，不同的设备支持的最高时钟频率不一样，如 STM32的 SPI时钟频率最大为fplickf_{plick}fplick​/2，两个设备之间通讯时，通讯速率受限于低速设备。 MOSI (Master Output， Slave Input)：主设备输出/从设备输入引脚。主机的数据从这条信号线输出，从机由这条信号线读入主机发送的数据，即这条线上数据的方向为主机到从机。 MISO(Master Input,，Slave Output)：主设备输入/从设备输出引脚。主机从这条信号线读入数据，从机的数据由这条信号线输出到主机，即在这条线上数据的方向为从机到主机。 SPI协议层 SPI协议定义了通讯的起始和停止信号、数据有效性、时钟同步等环节。 SPI基本通讯过程 先看看SPI通讯的通讯时序： 这是一个主机的通讯时序。NSS、SCK、MOSI信号都由主机控制产生，而 MISO的信号由从机产生，主机通过该信号线读取从机的数据。MOSI与MISO的信号只在 NSS为低电平的时候才有效，在 SCK的每个时钟周期MOSI和MISO传输一位数据。 以上通讯流程中包含的各个信号分解如下： 通讯的起始和停止信号 在图中的标号1处，NSS信号线由高变低，是SPI通讯的起始信号。NSS是每个从机各自独占的信号线，当从机检在自己的NSS线检测到起始信号后，就知道自己被主机选中了，开始准备与主机通讯。在图中的标号6处，NSS信号由低变高，是SPI通讯的停止信号，表示本次通讯结束，从机的选中状态被取消。 数据有效性 SPI使用MOSI及MISO信号线来传输数据，使用 SCK信号线进行数据同步。MOSI及MISO数据线在SCK的每个时钟周期传输一位数据，且数据输入输出是同时进行的。数据传输时，MSB先行或 LSB先行并没有作硬性规定，但要保证两个SPI通讯设备之间使用同样的协定，一般都会采用上图MSB先行模式。 观察图中的2、3、4、5标号处，MOSI及 MISO的数据在 SCK的上升沿期间变化输出，在SCK的下降沿时被采样。即在 SCK的下降沿时刻，MOSI及MISO的数据有效，高电平时表示数据“1”，为低电平时表示数据“0”。在其它时刻，数据无效，MOSI及 MISO为下一次表示数据做准备。 SPI每次数据传输可以8位或16位为单位，每次传输的单位数不受限制。 CPOL/CPHA及通讯模式 上面讲述的图中的时序只是SPI中的其中一种通讯模式，SPI一共有四种通讯模式，它们的主要区别是总线空闲时 SCK的时钟状态以及数据采样时刻。为方便说明，在此引入“时钟极性CPOL”和“时钟相位CPHA”的概念。 时钟极性CPOL是指 SPI通讯设备处于空闲状态时，SCK信号线的电平信号(即 SPI通讯开始前、 NSS线为高电平时 SCK的状态)。CPOL=0时， SCK在空闲状态时为低电平，CPOL=1时，则相反。 时钟相位CPHA是指数据的采样的时刻，当CPHA=0时，MOSI或 MISO数据线上的信号将会在SCK时钟线的“奇数边沿”被采样。当CPHA=1时，数据线在SCK的“偶数边沿”采样。见下图。 我们来分析这个CPHA=0的时序图。首先，根据 SCK在空闲状态时的电平，分为两种情况。SCK信号线在空闲状态为低电平时，CPOL=0；空闲状态为高电平时，CPOL=1。 无论CPOL=0还是=1，因为我们配置的时钟相位CPHA=0，在图中可以看到，采样时刻都是在SCK的奇数边沿。注意当CPOL=0的时候，时钟的奇数边沿是上升沿，而CPOL=1的时候，时钟的奇数边沿是下降沿。所以SPI的采样时刻不是由上升/下降沿决定的。MOSI和MISO数据线的有效信号在SCK的奇数边沿保持不变，数据信号将在 SCK奇数边沿时被采样，在非采样时刻，MOSI和 MISO的有效信号才发生切换。 类似地，当CPHA=1时，不受CPOL的影响，数据信号在 SCK的偶数边沿被采样，见下图。 由 CPOL及CPHA的不同状态，SPI分成了四种模式，见表 24-1，主机与从机需要工作在相同的模式下才可以正常通讯，实际中采用较多的是“模式0”与“模式3”。 STM32的 SPI特性及架构 STM32芯片也集成了专门用于 SPI协议通讯的外设。 STM32的 SPI外设简介 STM32的SPI外设可用作通讯的主机及从机，支持最高的 SCK时钟频率为 fpclk/2f_{pclk}/2fpclk​/2 (STM32F429型号的芯片默认fpclk1f_{pclk1}fpclk1​为 90MHz，fpclk2f_{pclk2}fpclk2​为 45MHz)，完全支持SPI协议的4种模式，数据帧长度可设置为 8位或16位，可设置数据 MSB先行或LSB先行。它还支持双线全双工(前面小节说明的都是这种模式)、双线单向以及单线模式。其中双线单向模式可以同时使用MOSI及 MISO数据线向一个方向传输数据，可以加快一倍的传输速度。而单线模式则可以减少硬件接线，当然这样速率会受到影响。我们只讲解双线全双工模式。 STM32的 SPI架构剖析 通讯引脚 SPI的所有硬件架构都从图中左侧MOSI、MISO、SCK及NSS线展开的。STM32芯片有多个SPI外设，它们的SPI通讯信号引出到不同的GPIO引脚上，使用时必须配置到这些指定的引脚，见上表。关于GPIO引脚的复用功能，可查阅《STM32F4xx规格书》，以它为准。 其中SPI1、SPI4、SPI5、SPI6是APB2上的设备，最高通信速率达45Mbtis/s，SPI2、SPI3是APB1上的设备，最高通信速率为 22.5Mbits/s。其它功能上没有差异。 AD7606与STM32的连接 AD7606B是一个8路16位的ADC模块，AD7606接口有三种模式选择，并行接口模式、串行接口模式、并行字节接口模式。采用stm32的8080接口来驱动，AD7606模块上两个选择，一是8080模式，二是SPI模式，下图是SPI模式的接口。 AD7606初始化 STM32的SPI初始化、AD7606的GPIO初始化、设置采样量程、设置过采样模式、硬件复位AD7606、开始转换引脚设置为高电平。因为AD7606内部没有寄存器，所以不需要SPI发什么指令配置啥玩意儿的。 这里有个细节要说一下，就是SPI四根线中的MISO，MISO是Master Input Slave Output，意为主机输入从机输出，但是这个GPIO配置为推挽输出。明明是主机输入，怎么就成输出了？其实测试复用推挽输出也是可以的，因为方向是SPI硬件自己控制的。 AD7606复位 AD7606手册指明：RESET高电平脉冲宽度典型值是50ns 小计 大部分的信息都包含在手册里，包括串行接口、并行接口啥的 代码 8080模式的因为板子上接口未引出，所以没写，提供SPI的，定时器里面，500ms采样一次 链接：https://pan.baidu.com/s/1gz9NtGOcCmj-QJAFmWSDiQ 提取码：3s19 ","link":"https://leichen2552.github.io/post/stm32f429-de-spi-zong-xian-qu-dong-ad76068-lu-16-wei-adc/"},{"title":"STM32F429的FMC总线应用驱动AD7606（8路16位ADC）","content":"AD7607 产品规格： 16bit 分辨率，内置基准，单5V 供电。 8 路模拟输入，阻抗1M欧姆。【无需负电源，无需前端模拟运放电路，可直接接传感器输出】 输入范围可以选择正负5V 或者正负10V，可通过IO 控制量程。 最大采样频率 200Ksps，支持8 档过采样设置（可以有效降低抖动）。 通信接口支持SPI或16 位总线方式（也支持8 位总线，一般用的比较少），接口IO电平可以是5V 或3.3V。 重要提示： AD7606 的配置很简单，它没有内部寄存器，量程范围和过采样参数是通过外部 IO控制的，采样速 率由MCU 或DSP 提供的脉冲频率控制。 AD7606 必须使用单5V供电。 而AD7606和 MCU 之间的通信接口电平由VIO （VDRIVE）引脚控制。 也就是说VIO 必须接单片机的电源，可以是3.3V也可以是5V（范围2.3V – 5V）。 AD7607的过采样 采样频率高于信号最高频率的两倍，这种采样被称为过采样。 采样频率低于信号最高频率的两倍，这种采样被称为欠采样。 正确的理解过采样，比如我们设置是 1Ksps 采样率，64 倍过采样。意思是指每次采样，AD7606会 采样64 次数据并求平均，相当于AD7606以64Ksps 进行采样的，只是将每 64 个采样点的值做了 平均，用户得到的值就是平均后的数值。因此，如果使用AD7606最高的200Ksps采样率，就不可 以使用过采样了。 什么是FMC 在这之前先说一下FSMC和FMC的区别： 看到了吧，不同的芯片支部不同的功能，我们可以理解FMC是FSMC的增强版！ 其实一开始不理解为什么要用FMC来驱动AD7606，一般的资料对其的描述是“灵活的静态存储控制器”，乍一听以为是来控制存储的，再想想的话，其实就能理解为一个外部总线，且是一个可以自己定义时序的总线并且速度不慢，当驱动8080接口的器件是时，如果只是使用GPIO来实现此时序的话，会占用大量的CPU资源，所以这个时候就可以考虑采用FSMC功能。 由上面的FMC图可知，FMC支持NAND FLASH和NOR FLASH等接口。FMC将外部设备分为三类，分别是NOR/PSRAM设备，NAND设备和PC卡设备，以及SDRAM。他们共用地址数据总线等信号，通过不同的片选CS来区分不同的设备。 FMC 包含五个主要模块： AHB 接口（包括 FMC 配置寄存器） NOR Flash/PSRAM/SRAM 控制器 NAND Flash/PC 卡控制器 SDRAM 控制器 外部器件接口 外部器件地址映射 从 FMC 的角度，外部存储器被划分为 6 个固定大小的存储区域，每个存储区域的大小为 256 MB（请参见图 455）： 存储区域 1 可连接多达 4 个 NOR Flash 或 PSRAM 器件。此存储区域被划分为如下 4 个NOR/PSRAM 子区域，带 4 个专用片选信号： 存储区域 1 NOR/PSRAM 1 存储区域 1 NOR/PSRAM 2 存储区域 1 NOR/PSRAM 3 存储区域 1 NOR/PSRAM 4 存储区域 2 和 3 用于连接 NAND Flash 器件（每个存储区域一个器件） 存储区域 4 用于连接 PC 卡 存储区域 5 和 6 用于连接 SDRAM 器件（每个存储区域一个器件） 对于每个存储区域，所要使用的存储器类型可由用户应用程序通过配置寄存器配置。 那为什么要把AD7606当成这些内存设备来用呢？ 一般的外部SRAM有如下几根线：地址线（A0 ~ A18），数据线（D0 ~ D15），读信号（WE），写信号（OE），片选信号（CS），如果SRAM支持字节控制的话，还有UB和LB信号。 而这个AD7606的8080模式有哪几根线呢？ 而8080接口的AD7606有如下几根线：复位信号（RST），数据线（D0 ~ D15），读信号（RD），写信号（WD），片选信号（CS）和读写功能标志（RS）。 这两种接口看上去好像差不多诶… 但是不同的地方在于，AD7606没有地址信号，而且还多了个复位信号（RST），不过没事，这两个可以通过软件来控制。 https://blog.csdn.net/z_jinye/article/details/41045939 但是核心板上没有把接在SDRAM上的FMC接口引出，需要16个IO口。打算用SPI模式读取AD7606。 ","link":"https://leichen2552.github.io/post/stm32f429-de-fmc-zong-xian-ying-yong-zhi-qu-dong-ad76068-lu-16-wei-adc/"},{"title":"STM32把程序下载到哪？从哪里执行？ROM还是RAM","content":"stm32中的Code在程序运行时要不要拷贝到RAM里执行呢？还是直接从Flash中取程序指令执行？ 不是nand flash不能运行程序吗？难道32里用的是nor flash？ STM32的flash是代码存储区。SRAM是程序运行过程中中间变量存储区。 参考这边博文：https://blog.csdn.net/zd845101500/article/details/91370939 以下内容摘自论坛帖子https://bbs.csdn.net/topics/392020439 /****************************************************************************/ 如果你有研究过单片机编程的分散加载机制，在编程中写过分散加载脚本。你问的第一个问题就解决了。 如果你有写过nand flash的驱动程序，你问的第二个问题就解决了。 STM32中的code可以不用拷贝到RAM中运行，也可拷贝到RAM中运行，这些不是技术问题，而是要看这段code有没有加载到RAM中运行的必要。后面再解释。 nand flash不支持片上执行，不能在nand flash中执行程序，但nor flash支持。 但不能因此就断定STM32用的外置flash都是nor的。只要STM32带nand flash的控制器，就可以把nand中的code加载到RAM中运行。至于能不能用IO模拟nand 的接口协议，我没搞过不清楚。 首先，应该所有的单片机都是片内集成RAM和ROM(在加载域和运行域的角度看，Flash就是ROM)。 一般容量小的单片机，RAM和ROM都小，不会把flash中的代码加载到RAM中。 但有时确实需要加载，怎么办呢。就把code中比较关键的，调用很频繁的，对响应速度有要求的，就会加载到RAM中。 例如高频率中断的定时器中断ISR，就可以在分散加载脚本中修改这段code的运行域到RAM中。程序在刚上电后会在main函数之前加载这段code到RAM中。这样做的好处就是，这段code的执行速度快，我们知道ROM和RAM执行代码的速度比差距是很大的。RAM比ROM中执行速度快得多！ 当然，如果你的RAM很大，你甚至可以把全部的Code加载到RAM中运行。 nand flash不是直接接到CPU的三总线上的，所以CPU不能直接从nand中取得可执行的指令，而是通过nand的控制器！ 而nor是在总线上的，所以nor中的code可以直接执行。(nor的这个观点仅是我个人看法，仅供参考)。 再说外置RAM的问题，单片机在带SDRAM的控制器之后，就可以支持SDRAM了。 SDRAM在初始化好之后，SDRAM的使用方法和内置的SRAM没有差别。 如果你的单片机支持SDRAM和Nand flash，你可以把nand flash中的code加载到SDRAM中运行。 如果你知道怎么写分散加载脚本，这个功能分分钟就能实现。 /****************************************************************************/ /**************************************************************************** 一般容量小的单片机，RAM和ROM都小，不会把flash中的代码加载到RAM中。 请教一下大神，如果是代码中的全局变量，静态变量，也不会把flash中的代码加载到RAM中吗，那如果需要修改这些变量，flash中可以直接修改吗，另外感觉大神这一块研究很深，但是还是没给出答案，stm32内部既不是nor flash，也不是nandflash吗，最近我也是在用这个突然想到的，我觉得应该算是nor flash，因为总线可以直接访问到，我的一点疑惑 和大神探讨一下 ****************************************************************************/ /****************************************************************************/ 其实我也不是大神，真正的大神似乎都很少来论坛。。。。。。 “一般容量小的单片机，RAM和ROM都小，不会把flash中的代码加载到RAM中” 不好意思，我这句话有些背景概念没有交代清楚，看来已经误导了人。但是要说清楚，也不是一两句就说的清楚的。还是先直接回答你的问题吧。 1.flash中的代码，怎么加载到RAM中，有两种做法 A.编写或改写分散加载脚本，编译出来的程序，在启动时，也就是在进入你的main函数之前，会按照分散加载脚本的要求， 把全部或部分代码加载到RAM中。这个比较通用，也还算是比较简单。 B.自己编写加载代码，自己将自己的某个部分或全部加载到RAM中，如果没有特殊需要，建议用A方法。 什么是特殊需要呢，我一下展开不了，你看看嵌入式的bootloader，就是这么干的，非常普遍。 一般A的做法，是为了让某些被调用得非常频繁的函数，运行速度更快，这个你也知道单片机内的flash，执行速度比片内RAM慢。 你可以试试。如果是为了让某些函数被运行得更快，建议你用A方法，例如中断频率非常高的定时器ISR，把代码直接加载到RAM中， 以后就直接在RAM中运行这段代码了，而不去flash中拿这段代码了。 不过这些都已经优化的高级阶段了，实际产品开发中你知道这个优化方法，但也可能不会用得很多。 如果单片机本身的RAM就很小，你自然不能把太多的代码加载到里面，不然就没有足够的RAM给程序的其他代码用了，对不对。 你的代码中有没有用到静态变量（全局变量和静态变量），和代码要不要加载到RAM没有什么关系。 请注意，静态变量不是代码。静态变量属于数据段，定义时无初始化值的静态变量在ZI区，定义时有初始化值的在RW区，不过我有一点也很模糊，我不知道定义时有初始化值的，但初始值是0的，是不是也在ZI区。对应到嵌入式Linux的说法，叫ZI-&gt;BSS，RW-&gt;DATA，RO-&gt;text 建议你关注以下概念： 加载域，运行域。数据段，代码段，堆栈段。RO,RW,ZI. text，data，bss 书籍推荐杜春雷的《ARM体系结构与编程》 ，王宇行的《ARM程序分析与设计》，高阶的可以看《程序员的自我修养：链接、装载与库》 ，这几本书中都有上面这些概念的相关章节，可以挑着看。 2.怎么修改这些静态变量。 如果这些静态变量，不需要做到断电保存，那就没什么要说的。 如果你要做成断电保存，那你一定得要知道它在flash中的地址，对不对。 做法，我还是不写了，你上网找找资料吧，这个很多，做法也有几种。 3.STM32内部的flash是nor还是nand，其实我也不知道，说不定还有第三种答案呢。 但是没所谓，这几种flash的特点你都知道，这几种你都会用，就好了。硬要说是哪种，我觉得似乎更接近nor的特性。 /****************************************************************************/ ","link":"https://leichen2552.github.io/post/stm32-ba-cheng-xu-xia-zai-dao-na-cong-na-li-zhi-xing-rom-huan-shi-ram/"},{"title":"STM32F429之ADC","content":" ADC需要若干个ADC_CLK周期完成对输入的电压进行采样，采样的周期数可通过ADC 采样时间寄存器ADC_SMPR1和ADC_SMPR2中的 SMP[2:0]位设置，ADC_SMPR2控制的是通道 0 ~ 9，ADC_SMPR1控制的是通道10 ~ 17。每个通道可以分别用不同的时间采样。其中采样周期最小是 3个，即如果我们要达到最快的采样，那么应该设置采样周期为3个周期，这里说的周期就是1/ADC_CLK。 ADC的总转换时间跟ADC的输入时钟和采样时间有关：公式为 Tconv=采样时间+12个周期{T_{conv} = 采样时间 + 12个周期} Tconv​=采样时间+12个周期 当 ADCCLK = 30MHz，即PCLK2为 60MHz，ADC时钟为2分频，采样时间设置为 3个周期，那么总的转换时为：Tconv = 3 + 12 = 15个周期 =0.5us。 一般我们设置 PCLK2=90MHz，经过 ADC预分频器能分频到最大的时钟只能是 22.5M，采样周期设置为3个周期，算出最短的转换时间为0.6667us，这个才是最常用的。 15个周期∗1/(ADCCLK)=15∗(1/(22.5∗106))=0.667us15个周期 * 1/(ADC_{CLK} )= 15 * (1 / (22.5 * 10^6)) = 0.667us 15个周期∗1/(ADCCLK​)=15∗(1/(22.5∗106))=0.667us ","link":"https://leichen2552.github.io/post/stm32f439-zhi-adc/"},{"title":"一个字等于多少个字节？","content":" 位（bit） 来自英文bit，音译为“比特”，表示二进制位。位是计算机内部数据储存的最小单位。 字节（byte） 字节来自英文Byte，音译为“拜特”，习惯上用大写的“B”表示。 字节是计算机中数据处理的基本单位。 字 （word）计算机进行数据处理时，一次存取、加工和传送的数据长度称为字。一个字通常由一个或多个（一般是字节的整数位）字节构成。 一个字等于多少个字节，与系统硬件（总线、cpu命令字位数等）有关，不应该毫无前提地说一个字等于多少位。 正确的说法： 字节（byte） = 8位（bit） 在16位的系统中（比如8086微机） 1字 （word）= 2字节（byte）= 16（bit） 在32位的系统中（比如win32） 1字（word）= 4字节（byte）=32（bit） 在64位的系统中（比如win64）1字（word）= 8字节（byte）=64（bit） ","link":"https://leichen2552.github.io/post/yi-ge-zi-deng-yu-duo-shao-ge-zi-jie/"},{"title":"SRAM、DRAM和SDRAM的区别","content":"SRAM ：静态RAM，不用刷新，速度可以非常快，像CPU内部的cache，都是静态RAM，缺点是一个内存单元需要的晶体管数量多，因而价格昂贵，容量不大。 DRAM：动态RAM，需要刷新，容量大。 SDRAM：同步动态RAM，需要刷新，速度较快，容量大。 DDR SDRAM：双通道同步动态RAM，需要刷新，速度快，容量大。 什么是SRAM SRAM 的英文全称是&quot;Static RAM&quot;，翻译成中文就是'静态随机存储器'。SRAM主要用于制造Cache。 什么是PSRAM PSRAM就是伪SRAM，内部的内存颗粒跟SDRAM的颗粒相似，但外部的接口跟SDRAM不同，不需要SDRAM那样复杂的控制器和刷新机制，PSRAM的接口跟SRAM的接口是一样的。PSRAM 内部自带刷新机制。 容量模式 PSRAM容量有4Mb,8Mb,16Mb,32Mb，64Mb, 128Mb等等，容量没有SDRAM那样密度高，但肯定是比SRAM的容量要高很多的，速度支持突发模式，并不是很慢，APmemory，Hynix，Fidelix,Coremagic, WINBOND .MICRON. CY 等厂家都有供应，价格只比相同容量的SDRAM稍贵一点点，比SRAM便宜很多。 什么是SDRAM SDRAM 的英文全称是'Synchronous DRAM'，翻译成中文就是'扩充数据输出内存'，它比一般DRAM和EDO RAM速度都快，它已经逐渐成为PC机的标准内存配置。 什么是Cache Cache 的英文原意是'储藏'，它一般使用SRAM制造，它与CPU之间交换数据的速度高于DRAM，所以被称作'高速缓冲存储器'，简称为'高速缓存'。由于CPU的信息处理速度常常超过其它部件的信息传递速度，所以使用一般的DRAM来作为信息存储器常常使CPU处于等待状态，造成资源的浪费。Cache就是为了解决这个问题而诞生的。在操作系统启动以后，CPU就把DRAM中经常被调用的一些系统信息暂时储存在Cache里面，以后当CPU需要调用这些信息时，首先到Cache里去找，如果找到了，就直接从Cache里读取，这样利用Cache的高速性能就可以节省很多时间。大多数CPU在自身中集成了一定量的Cache，一般被称作'一级缓存'或'内置Cache'。这部分存储器与CPU的信息交换速度是最快的，但容量较小。大多数主板上也集成了Cache，一般被称作'二级缓存'或'外置Cache'，比内置Cache容量大些，一般可达到256K，现在有的主板已经使用了512K～2M的高速缓存。在最新的Pentium二代CPU内部，已经集成了一级缓存和二级缓存，那时主板上的Cache就只能叫作'三级缓存'了。 什么是闪存 闪存 目前主板上的BIOS大多使用Flash Memory制造，翻译成中文就是'闪动的存储器'，通常把它称作'快闪存储器'，简称'闪存'。这种存储器可以直接通过调节主板上的电压来对BIOS进行升级操作。 FLASH：非易失存储器，简单的讲就是掉电之后里面的存储数据不会丢失，在嵌入式系统中用作存储Bootloader以及操作系统或者程序代码或者直接 当硬盘使用（U盘）。一般主要使用的FLASH有NOR和NAND，一般小容量的用NOR因为其读取速度快，多用来存储操作系统等重要信息，大容量的用 NAND，如U盘，可以在线擦除。FLASH的存贮组织为分页型的，对其的操作分为擦除和编程，必须先擦除再编程，操作方式是通过向FLASH写入一定的 命令序列来实现不同的操作。 ","link":"https://leichen2552.github.io/post/sramdram-he-sdram-de-qu-bie/"},{"title":"STM32命名规则","content":"STM32型号的说明：以STM32F103RBT6这个型号的芯片为例，该型号的组成为7个部分，其命名规则如下： 所以，目前所用芯片STM32F429IGT6，名字解读如下： STM32：32位MCU F：基础型 429：具有特定功能 I：176脚 G：1024kb的闪存容量 T：QFP封装 6：−40-40−40 ~ +85+85+85摄氏度 ","link":"https://leichen2552.github.io/post/stm32-ming-ming-gui-ze/"},{"title":"ESP8266","content":"ESP8266的工作模式 ESP8266共有三种工作模式，分别是Station模式，AP模式，AP+Station模式。ESP8266出厂默认是第三种模式。 1、Station模式，Station就像一个接收器，可以接收其他接收器的的信号，而我们的手机、笔记本等就像是一个个的Station，可以接收路由器发出的信号。 2、AP模式：AP是Wireless Access Point的简称，中文名称：无线接入点；AP模式也就是无线接入点模式。其主要作用是将各个无线网络客户端连接到一起，然后将无线网络接入以太网(这正是Access Point名称的本义)，我们家里的路由器就工作在这个模式下，说简单点，就像一个基站，将有线网络转换成无线网络发射出去，这样我们的手机、电脑等就可以连接扩展出来的无线网络上网了。 3、AP+Station模式，模块支持一个AP接口，一个Station接口。即可接受AP的无线，自身也可发送无线。 透传 透传概念： 透传即是透明传送，是指传送网络无论传输业务如何，只负责将需要传送的业务传送到目的节点，同时保证传输的质量即可，而不对传输的业务进行处理。在数据的传输过程中，这组数据不发生任何形式的改变，即不竭断，不分组，不编码，不加密，不混淆等等，仿佛传输过程是透明的一样，原封不动地到了最终接收者手里。 透传模式的要求： 透传模式只能在单链接模式下开启； 模块开启服务器模式时，必须开启多链接模式，所以只能作为单链接模式下的客户端。 透传与非透传的区别： 开启透传模式，可以连续的发送数据，而非透传模式下，每次发送数据前都需要发送相关的发送数据的AT指令。 透传时必须选择单路模式。 ","link":"https://leichen2552.github.io/post/esp8266/"},{"title":"STM32的BSRR与BRR寄存器的区别","content":"使用BRR和BSRR寄存器可以方便地快速地实现对端口某些特定位的操作，而不影响其它位的状态。 比如希望快速地对GPIOE的位7进行翻转，则可以： GPIOE-&gt;BSRR = 0x80; // 置'1' GPIOE-&gt;BRR = 0x80; // 置'0' 如果使用常规'读-改-写'的方法： GPIOE-&gt;ODR = GPIOE-&gt;ODR | 0x80; // 置'1' GPIOE-&gt;ODR = GPIOE-&gt;ODR &amp; 0xFF7F; // 置'0' 有人问是否BSRR的高16位是多余的，请看下面这个例子： 假如你想在一个操作中对GPIOE的位7置'1'，位6置'0'，则使用BSRR非常方便： GPIOE-&gt;BSRR = 0x00400080; 如果没有BSRR的高16位，则要分2次操作，结果造成位7和位6的变化不同步！ GPIOE-&gt;BSRR = 0x80; GPIOE-&gt;BRR = 0x40; 规则 置GPIOD-&gt;BSRR低16位的某位为'1'，则对应的I/O端口置'1'；而置GPIOD-&gt;BSRR低16位 的某位为'0'，则对应的I/O端口不变。 置GPIOD-&gt;BSRR高16位的某位为'1'，则对应的I/O端口置'0'；而置GPIOD-&gt;BSRR高16位 的某位为'0'，则对应的I/O端口不变。 置GPIOD-&gt;BRR低16位的某位为'1'，则对应的I/O端口置'0'；而置GPIOD-&gt;BRR低16位的 某位为'0'，则对应的I/O端口不变。 例如： 要设置D0、D5、D10、D11为高，而保持其它I/O口不变，只需一行语句： GPIOD-&gt;BSRR = 0x0C21；// 使用规则一 要设置D1、D3、D14、D15为低，而保持其它I/O口不变，只需一行语句： GPIOD-&gt;BRR = 0xC00A；// 使用规则三 要同时设置D0、D5、D10、D11为高，设置D1、D3、D14、D15为低，而保持其它I/O口不变，也只需一行语句： GPIOD-&gt;BSRR = 0xC00A0C21；// 使用规则一和规则二 ","link":"https://leichen2552.github.io/post/stm32-de-bsrr-yu-brr-ji-cun-qi-de-qu-bie/"},{"title":"运算电路","content":"运算类型 Summation(加法求和)，Subtraction(减法) Intgration(积分)，differentation(微分) Logarithmic(对数)，exponential(指数) Multiplier(模拟乘法器)： Multiplication(乘)，division(除) square(平方)，square root(开方) 加法电路 两个输入端的电阻必须要满足比例系数 加法电路应用 减法电路 为了提升输入电阻，可以用放大倍数为1的电压跟随器组合起来，这个输入电阻就位无穷大 但是这要同时调整两个RRR和RfR_fRf​，所以加入了如下三个电阻 ","link":"https://leichen2552.github.io/post/yun-suan-dian-lu/"},{"title":"信号放大、隔离电路、滤波电路","content":"信号放大器 电压放大器（比例运算电路） 虚短和虚断的概念 由于运放的电压放大倍数很大，一般通用型运算放大器的开环电压放大倍数都在80dB80 dB80dB以上(1万倍)。而运放的输出电压是有限的，一般在 10V～14V10 V～14 V10V～14V。因此运放的差模输入电压不足1mV1 mV1mV，两输入端近似等电位，相当于 “短路”。开环电压放大倍数越大，两输入端的电位越接近相等。 “虚短”是指在分析运算放大器处于线性状态时，可把两输入端视为等电位，这一特性称为虚假短路，简称虚短。显然不能将两输入端真正短路。 “虚断”相对于“虚短”理解起来就容易多了，他是说电流流向运放输入端几乎为零，在上图中体现在iRi_RiR​等于iFi_FiF​，这是由于运放输入差模电阻很大，理想运放可近似看为无穷大，如果输入差模电阻是无穷大也就是开路了，所以并没有电流流入，实际运放虽说不是无穷大，但是这个值很大，一般都在1MΩ1MΩ1MΩ以上，因此流向运放输入端电流很小（可以反推，如果电流为1mA1mA1mA，就会产生很高的输入差模电压，显然运放不能正常工作了），因此可以近似看为断路，并不是真正的断路，也就是“虚断”。 豪兰德电流源 点过电阻之间的比值有以下关系的话，那么： 电荷放大器 隔离放大器 滤波电路 有源滤波器 有源滤波器带负载能力强 幅频特性及通带截止频率 滤波器的传输函数 对于二阶： a0,a1=0，a2≠0a_0,a_1 = 0，a_2 \\neq 0a0​,a1​=0，a2​​=0，那么这就是二阶高通滤波器 a1,a2=0，a0≠0a_1,a_2 = 0，a_0 \\neq 0a1​,a2​=0，a0​​=0，那么这就是二阶低通滤波器 a0,a2=0，a1≠0a_0,a_2 = 0，a_1 \\neq 0a0​,a2​=0，a1​​=0，那么这就是二阶带通滤波器 Q是传输函数的品质因数，Q是指：频率在截止频率fp附近，它的幅频特性电压放大倍数这个幅值。这个值越大，电压放大倍数在通带截止频率附近的值就越大。那这个滤波器的特性就更理想一些。 滤波器设计 一阶滤波器，-20dB下降速度 效果不够理想 二阶滤波器，-40dB下降速度 但是在曲线拐弯的地方，也就是通带到过渡带的地方，它的电压放大倍数幅度下降得比较快的地方，这时它的滤波特性还不够理想，那么就要提升他在截止频率附近的电压放大倍数。 那有什么办法提升它在截止频率附近的电压放大倍数？ 引入正反馈，VCVS（电压控制的电压源）用来提升它在截止频率附近的电压放大倍数 BPF：R1、C1R_1、C_1R1​、C1​组成低通滤波环节，R2、C2R_2、C_2R2​、C2​组成高通滤波环节 BEF：采用双T带阻网络，2个R2个R2个R和2C2C2C组成组成低通滤波环节，上面的2个C2个C2个C和一个R/2R/2R/2的组成高通滤波环节 低通滤波器的幅频特性曲线 ","link":"https://leichen2552.github.io/post/xin-hao-fang-da-he-ge-chi-dian-lu/"},{"title":"聚类算法Clustering","content":"对一组没有标记（代表原始数据，没有标签）的的数据，来发现这组数据的内在结构。 similarity 抽象表征 自然的类，自然的数据类型 找到合适有用的组 聚类算法应用 模式识别 空间数据分析 图像处理 经济分析，股市分析 WWW里的文本分类，文档分类 聚类分析 找出这些数据的相似性 可扩展性 处理不同类型的属性 ","link":"https://leichen2552.github.io/post/ju-lei-suan-fa-clustering/"},{"title":"FPGA状态机设计实例","content":" ","link":"https://leichen2552.github.io/post/fpga-zhuang-tai-ji-she-ji-shi-li/"},{"title":"FPGA之阻塞赋值与非阻塞赋值","content":" 阻塞赋值 （d = a+b）在前，（out = d+c）在后 （out = d+c）在前，（d = a+b）在后 非阻塞赋值 （d &lt;= a+b）在前，（out &lt;= d+c）在后 （out &lt;= d+c）在前，（d &lt;= a+b）在后 阻塞赋值与非阻塞赋值区别 阻塞赋值 （d = a+b）在前，（out = d+c）在后 module block_nonblock(Clk, Rst_n, a,b,c, out); input Clk; input Rst_n; input a,b,c; //out = a + b + c; output reg [1:0]out; //d = a + b //out = d + c; reg [1:0]d; always@(posedge Clk or negedge Rst_n) if(!Rst_n) out = 2'b0; else begin d = a + b; out = d + c; end endmodule （out = d+c）在前，（d = a+b）在后 module block_nonblock(Clk, Rst_n, a,b,c, out); input Clk; input Rst_n; input a,b,c; //out = a + b + c; output reg [1:0]out; //d = a + b //out = d + c; reg [1:0]d; always@(posedge Clk or negedge Rst_n) if(!Rst_n) out = 2'b0; else begin out = d + c; d = a + b; end endmodule 非阻塞赋值 （d &lt;= a+b）在前，（out &lt;= d+c）在后 module block_nonblock(Clk, Rst_n, a,b,c, out); input Clk; input Rst_n; input a,b,c; //out = a + b + c; output reg [1:0]out; //d = a + b //out = d + c; reg [1:0]d; always@(posedge Clk or negedge Rst_n) if(!Rst_n) out &lt;= 2'b0; else begin d &lt;= a + b; out &lt;= d + c; end endmodule `timescale 1ns/1ns `define tp 1 //模拟电路延时 module block_nonblock(Clk, Rst_n, a,b,c, out); input Clk; input Rst_n; input a,b,c; //out = a + b + c; output reg [1:0]out; //d = a + b //out = d + c; reg [1:0]d; always@(posedge Clk or negedge Rst_n) if(!Rst_n) out &lt;= #`tp 2'b0; else begin d &lt;= #`tp a + b; out &lt;= #`tp d + c; end endmodule （out &lt;= d+c）在前，（d &lt;= a+b）在后 module block_nonblock(Clk, Rst_n, a,b,c, out); input Clk; input Rst_n; input a,b,c; //out = a + b + c; output reg [1:0]out; //d = a + b //out = d + c; reg [1:0]d; always@(posedge Clk or negedge Rst_n) if(!Rst_n) out &lt;= 2'b0; else begin out &lt;= d + c; d &lt;= a + b; end endmodule 阻塞赋值与非阻塞赋值区别 阻塞和非阻塞赋值的区别在：阻塞是顺序执行，而非阻塞是并行执行。 ","link":"https://leichen2552.github.io/post/fpga-zhi-zu-sai-fu-zhi-yu-fei-zu-sai-fu-zhi/"},{"title":"FPGA之BCD码计数器","content":" 代码 用时序逻辑电路的波形问题 改用组合逻辑电路的正确波形 代码 module BCD_Counter(Clk, Cin, Rst_n, Cout, q); input Clk; //计数基准时钟 input Cin; //计数器进位输入 input Rst_n; //系统复位 output Cout; //计数进位输出 output [3:0]q; //计数器值输出 reg [3:0]cnt; //执行计数过程 always@(posedge Clk or negedge Rst_n) if(Rst_n == 1'b0) cnt &lt;= 4'd0; else if(Cin == 1'b1)begin if(cnt == 4'd9) cnt &lt;= 4'd0; else cnt &lt;= cnt + 1'b1; end else cnt &lt;= cnt; //不要在不同的always块中对同一个变量赋值 //不要在同一个always块中同时使用阻塞赋值与非阻塞赋值 //时序逻辑电路always块中被赋值的变量必须是reg /* always时序逻辑电路中用 &lt;= 非阻塞赋值，在时序逻辑电路中用 = 阻塞赋值 简单理解就是：在边沿敏感的always块中用非阻塞赋值，在电平敏感的always块中用阻塞赋值 */ /* always的敏感列表中包括多个电平敏感事件，也可以同时包括多个电平敏感事件，但是不能同时有电平和边沿敏感事件。 另外，敏感列表中，同时包含一个信号的上升沿和下降沿也是不允许的，因为这两个事件可以合并成一个电平事件 */ //产生进位输出信号 //这是把之前的时序逻辑电路（注释内）改成组合逻辑电路 assign Cout =(Cin == 1'b1 &amp;&amp; cnt == 4'd9); /* always@(posedge Clk or negedge Rst_n) if(Rst_n == 1'b0) Cout &lt;= 1'b0; else if(Cin == 1'b1 &amp;&amp; cnt == 4'd9) Cout &lt;= 1'b1; else Cout &lt;= 1'b0; */ assign q = cnt; endmodule 用时序逻辑电路的波形问题 进位链的问题 改用组合逻辑电路的正确波形 ","link":"https://leichen2552.github.io/post/fpga-zhi-bcd-ma-ji-shu-qi/"},{"title":"FPGA之计数器IP核的调用（超详细过程）","content":" LPM_counter IP核使用 新建工程 新建LPM_counter IP核 把生成的ip核文件设置为顶层文件 新建testbench文件 counter_ip_tb文件 编译一次，开始分析综合 设置TestBench文件 仿真 LPM_counter IP核使用 Quartus 软件日工的LPM_counter IP核的使用 FPGA设计方式： 原理图（不推荐） Verilog HDL 设计方式 IP核的设计方式 新建工程 这一页如果没有文件的话，可以不用管 新建LPM_counter IP核 这就是生成的ip核文件 把生成的ip核文件设置为顶层文件 新建testbench文件 counter_ip_tb文件 `timescale 1ns/1ns `define clock_period 20 module counter_ip_tb; reg cin; reg clk; wire cout; wire [3:0]q; Counter_IP Counter_IP0( .cin(cin), .clock(clk), .cout(cout), .q(q) ); initial clk = 1; always #(`clock_period/2) clk = ~clk; initial begin repeat(30)begin cin = 0; #(`clock_period * 5) cin = 1; #(`clock_period) cin = 0; end #(`clock_period * 200); $stop; end endmodule 编译一次，开始分析综合 分析综合没有错误，就可以进行下一步 设置TestBench文件 点击Simulation 点击TestBenches 点击New 点击 Add 设置显示 仿真 进行RTL仿真 仿真波形如下，确实是16位的计数器，从0计数到15就清零 ","link":"https://leichen2552.github.io/post/fpga-zhi-ji-shu-qi-ip-he-de-diao-yong/"},{"title":"FPGA之计数器的编写","content":" 实验要求 代码编写 仿真文件编写 ModelSim仿真波形 数字逻辑图 实验要求 LED，每500ms，状态翻转一次 系统时钟为50M，对应周期是20ns 500ms = 500_000_000ns / 20ns = 25_000_000 代码编写 module Counter(Clk50M, Rst_n, led);//Rst_n表示低电平有效 input Clk50M;//系统时钟：50M input Rst_n;//全局复位，低电平复位 output reg led;//led输出 reg [24:0]cnt;//定义计数器寄存器 //计数器技术进程 always@(posedge Clk50M or negedge Rst_n)//总在在时钟上升沿或者复位下降沿 if(Rst_n == 1'b0) cnt &lt;= 25'd0; else if(cnt == 25'd24_999_999)//从0开始，只要加到24_999_999 cnt &lt;= 25'd0; else cnt &lt;= cnt + 1'b1; //Led输出控制进程 always@(posedge Clk50M or negedge Rst_n)//总在在时钟上升沿或者复位下降沿 if(Rst_n == 1'b0) led &lt;= 1'b1; else if(cnt == 25'd24_999_999) led &lt;= ~led; else led &lt;= led; endmodule 仿真文件编写 `timescale 1ns/1ns `define clock_period 20 //声明一个宏定义参数 module Counter_tb; reg clk; reg rst_n; wire led; Counter counter0( .Clk50M(clk), //这个前面的点一定要加 .Rst_n(rst_n), .led(led) ); initial clk = 1;//初始化clk是高电平 //表示时钟信号总是以#10ns翻转 always #(`clock_period/2) clk = ~clk; //(`)这表示调用一个宏定义的参数 initial begin rst_n = 1'b0; #(`clock_period * 200); rst_n = 1'b1; #2000000000;//延时2000毫秒 $stop; end endmodule ModelSim仿真波形 如果是按照500ms翻转，博主已经试过，得跑四五十分钟才能看到波形，所以我们改成500us (cnt == 25'd24_999_999)改成(cnt == 25'd24_999) 数字逻辑图 Quarters软件生成的数字逻辑电路 点击RTL Viewer，就可以该软件根据代码生成的数字逻辑图 ","link":"https://leichen2552.github.io/post/fpga-zhi-ji-shu-qi-de-bian-xie/"},{"title":"电机分类","content":"直流电机 直流电机（direct current machine）是指能将直流电能转换成机械能（直流电动机）或将机械能转换成直流电能（直流发电机）的旋转电机。它是能实现直流电能和机械能互相转换的电机。当它作电动机运行时是直流电动机，将电能转换为机械能；作发电机运行时是直流发电机，将机械能转换为电能。 步进电机 工作原理：步进电机是一种将电脉冲转化为角位移的执行机构。当步进驱动器接收到一个脉冲信号, 它就驱动步进电机按设定的方向转动一个固定的角度(称为”步距角“)，它的旋转是以固定的角度一步一步运的。可以通过控制脉冲个数来控制角位移量，从而达到准确定位的目的；同时可以通过控制脉冲频率来控制电机转动的速度和加速度,从而达到调速的目的。 伺服电机 伺服电机内部的转子是永磁铁,驱动器控制的U/N/W三相电形成电磁场,转子在此磁场的作用下转动，同时电机自带的编码器反馈信号给驱动器,驱动器根据反馈值与目标值进行比较,调整转子转动的角度。伺服电机的精度决定于编码器的精度(线数)。 有刷电机 有刷电机采用机械换向，磁极不动，线圈旋转。电机工作时，线圈和换向器旋转，磁钢和碳刷不转，线圈电流方向的交替变化是随电机转动的换相器和电刷来完成的。 在有刷电机中，这个过程是将各组线圈的两个电源输入端，依次排成一个环，相互之间用绝缘材料分隔，组成一个象圆柱体的东西，与电机轴连成一体，电源通过两个碳元素做成的小柱子（碳刷），在弹簧压力的作用下，从两个特定的固定位置，压在上面线圈电源输入环状圆柱上的两点，给一组线圈通电。 随着电机转动，不同时刻给不同线圈或同一个线圈的不同的两极通电，使得线圈产生磁场的N-S极与最靠近的永磁铁定子的N-S极有一个适合的角度差，磁场异性相吸、同性相斥，产生力量，推动电机转动。碳电极在线圈接线头上滑动，象刷子在物体表面刷，因此叫碳“刷”。 相互滑动，会摩擦碳刷，造成损耗，需要定期更换碳刷；碳刷与线圈接线头之间通断交替，会发生电火花，产生电磁破，干扰电子设备。 无刷电机 转子上有NS级，有三对线圈绕在定子上，三对线圈先后通上电流再关闭，就能让外面的转子转动。 但是这样的转动不圆滑，而且动率小。 按下图这样，前一对线圈在前面吸引，后一对线圈在后面推动，这样就十分圆滑，且功率就提升上来。 但是有两个问题： 什么时候给线圈通电？ 该给哪两对线圈通电？ 用霍尔传感器来检测转子的位置 电机参数 ","link":"https://leichen2552.github.io/post/dian-ji-fen-lei/"},{"title":"FPGA之三八译码器的编写","content":" 三八译码器真值表 代码编写 测试文件编写 RTL仿真 门级仿真 三八译码器真值表 A B C output 0 0 0 0000_0001 0 0 1 0000_0010 0 1 0 0000_0100 0 1 1 0000_1000 1 0 0 0001_0000 1 0 1 0010_0000 1 1 0 0100_0000 1 1 1 1000_0000 代码编写 module Decoder3_8(a, b, c, out); input a; input b; input c; output [7:0]out;//定义多位位宽的信号 always@(a,b,c)begin case({a,b,c})//用花括号位拼接 3'b000:out = 8'b0000_0001;//下划线是占位符，不代表任何意思 3'b001:out = 8'b0000_0010; 3'b010:out = 8'b0000_0100; 3'b011:out = 8'b0000_1000; 3'b100:out = 8'b0001_0000; 3'b101:out = 8'b0010_0000; 3'b110:out = 8'b0100_0000; 3'b111:out = 8'b1000_0000; //default:out = 8'b1000_0000; endcase end endmodule 编译报错：Error (10137): Verilog HDL Procedural Assignment error at Decoder3_8.v(10): object &quot;out&quot; on left-hand side of assignment must have a variable data type 在always@()块中的输出信号一定要是reg型，所以output [7:0]out;修改成output reg [7:0]out; /* 这样也行 output [7:0]out; reg [7:0]out; */ 测试文件编写 `timescale 1ns/1ps//定义 延时和仿真 精度 module Decoder3_8_tb; reg a;//定义激励信号源 reg b;//定义激励信号源 reg c;//定义激励信号源 wire [7:0] out;//定义观测信号源 Decoder3_8 u1( .a(a), //一定要在a之前加上点 .b(b), .c(c), .out(out) ); initial begin a = 0;b = 0;c = 0; #100; a = 0;b = 0;c = 1; #100; a = 0;b = 1;c = 0; #100; a = 0;b = 1;c = 1; #100; a = 1;b = 0;c = 0; #100; a = 1;b = 0;c = 1; #100; a = 1;b = 1;c = 0; #100; a = 1;b = 1;c = 1; #200; $stop; end endmodule RTL仿真 门级仿真 为什么门级仿真会出现电平混乱？ 因为现实的电子器件，电平0000_0001 跳转到 0000_0010时，有可能是0000_0001成0000_0011，然后0000_0011再变成0000_0010，器件当中会存在电平跳变的时间差，所以会有这样的现象。 ","link":"https://leichen2552.github.io/post/fpga-zhi-san-ba-yi-ma-qi-de-bian-xie/"},{"title":"FPGA语法简单介绍","content":"Verilog文件基本结构 /*****第一种定义*****/ 模块声明 模块名(端口列表) module mux2(a, b, sel, out, io); //端口属性定义 input [7:0]a;//定义位宽 input [7:0]b; input sel;//sel = 0时，out = a;要么out = b; output [7:0]out; inout io; /*一般组合逻辑的信号由wire定义，时序逻辑的信号由reg来定义*/ //定义内部信号 wire oe;//线网型 reg oo; /*连续赋值语句*/ assign out = ( sel == 0 ) ? a : b; assign out = !sel ? a : b ; assign out = sel ? a : b; /*三态门控制*/ assign = oe = sel; assign io = oe ? out[0] : 1'bz; /*Verilog HDL取位操作*/ //1、取某一位的数据用作数据源 wire [2:0]m; assign m = out[5:3]; //循环右移 reg [7:0]shift_a; always@(posedge clk) shift_a &lt;= {shift_a[0], shift_a[7:1]}; //移位寄存器 reg [7:0]shift_a; wire data; always@(posedge clk) shift_a &lt;= {shift_a[6:0], data}; //移位寄存器 reg [7:0]shift_a; wire data; always@(posedge clk) shift_a &lt;= {data，shift_a[7:1]}; wire [3:0]x; wire [3:0]y; wire [7:0]z; wire [31:0]x; //拼接 assign z = {x, y}; assign n = {y, 7{x}};//下面同这种拓宽7倍的x assign n = {y, x, x, x, x, x, x, x}; assign n = {y, 7{1'b1};//7倍的一个比特宽度的1 //数据表示 assign x = 4'b1001; //x是4个比特宽度的二进制1001 assign x = 4'd9; //x是4个比特宽度的十进制9 assign x = 4'h9; //x是4个比特宽度的十六进制9 assign x = 4'hc; assign n = 32'h1234_5678; assign n = 8'b1101_0011; /***运算***/ /*加（+）、减（-）、乘（*）、除（/）,加减乘都能用，但是除法不行，对于时效性不高的，除法可以用剪发代替，但是对于时效性高的*/ //逻辑运算 //与或非 //逻辑与（&amp;&amp;），逻辑或（||），逻辑非（！） a = 4'b1011; b = 4'b0000 wire c; c = a &amp;&amp; b; = 0//逻辑只有真跟假 //按位与，按位或，按位取反 a = 4'b1011; b = 4'b0110; wire [3:0]c; wire [3:0]d; wire [3:0]e; c = a&amp;b; = 4'b0010 d = a | b; = 4'b1111 e = ~b; = 4'b1101 endmodule /*****第二种定义*****/ module mux2 { //端口属性定义 input [7:0]a, input [7:0]b, input sel, output [7.0]out, inout io//最后一个不加逗号 } endmodule module mux4(); endmodule **注意！always块使用注意事项 ** 不要在不同的always块内为同一个变量赋值。 不要在同一个always块内同时使用阻塞赋值（=）和非阻塞赋值（&lt;=）。 使用always块描述组合逻辑时使用阻塞赋值（=），在使用always块描述时序逻辑时使用非阻塞赋值（&lt;=）。简单理解就是，在电平敏感的always块内使用阻塞赋值，在边沿敏感的always块内使用非阻塞赋值。 任何在always块内“被赋值的变量”都必须是寄存器型（reg）。即，&lt;=或=左边的信号，必须是reg型。 always的敏感列表中可以同时包括多个电平敏感事件，也可以同时包括多个边沿敏感事件，但不能同时有电平和边沿敏感事件。另外，敏感列表中，同时包括一个信号的上升沿和它的下降沿敏感事件也是不允许的，因为这两个事件可以合并为一个电平事件。 ","link":"https://leichen2552.github.io/post/fpga-yu-fa-jian-dan-jie-shao/"},{"title":"科学FPGA开发流程","content":" 科学FPGA开发流程 二选一多路器 设计定义 代码编写 led_test.v 仿真代码编写 led_test_tb.v 开始仿真 仿真结果 分配管脚 下载程序 科学FPGA开发流程 设计定义 设计输入 分析和综合 功能仿真（modelsim-altera） 布局布线 时序仿真（modelsim-altera） IO分配以及配置文件的生成 配置（烧写FPGA） 在线调试 二选一多路器 设计定义 两个输入IO，a、b。可以是高电平，也可以是低电平 输入按键按下时，LED灯与a端口报纸一致 输入按键释放时，LED灯与b端口报纸一致 代码编写 led_test.v module led_test(a, b, key_in, led_out);//模块名 工程名（端口名） //input a, b;//这样也行，就是输入端口a,b input a;//输入端口a input b;//输入端口b input key_in;//按键输入，也叫做选择信号，实现输入通道的选择 output led_out;//led控制输出端口 //当key_in == 0，led_out = a; assign led_out = (key_in == 0)? a : b;//assign是连续赋值语句 endmodule 仿真代码编写 led_test_tb.v `timescale 1ns/1ps//定义延时和仿真精度 //#100.1//这个就是延时100纳秒.仿真精度 //testbench文件是一种仿真手段 module led_test_tb;//这是一个基于led_test这个工程的testbench文件 //激励信号定义，对应连接到待测试模块的输入端口 reg signal_a; reg signal_b; reg signal_c; //待检测信号定义，对应连接到待测试模块的输出端口 wire led; //例化待测试模块 led_test led_test0( .a(signal_a),//接线 .b(signal_b),//接线 .key_in(signal_c),//接线 .led_out(led)//接线 ); //产生激励 initial begin signal_a = 0;signal_b = 0;signal_c = 0; #100;//延时100纳秒 signal_a = 0;signal_b = 0;signal_c = 1; #100; signal_a = 0;signal_b = 1;signal_c = 0; #100; signal_a = 0;signal_b = 1;signal_c = 1; #100; signal_a = 1;signal_b = 0;signal_c = 0; #100; signal_a = 1;signal_b = 0;signal_c = 1; #100; signal_a = 1;signal_b = 1;signal_c = 0; #100; signal_a = 1;signal_b = 1;signal_c = 1; #200; $stop;//系统函数停止仿真 end endmodule 然后点击编译Start Analysis and Synthesis 开始仿真 点击Tools→\\rightarrow→Run EDA Simulation Tool→\\rightarrow→EDA RTL Simulation 如果出来下面这幅图，就说明你没有安装ModelSim-Altera，去安装就可以了 然后设置Tools→\\rightarrow→Options→\\rightarrow→EDA Tool Options 在ModelSim-Altera那儿设置路径。 这中间还有个门级电路仿真，条件更苛刻，会出现延时，以后再说！ 仿真结果 这个仿真结果跟之前分析的一样。 分配管脚 点击Assignmengs→\\rightarrow→Pin Planner 下载程序 点击Tools→\\rightarrow→Programmer 这就OK，然后在板子上看现象就行 ","link":"https://leichen2552.github.io/post/ke-xue-fpga-kai-fa-liu-cheng/"},{"title":"模糊信息处理技术","content":" 集合 集合的概念 集合的特征函数表示 集合的直积 关系矩阵 模糊集 A∼\\mathop{ A }\\limits_{\\sim}∼A​ 模糊集例子 模糊性与随机性 模糊集的表示 加法表示 向量表示 隶属度函数μA∼(x)\\mu_{\\mathop{ A }\\limits_{\\sim}}(x)μ∼A​​(x)表示 隶属函数的确定 模糊集的运算 常规控制 模糊控制 集合 集合的概念 给定论域XXX和给定某一性质PPP，XXX具有性质PPP的元素所组成的总体叫做集合，简称为集。 如果xxx是集合AAA的元素，就是说xxx属于AAA，写成x∈Ax\\in Ax∈A；反之，如果xxx不是集合A的元素，就说xxx不属于AAA，表示x∉Ax \\notin Ax∈/​A。 集合的特征函数表示 对于给定的论域UUU，任意集合A⊆UA\\subseteq UA⊆U，x∈Ux\\in Ux∈U，则有： μA(x)={1,x∈A0,x∉A\\mu_A(x)=\\begin{cases} 1,x \\in A\\\\ 0,x \\notin A\\\\ \\end{cases}μA​(x)={1,x∈A0,x∈/​A​ μA(x)\\mu_A(x)μA​(x)成为集合A的特征函数，可见特征函数的值是一个只能取两个数的集合{0，1}\\{0，1\\}{0，1}。 所以，用函数来刻画某一个集合，那么集合之间的运算可以转化成函数之间的运算。 集合的直积 有两个集合AAA和BBB，从AAA中取一个元素xxx，从BBB中取一个元素yyy，把他们搭配起来组成一个序偶(x,y)(x , y)(x,y)，所有序偶的全体组成一个新的集合，这个集合叫做集合A和集合B的直积A×BA\\times BA×B，表示成： A×B={(x,y)∣x∈A,y∈B}A\\times B = \\{ ( x , y ) \\mid x\\in A, y\\in B \\} A×B={(x,y)∣x∈A,y∈B} 序偶和顺序有关，即(x,y)≠(y,x)(x , y) \\ne (y , x)(x,y)​=(y,x)，所以一般情况下直积A×B≠B×AA\\times B \\ne B\\times AA×B​=B×A 直积也叫乘积、叉积或笛卡尔积，有直积就可以描绘nnn维立方体。 关系矩阵 用矩阵来描述两个集合之间的关系 模糊集 A∼\\mathop{ A }\\limits_{\\sim}∼A​ 定义：给定论域UUU，对于∀x∈U\\forall x\\in U∀x∈U都指定的一个值，将序对（偶）集 A∼=(μA∼(x)∣x),∀x∈U,μA∼(x)∈[0,1]\\mathop{ A }\\limits_{\\sim} = ( \\mu_{\\mathop{ A }\\limits_{\\sim}}(x) \\mid x ) , \\forall x \\in U , \\mu_{\\mathop{ A }\\limits_{\\sim}}(x) \\in [0 , 1] ∼A​=(μ∼A​​(x)∣x),∀x∈U,μ∼A​​(x)∈[0,1] 定义为论域UUU上的一个模糊子集，简称模糊集，∼{\\sim}∼波浪号表示该集合为模糊集。 根据以上定义，模糊集合实质是论域UUU到[0,1][0 , 1][0,1]闭区间的一个映射。 模糊集例子 比如：年轻是20岁以下；中年是四五十岁；老年是七八十岁。 所谓模糊集，就是任何一个元素属于这个集合的程度是需要用一个隶属度函数来刻画的，就是由隶属度函数来描绘这个元素属于这个集合的程度大小 模糊性与随机性 模糊性总是伴随着复杂性而出现 复杂性意味着因素的多样性、关联的多样性 随机性：事件是否发生的因果规律被破坏二造成的一种不确定性 模糊性：事物本身性态和属性的不确定性 从信息观点看：随机性只设计信息的量。模糊性关系到信息的意义、信息的定性问题。 模糊性是一种比随机性更深刻的不确定性。但是用随机、用概率的方式来解决模糊的问题是做不到的。 模糊集的表示 加法表示 也并不是加法，就是一个集合。也叫做乍得表示。 向量表示 用大括号集合表示，但是要表示出0。 隶属度函数μA∼(x)\\mu_{\\mathop{ A }\\limits_{\\sim}}(x)μ∼A​​(x)表示 隶属函数的确定 Fuzzy统计法 μ(xϕ)=lim⁡x→+∞xϕ∈A∗的次数n\\mu(x_{\\phi}) = {\\lim_{x \\to +\\infty}}{\\frac{x_{\\phi} \\in A^*的次数}{n}} μ(xϕ​)=x→+∞lim​nxϕ​∈A∗的次数​ 其中nnn为总得试验次数，只要充分大就可以了，随着nnn的增大，μ(xϕ)\\mu_(x_{\\phi})μ(​xϕ​)就会趋向一个[0,1][0 , 1][0,1]闭区间的数，即隶属度。隶属函数绝不是概率，只是用概率这个解析式来表示。 几种常见的隶属函数形式，一些专家在某些领域研究的隶属度规则 正态形 斜坡形 模糊集的运算 μA∼∪B∼(x)\\bm{ \\mu_{\\mathop{ A }\\limits_{\\sim} \\cup \\mathop{ B }\\limits_{\\sim}}(x)}μ∼A​∪∼B​​(x) = max⁡[μA∼(x),μB∼(x)]\\max[ \\bm{\\mu_{\\mathop{ A }\\limits_{\\sim}}(x)}, \\bm{\\mu_{\\mathop{ B }\\limits_{\\sim}}(x)} ]max[μ∼A​​(x),μ∼B​​(x)] μA∼∩B∼(x)\\bm{ \\mu_{\\mathop{ A }\\limits_{\\sim} \\cap \\mathop{ B }\\limits_{\\sim}}(x)}μ∼A​∩∼B​​(x) = min⁡[μA∼(x),μB∼(x)]\\min[ \\bm{\\mu_{\\mathop{ A }\\limits_{\\sim}}(x)}, \\bm{\\mu_{\\mathop{ B }\\limits_{\\sim}}(x)} ]min[μ∼A​​(x),μ∼B​​(x)] μA‾∼\\bm{ \\mu_{\\mathop{ \\overline{A} }\\limits_{\\sim}}}μ∼A​​ = 1 - μA∼(x)\\bm{\\mu_{\\mathop{ A }\\limits_{\\sim}}}(x)μ∼A​​(x) μB‾∼\\bm{ \\mu_{\\mathop{ \\overline{B} }\\limits_{\\sim}}}μ∼B​​ = 1 - μB∼(x)\\bm{\\mu_{\\mathop{ B }\\limits_{\\sim}}}(x)μ∼B​​(x) 智能处理未来的发展方向？ 普通集合表示法的枚举法和定义法举例？ 什么是直积？ 模糊集和经典集合的区别？ 模糊数学和概率论的区别？ 常规控制 传统控制需要一个精确的数学模型，但是建不起模型，就无法获得最好的控制效果。但是总不能用不精确的数学模型来控制，那样的控制效果就会大打折扣。所以用模糊控制来代替这种不精确的数学模型。 模糊控制 状态变量和控制变量的确定 推理方法的选择 Mamdars Larsen Tsukamolo TSK 数据（知识）库设计 对论域进行划分，根据实际问题、实际情况进行划分，进行归一化。一个数据只能属于相邻，每个论域上相加是1。 规则库设计 从专家那去获得 控制工程理论基础 熟练工人的长期经验 对例子过程的模糊建模 ififif 评价状态变量，thenthenthen控制动作，ififif xxx isisis AAA andandand yyy isisis BBB，thenthenthen zzz === fi(x,...,y)f_i(x,...,y)fi​(x,...,y) 去模糊化 中心化 加权法 测试和调整 调整数据库 调整规则库 尝试不同的推理方法 尝试不同的解模糊化方法 确定查找表 ","link":"https://leichen2552.github.io/post/mo-hu-xin-xi-chu-li-ji-zhu/"},{"title":"转载：通信简史-5G通信为什么快于4G？","content":" 通信的历史 1G到2G 2G到3G 3G到4G 4G到5G 总结 通信的历史 这篇文章是吴军教授在得到APP上的文章，我获益良多。 我也搜集了多方资料，才把通信的前世今生给搞清楚。 在说5G为什么比4G快之前，我想把1G到4G说清楚。 我们先从1G说起。世界上最早的民用移动通信电话是由摩托罗拉公司发明的。 当然了，设备要能通信还需要让他们都遵守一套大家都认可的信息编码规范，这就是通信标准这就如同发电报有标准的电报码一样。没有标准，彼此就没法沟通，是鸡同鸭讲。 通信的标准中有两部分最重要，一个是对信息的发送和接收的描述，比如打电话时大家的电话号码；二是对信息编码的方式，比如文字就是对信息的一种编码。 好的信息编码能保证信息的传输率尽可能高，接近信道的容量。在移动通信的发展过程中，每隔十多年，就会出现新一代的通信标准。当然，谁掌握了标准，谁就掌握了行业的制高点。 1G到2G 在早期的移动通信中，标准是以摩托罗拉为主制定的，我们后来称之为1G。进入到上个世纪80年代，诺基亚等公司就开始研制新一代的移动通信设备，并且提出新的移动通信标准，它们在1991年开始投入使用，为了区分，我们称之为2G。 那么1G和2G有什么区别呢？从技术上讲，1G是模拟电路的，2G是数字电路的。从外观上看，2G的手机比1G小很多，更省电，而且收发短信方便。 为什么2G的手机小？因为数字电路可以把更多的数字芯片集成起来，用一个专用芯片就取代了过去上百个芯片。而在摩尔定律的影响下，这种技术进步的叠加效应更明显，就越做越小。 于是2G取代1G就成为了历史的必然，诺基亚是那个时代的领航者。如果我们沿用《科技史纲60讲》中衡量技术进步的标尺来衡量，从1G到2G，单位能量处理信息的能力提高了百倍。 2G到3G 接下来从2G到3G又发生了什么呢？我们大家可能都知道，2G的手机只能打电话发短信，上网很困难。3G的通信标准将信息的传输率提高了一个数量级，这是一个飞跃，它使得移动互联网得以实现，从此手机打电话的功能降到了次要的位置，而数据通信，也就是上网，成为了主要功能。 但是，从1G到3G都存在一个大问题，那就是上网用的移动通信的网络和原有打电话用的通信网络虽然能够彼此融合，但是却彼此独立。 今天的人回过头来看这件事会觉得有点荒唐，但是如果我们了解了当时移动通信和以AT&amp;T为代表的传统电信公司是多么地水火不容，就不难理解这一点了。 这就使得独立的移动网络就无法受益于网络技术的快速进步。2G和3G时代用手机打一个电话实际上经过的物理路径很长。其中的原理细节，请看下图2G、3G时代移动通信网络的原理示意图。 一方面基站和基站之间的通信效率并不高，使得上网速度快不起来；另一方面，由于在2G时代为了适合当时移动通信的特点，手机端到端的通信要经过好几级的转发。手机信号送到基站后，要经过基带单元（BBU）、无线网络控制器（RNC），才能到核心网，然后再从核心网到RNC、BBU，最后送到基站，基站再与接收者通信。 3G到4G 因此，由于3G的系统是半吊子的，虽然标称的网速很高，但是实际网速并不快。于是4G很快出现了。 4G有什么革命性的进步呢？有人说是网速快。但这是结果，不是原因。4G一方面使用了扁平的网络结构，减少了端到端通信时信息转发的次数，同时增加了基站之间光纤的带宽。 更重要的是，它同时利用了互联网和电信网络的技术进步，这两种技术的融合才使得4G的速度比3G快很多。你可以认为，到了4G，电信的网络已经统一了，但是它和互联网还没有完全统一，你先记住这个事实。 虽然在4G时代从理论上讲移动通信的网速可以变得很快，你今天能够想到的所有应用都是够快的。但是，如果很多人同时上网，它不仅不够快，甚至连不进去。 2018年的杭州开全国计算机大会，参会者近万，在会场上无论是4G还是Wi-Fi都不大管用，你如果拍一张照片想在朋友圈中分享，那么能否分享成功，全靠运气。这一方面是因为总的网速不够快，另一方面是很多人要同时和基站通信，基站成为了瓶颈。 比如一个基站覆盖半径一公里的范围（基站之间的距离通常在2～3公里），通常这方圆一公里范围内的人不会同时上网，因此分给每个上网的人的带宽是够用的，但是当大家都要发照片时，总的传输率超过了信道的总的带宽，根据香农第二定律，出错率是100%，于是大家都传递不了信息了。 公平地讲，4G对于我们目前的上网需求绝大部分时候是足够了，但是在未来我们有很多智能设备，它们也要同时上网，就会出现像前面说的那种“会场拥堵”的问题。 那么怎么解决这个问题呢？有人会想到继续增加带宽。这是一种自然而然，颇为合理的想法。虽然在4G的基础上增加2～3倍的带宽并非难事，但如果想增加1～2个数量级就办不到了。 那一方面要求基站的功率增加很多，这在城市里完全不可行，因为基站周围会因为电磁波辐射太强而变得很不安全。另一方面，要想增加带宽，就要增加通信的频率范围，无线通信的频率无法向下扩展，只能向上扩展，也就是让无线电波的频率增加。 我们知道无线电波的频率越高，它绕过障碍物的能力就越差，比如说它高到可见光的频率时，你随便用张纸，用块布就能挡住它。因此在城市里高楼会严重影响通信。 那么怎么办呢？最简单的办法就是在提高通信频率的同时，把基站建得非常密，这样在你的附近就有基站，它不会被建筑物所阻拦。 4G到5G 基于上述想法，5G的概念就被提出来了。5G是如何进行无线通信的呢？如果我们说4G是一公里的范围建一个基站，负责这方圆一公里范围内的手机和基站的通信，那么5G则是在百米的范围内建基站（今天的方案是基站距离平均在200～300米左右），负责半径为一百多米范围内的通信。 手机和基站的距离缩短，会带来三个好处。 首先是建筑物干扰的问题得到解决，这是显而易见的。 其次是更少的人分享带宽。我们假定方圆一公里范围里的人口是1万人，那么方圆百米范围内就会下降到100人。这样每个人能够分到的带宽就可以增加两个数量级。 最后，由于基站的通信范围可以从1公里减少到100米，功率可以降低两个数量级，这样，在基站周围电磁波辐射也会大大降低，我们生活的环境反而变得安全了。 当5G的基站密集到两三百米甚至不到一百米一个的时候，我们家里是否还需要安装Wi-Fi呢？或许不需要了，Wi-Fi或许会消失，或者会退居次要的地位。这样，就将互联网和通信网络融合成一个网络了，这无疑将是一次通信的革命。 总结 接下来我们总结一下从1G到5G的革命性变化。 1G的诞生。 从1G到2G，是从模拟电路到数字电路，由于采用了专用集成电路，单位能量传输和处理信息的能力提高了两个数量级。 从2G到3G，实现了从语音通信到数据通信的飞跃。 从3G到4G，实现了移动通信网络和传统电信网络的融合，将云计算等互联网技术用于了移动通信，使得不同区域之间的流量能够动态平衡，大大地提高了带宽的使用率。 从4G到5G，可以实现移动互联网和有线的互联网的彻底融合。当然，万物互联才会成为可能。需要指出的是，由于网络基站的密度非常高，每一个基站的功率非常小，因此单位能耗传递信息的效率会进一步大幅度提高。 最后我们看看未来会是什么样子。我们做什么事情是顺应技术发展的趋势，做什么则是逆流而动？ 首先，如果基站的距离缩短到200～300米，单位面积的基站密度比4G就要增加100倍，这是一个巨大的国家级的基础架构建设，因此从事基础架构建设的企业都是受益者。你或许已经听到这样的消息，5G的传闻一出，制造电线杆子企业的股票已经开始疯涨了。 其次，任何致力于将各种网络融合的努力都是顺势而为，任何试图搭建一个独立的，单纯基于无线技术的努力都是逆流而动。几个月前，一些国家决策部门的领导问我，以现在的技术再开发类似于铱星的通信系统，是否可行？我说完全没有必要，因为那是逆流而动。从1G到5G，将各种网络融合是一个大趋势。 再次，由于网速极大地提高，很多需要高速互联网的应用可以开展起来了，包括IoT。 最后，让我们一同来思考一个问题。有了5G，光纤通信是否还需要？答案是，不仅需要，而且还要大幅度提高。 我们不妨从相反的角度思考这个问题，就很容易得到答案。假如没有光纤，只有移动网络，那么基站和基站之间的通讯就不得不用移动网络实现，这就要占据很大的带宽，就会影响我们每一个人和基站的通信。 因此光纤依然是必要的，不仅必要，而且要增加，因为我们和基站通信的速率增加了，又有很多IoT的设备连进来，总的通信量就增加了。从这里我们还可以得出一个结论，从事光纤通讯产业的人，将是5G的获益者。 ","link":"https://leichen2552.github.io/post/zhuan-zai-tong-xin-jian-shi-5g-tong-xin-wei-shi-me-kuai-yu-4g/"},{"title":"回顾（35）：函数对象分析——重载函数调用操作符（( )）","content":" 客户需求 存在的问题 解决方案 函数对象 重载函数调用操作符（( )） 小结 客户需求 函数可以获得斐波那契数列每项的值 每调用一次返回一个值 函数可根据需要重复使用 #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; int fib() { static int a0 = 0; static int a1 = 1;//使用静态局部变量，可以使数据返回时不被摧毁，从而避免使用全局变量 int ret = a1; a1 = a0 + a1; a0 = ret; return ret; } int main(int argc, char *argv[]) { for(int i=0; i&lt;10; i++) { cout &lt;&lt; fib() &lt;&lt; endl; } return 0; } 存在的问题 函数一旦开始就无法重来 静态局部变量处于函数内部，外界无法改变 函数为全局函数，是唯一的，无法多次独立使用 无法指定某个具体的数列项作为初始值 解决方案 函数对象 使用具体的类对象取代函数 该类的对象具备函数调用的行为 构造函数指定具体数列项的起始位置 多个对象相互独立的求解数列项 重载函数调用操作符（( )） 只能通过类的成员函数重载 可以定义不同参数的多个重载函数 #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; class fib { int a0; int a1;//使用静态局部变量，可以使数据返回时不被摧毁，从而避免使用全局变量 public: fib() { a0 = 0; a1 = 1; } fib(int n) { a0 = 0; a1 = 1; for(int i=2; i&lt;=n; i++) { int t=a1; a1 = a0 + a1; a0 = t; } } int operator()() { int ret = a1; a1 = a0 + a1; a0 = ret; return ret; } }; int main(int argc, char *argv[]) { fib a; for(int i=0; i&lt;10; i++) { cout &lt;&lt; a() &lt;&lt; endl; } fib b(10); for(int i=0; i&lt;5; i++) { cout &lt;&lt; b() &lt;&lt; endl; } return 0; } 小结 函数调用操作符（( )）是可以重载的 函数调用操作符智能通过类的成员函数重载 函数调用操作符可以定义不同参数的多个重载函数 函数对象在工程中取代函数指针 ","link":"https://leichen2552.github.io/post/hui-gu-35han-shu-dui-xiang-fen-xi-chong-zai-han-shu-diao-yong-cao-zuo-fu/"},{"title":"智能信息处理概论","content":" 脑与智能 智能定义 智能的概念 所谓的智能ABC 智能的深层定义 信息和知识 人工智能的三个学派 人工智能理论 计算智能的主要研究方法 智能信息的意义与作用 有关智能信息处理的概念 发展过程 智能信息处理的主要技术 脑与智能 智能的核心是思维，思维是大脑活动，怎么来刻画这个思维过程，就来定义什么是智能。 智能定义 在给定的任务或目的下，能根据环境条件能制定正确的策略和角色，并能有效地实现其目的的过程或能力。要有一个目标，而不是泛泛的，能够达到一个准确的决策。但是怎么来细化这个目的是需要研究的。 智能的概念 什么是生物智能（Biological Intelligence - BI）？研究自然生物体的智能 什么是人工智能（Artificial Intelligence - AI）？模拟生物体智能来发展人工的系统，通过这种方式拓宽生物智能 什么是计算智能（Computational Intelligence - CI）？ 所谓的智能ABC Bczdek观点：CI →\\rightarrow→ AI →\\rightarrow→ BI（1992） Jacek M. Zurada的观点：CI不完全包含于AI 智能的深层定义 智能：有效地获取、传递、处理、再生和利用信息，使其任意环境下成功地达到预定目标的能力。对于同样的环境和目标下，具有更强的信息“获取、处理、再生和利用”的能力，就更容易有效的实现目标，从而表现出具有更强的智能水平。 信息和知识 信息：认识主体所感受到的失误状态及其变化的方式 知识：是人类经验的总结和提炼，具有抽象性和普遍性，属于认识论范畴的概念，知识是加工后的信息，是抽象化/广义化的信息。 人工智能的三个学派 符号主义学派：Rule，if A and B 联接主义学派：模拟神经网状结构 行为主义学派：感知→\\rightarrow→行为，控制论 人工智能理论 传统人工智能 现代人工智能 计算智能：以数据为基础，以计算为手段建立功能模型，从而进行问题求解，以实现对智能的模拟和认识 计算智能的主要研究方法 模型 算法 实验 智能信息的意义与作用 意义： 通过模拟人脑的信息处理过程，实现人脑的智能处理能力 提高我们解决实际工程和科学研究问题的能力 极大地提高我们认识自然界奥秘的能力 作用： 通过智能信息处理的研究，可以对我们目前无法解决的难题找到更加有效的高效处理方法和途径 对直接用计算机过程程序无法有效解决的难题，采用智能处理方法将事半功倍 等等 有关智能信息处理的概念 智能信息处理的定义 智能信息处理是利用各种智能手段进行信息变换的过程，这里的智能手段，包括各种人工之能、机器智能和计算智能 分类 基于传统计算机技术的智能信息处理 基于逻辑符号推理实现的智能 包括：智能仪器、自动跟踪系统、自动故障诊断等 基于计算机技术的智能信息处理 基于结构和功能的计算来模拟和实现的智能 包括：模拟人的形象思维、联想记忆 发展过程 伴随着人工智能的技术发展的工程而发展 神经网络研究的兴起 计算智能技术 多种计算方法的综合继承-现在 智能信息处理的主要技术 模糊逻辑技术 神经网络技术 前馈神经网络计算模型 BP网络、RPF网络等 反馈神经网络计算模型 Hopfield网络、回馈网络 自组织网络计算模型 Hebb学习、竞争学习、ART和基于信息论模型等 联想记忆网络模型 单项和双向联想记忆 细胞神经网络模型 小波神经网络 等等 进化演化技术 自然计算技术 粒子群优化 蚁群算法（Ant Colony Algorithm） DNA计算 文化算法 免疫算法 内分泌算法 等等 量子计算技术 混沌计算技术 分形计算技术 专家系统技术 多种智能技术的综合集成 ","link":"https://leichen2552.github.io/post/zhi-neng-xin-xi-chu-li-gai-lun/"},{"title":"回顾（34）：数组操作符的重载","content":" 数组操作符的重载 字符串类的兼容性 重载数组访问操作符 再次升级数组类 IntArray.h IntArray.cpp main.cpp 小结 数组操作符的重载 问题： string类对象还具备C方式字符串的灵活性吗？还能访问单个字符吗？意思就是通过[]访问单个字符 字符串类的兼容性 string类最大限度的考虑了C字符串的兼容性 可以按照使用C字符串的方式使用string对象 #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; int main(int argc, char *argv[]) { string s = &quot;abcdefg1234&quot;; int n = 0; for(int i=0;i&lt;s.length(); i++) { if(isdigit(s[i])) { n++; } } cout &lt;&lt; n &lt;&lt; endl; return 0; } //编译通过，说明string支持这种访问 问题： 类的对象怎么能和数组操作符[]在一起使用呢？ 重载数组访问操作符 被忽略的事实 数组访问操作符是C/C++中内置操作符 数组访问操作符的原生意义是数组访问和指针运算 变换公式 a[n] ←→\\leftarrow \\rightarrow←→ * (a + n)←→\\leftarrow \\rightarrow←→ *(n + a) ←→\\leftarrow \\rightarrow←→ n[a] #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; int main() { int a[5] = {0}; for(int i=0; i&lt;5; i++) { a[i] = i; } for(int i=0; i&lt;5; i++) { cout &lt;&lt; *(a + i) &lt;&lt; endl; // cout &lt;&lt; a[i] &lt;&lt; endl; } cout &lt;&lt; endl; for(int i=0; i&lt;5; i++) { i[a] = i + 10; // a[i] = i + 10; } for(int i=0; i&lt;5; i++) { cout &lt;&lt; *(i + a) &lt;&lt; endl; // cout &lt;&lt; a[i] &lt;&lt; endl; } return 0; } 数组访问操作符（[ ]）：重载一个操作符不能违背它的原生语义 只能通过类的成员函数重载 重载函数能且仅能使用一个参数 可以定义不同参数的多个重载函数 #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; class Test { int a[5]; public: int&amp; operator [] (int i) { return a[i];//通过特殊的技术返回一个函数的返回值，如果真的想返回这个数组里面的值，就该使用引用 } int&amp; operator [] (const string&amp; s) { if(s == &quot;1st&quot;) { return a[0]; } if(s == &quot;2nd&quot;) { return a[1]; } if(s == &quot;3rd&quot;) { return a[2]; } if(s == &quot;4th&quot;) { return a[3]; } if(s == &quot;5th&quot;) { return a[4]; } } int lenrth() { return 5; } }; int main(int argc, char *argv[]) { Test t; for(int i=0; i&lt;t.lenrth(); i++) { t.operator[](i) = i; //在重载函数的返回值不是引用的时候，把一个值赋给函数的返回值，绝对的不合法 t[i] = i; } for(int i=0; i&lt;t.lenrth(); i++) { cout &lt;&lt; t[i] &lt;&lt; endl; } cout &lt;&lt;t[&quot;1st&quot;]&lt;&lt;endl; cout &lt;&lt;t[&quot;2nd&quot;]&lt;&lt;endl; cout &lt;&lt;t[&quot;3rd&quot;]&lt;&lt;endl; cout &lt;&lt;t[&quot;4th&quot;]&lt;&lt;endl; cout &lt;&lt;t[&quot;5th&quot;]&lt;&lt;endl;//通过字符串来访问数组，在c#、D语言中，如果看到这个不要觉得惊奇 return 0; } //测试成功，编译器没有报错 再次升级数组类 IntArray.h #ifndef INTARRAY_H #define INTARRAY_H class IntArray{ private: int m_length; int* m_pointer; IntArray(int len); //IntArray(const IntArray&amp; ob); bool construct(); public: static IntArray* NewInstance(int length); int length(); bool get(int index, int&amp; value); bool set(int index, int value); int&amp; operator [](int index); IntArray&amp; self(); //返回自身，从而减少使用指针 ~IntArray(); }; #endif IntArray.cpp #include &lt;iostream&gt; #include &quot;IntArray.h&quot; IntArray::IntArray(int len) { m_length = len; } bool IntArray::construct() { bool ret = true; m_pointer = new int[m_length]; if(m_pointer) { for(int i = 0;i &lt; m_length; i++) { m_pointer[i] = 0; } } else { ret = false; } return ret; } IntArray* IntArray::NewInstance(int length) { IntArray* ret = new IntArray(length); if( !(ret &amp;&amp; ret-&gt;construct()) ) { delete ret; ret = NULL; } return ret; } int IntArray::length() { return m_length; } bool IntArray::get(int index, int&amp; value) { bool ret = (0 &lt;= index)&amp;&amp;(index &lt; length()); if(ret) { value = m_pointer[index]; } return ret; } bool IntArray::set(int index, int value) { bool ret = (0 &lt;= index)&amp;&amp;(index &lt; length()); if(ret) { m_pointer[index] = value; } return ret; } int&amp; IntArray::operator [](int index) { return m_pointer[index]; } IntArray&amp; IntArray::self() { return *this; } IntArray::~IntArray() { delete[] m_pointer; } main.cpp #include &lt;iostream&gt; #include &quot;IntArray.h&quot; using namespace std; int main(int argc, char *argv[]) { IntArray* a = IntArray::NewInstance(5);//但是即使这样 cout &lt;&lt; &quot;a-&gt;length() = &quot; &lt;&lt; a-&gt;length() &lt;&lt; endl; if(a != NULL)//在堆空间中创建的对象，我们给他娶个别名 { IntArray&amp; array = a-&gt;self(); array[0] = 1; for(int i=0; i&lt;array.length(); i++) { cout &lt;&lt; &quot;array[&quot;&lt;&lt; i &lt;&lt;&quot;] = &quot; &lt;&lt; array[i] &lt;&lt; endl; } //再次总结对于这句IntArray* a = IntArray::NewInstance(5); //但是即使这样，还是出现了指针，在后面会有智能指针的技术来改善 } /* (*a)[0] = 1;//但是这样子访问看着很别扭，在C++开发中，尽可能的不使用指针*，所以我们再提供一个self()成员函数来返回自身 for(int i=0; i&lt;a-&gt;length(); i++) { cout &lt;&lt; &quot;a[&quot;&lt;&lt; i &lt;&lt;&quot;] = &quot; &lt;&lt; (*a)[i] &lt;&lt; endl; }*/ delete a; return 0; } 小结 string类最大程度的兼容了C字符串的用法 数组访问福的重载能够使得对象模拟数组的行为 只能通过类的成员函数重载数组访问符 重载函数能且仅能使用一个参数 ","link":"https://leichen2552.github.io/post/hui-gu-34shu-zu-cao-zuo-fu-de-chong-zai/"},{"title":"回顾（33）：C++中的字符串类","content":" 历史遗留问题 解决方案 标准库中的字符串类 字符串基本操作 字符串与数字的转换 面试题分析 小结 字符串反转 历史遗留问题 C语言不支持真正意义上的字符串 C语言用字符数组和一组函数实现字符串操作 C语言不支持自定义类型，因此无法获得字符串类型 解决方案 从C到C++的进化引入了自定义类型 在C++中可以通过类完成字符串类型的定义 问题： C++中的原生类型系统是否包含字符串类型？ 标准库中的字符串类 字符串基本操作 C++语言直接支持C语言的所有概念 因为C++自诞生以来的沉重使命就是兼容C语言，所以C++语言中没有原生的字符串类型 C++标准库提供了string类型 string直接支持字符串连接 string直接支持字符串比较大小 string直接支持字符串查找和提取 string直接支持字符串的插入和替换 #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; void string_sort(string a[], int len) { for(int i=0; i&lt;len; i++) { for(int j=i; j&lt;len; j++) { if(a[i] &gt; a[j])//标准库里重载了 &gt; 这个操作符 { swap(a[i], a[j]); } } } } string string_add(string a[], int len) { string ret = &quot;&quot;; for(int i=0; i&lt;len; i++) { ret = ret + a[i] + &quot;;&quot;;//标准库里重载了 + 这个操作符 } return ret; } int main(int argc, char *argv[]) { string sa[7] = { &quot;Hello World&quot;, &quot;D.T.Software&quot;, &quot;C#&quot;, &quot;Java&quot;, &quot;C++&quot;, &quot;Python&quot;, &quot;TypeScript&quot; }; string_sort(sa,7); for(int i=0; i&lt;7; i++) { cout &lt;&lt; sa[i] &lt;&lt; endl; } cout &lt;&lt; endl; cout &lt;&lt; string_add(sa, 7) &lt;&lt; endl; return 0; } 打印结果： C# C++ D.T.Software Hello World Java Python TypeScript C#;C++;D.T.Software;Hello World;Java;Python;TypeScript; 字符串与数字的转换 标准库中提供了相关的类对字符串和数字进行转换 字符串流泪（sstream）用于string的转换 &lt;sstream&gt; - 相关头文件 istringstream- 字符串输入流 ostringstream - 字符串输出流 使用方法 string →\\rightarrow→ 数字istringstream iss(&quot;123.45&quot;); double num; iss &gt;&gt; num; 数字 →\\rightarrow→ stringostringstream oss; oss &lt;&lt;543.21; string s = oss.str(); #include &lt;iostream&gt; #include &lt;sstream&gt; #include &lt;string&gt; using namespace std; //采用直接调用构造函数的方法形成临时对象，生命周期只有这一行语句的时间 #define TO_NUMBER(s, n) (istringstream(s) &gt;&gt; n) //这一行里的(ostringstream&amp;)强制类型转换， //如果没有的话，编译器会报错，因为如果没有的话，返回的就不是一个ostringstream类型 #define TO_STRING(n) (((ostringstream&amp;)(ostringstream() &lt;&lt; n)).str()) //函数模板支持多种类型 template &lt;typename T&gt; string to_string(T n) { ostringstream oss; oss &lt;&lt; n; return oss.str(); } //函数模板支持多种类型 template &lt;typename T&gt; bool to_number(const string&amp; s, T&amp; n) { istringstream iss(s); return iss &gt;&gt; n; } int main(int argc, char *argv[]) { //采用函数模板 /***************************************************/ double m = 0; if(TO_NUMBER(&quot;123.789&quot;, m)) { cout &lt;&lt; &quot;m = &quot;&lt;&lt; m &lt;&lt;endl; } cout &lt;&lt; endl; /***************************************************/ //采用函数模板 /***************************************************/ int n = 0; cout &lt;&lt; &quot;to_number&lt;int&gt;(&quot; &lt;&lt; &quot;123456,n) = &quot; &lt;&lt; to_number&lt;int&gt;(&quot;123456&quot;,n) &lt;&lt; endl; cout &lt;&lt; &quot;n = &quot; &lt;&lt; n &lt;&lt; endl; cout &lt;&lt; endl; float f = 0; cout &lt;&lt; &quot;to_number&lt;float&gt;(&quot; &lt;&lt; &quot;123.456,f) =&quot; &lt;&lt; to_number&lt;float&gt;(&quot;123.456&quot;,f) &lt;&lt; endl; cout &lt;&lt; &quot;f = &quot; &lt;&lt; f &lt;&lt; endl; cout &lt;&lt; endl; double d = 0; cout &lt;&lt; &quot;to_number&lt;double&gt;(&quot; &lt;&lt; &quot;123.4789,d)&quot;&lt;&lt; to_number&lt;double&gt;(&quot;123.4789&quot;,d) &lt;&lt; endl; cout &lt;&lt; &quot;d = &quot; &lt;&lt; d &lt;&lt; endl; cout &lt;&lt; endl; /***************************************************/ string s1 = TO_STRING(12345); string s2 = to_string(12345); cout &lt;&lt; &quot;s1 = &quot; &lt;&lt; s1 &lt;&lt; endl; cout &lt;&lt; &quot;s2 = &quot; &lt;&lt; s2 &lt;&lt; endl; return 0; } 打印结果： m = 123.789 to_number&lt;int&gt;(123456,n) = 1 n = 123456 to_number&lt;float&gt;(123.456,f) =1 f = 123.456 to_number&lt;double&gt;(123.4789,d)1 d = 123.479 s1 = 12345 s2 = 12345 面试题分析 abcdefg →\\rightarrow→ efgabcd，需要循环右移三位 #include &lt;iostream&gt; #include &lt;sstream&gt; #include &lt;string&gt; using namespace std; string operator &gt;&gt; (const string&amp; s, unsigned int n) { string ret; unsigned int pos = 0; //abc ==&gt; 1 cab //abc ==&gt; 4 cab n = n % s.length();//先取余 pos = s.length() - n;//再取位置 ret = s.substr(pos);//提取位置之后的字串 ret = ret + s.substr(0,pos);//再把ret加上从0到pos的字串 //abcdefg ==&gt; 8 //sbcdefg ==&gt; 1 //8 % 7 == &gt; 1 //7-1 = 6 //abcdef g //ret ==&gt; g //ret = g + abcdef //ret = gabcdef return ret; } int main(int argc, char *argv[]) { string r = &quot;abcdefg&quot;; string s = r &gt;&gt; 3; cout &lt;&lt; s &lt;&lt; endl; return 0; } 打印结果： r = abcdefg s = efgabcd 小结 应用开发中大多数的情况都在进行字符串处理 C++中没有直接支持原生的字符串类型 标准库中通过 string 类支持字符串的概念 string类支持字符串和数字的相互转换 string类的应用使得问题的求解变得简单 字符串反转 要求： 使用string类完成 示例： &quot;we;tonight;you&quot; →\\rightarrow→ &quot;ew;thginot;uoy&quot; 提示： string类中提供了成员函数可以查找目标字符的位置 ","link":"https://leichen2552.github.io/post/hui-gu-33czhong-de-zi-fu-chuan-lei/"},{"title":"回顾（32）：初探C++标准库","content":"有趣的重载 操作符&lt;&lt;的原生意义是按位左移，例如：1 &lt;&lt; 2 意义是把 1 按位左移 2 位 0001 &lt;&lt; 2 --&gt; 0100 重载左移操作符，将变量或者常量左移到一个对象中 #include &lt;stdio.h&gt; class Console { public : void operator &lt;&lt; (int i) { printf(&quot;%d&quot;,i); } void operator &lt;&lt; (char c) { printf(&quot;%c&quot;,c); } }; Console cout; int main(int argc, char *argv[]) { cout &lt;&lt; 1; cout &lt;&lt; '\\n'; //cout &lt;&lt; 1 &lt;&lt; '\\n';//像这样连续左移就不支持，所以采用这样 return 0; } 采用返回当前对象的方式支持连续左移 #include &lt;stdio.h&gt; class Console { public : Console&amp; operator &lt;&lt; (int i) { printf(&quot;%d&quot;,i); return *this; } Console&amp; operator &lt;&lt; (char c) { printf(&quot;%c&quot;,c); return *this; } }; Console cout; int main(int argc, char *argv[]) { cout &lt;&lt; 1 &lt;&lt; '\\n'; return 0; } 但是生平最讨厌输入换行符'\\n'，加入const char endl = '\\n' #include &lt;stdio.h&gt; const char endl = '\\n'; class Console { public : Console&amp; operator &lt;&lt; (int i) { printf(&quot;%d&quot;,i); return *this; } Console&amp; operator &lt;&lt; (char c) { printf(&quot;%c&quot;,c); return *this; } Console&amp; operator &lt;&lt; (const char* s) { printf(&quot;%s&quot;,s); return *this; } Console&amp; operator &lt;&lt; (double d) { printf(&quot;%f&quot;,d); return *this; } }; Console cout; int main(int argc, char *argv[]) { double a = 0.777; cout &lt;&lt; 1 &lt;&lt; endl; cout &lt;&lt; &quot;112233, &quot; &lt;&lt; a &lt;&lt;endl; return 0; } 但是重复造轮子并不是一件有创造性的事， 站在巨人的肩膀上解决问题会更加有效！ c++标准库 C++标准库不是C++语言的一部分，是那些做编译器的厂商在开发编译器的时候添加的，就是你做编译器，就要提供标准库 C++标准库是由类库和函数库组成的集合 C++标准库中定义的类和对象都位于std命名空间中 C++标准库的头文件都不带.h后缀，这是因为C++自诞生以来就背负的沉重使命就是兼容C语言 C++标准库涵盖了C库的功能 C++编译环境组成 C++标准库预定义了多数常用的数据结构 #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;cstdlib&gt; #include &lt;cmath&gt; //使用的是标准库，所以要打开这个命名空间 using namespace std; int main(int argc, char *argv[]) { printf(&quot;Hello world&quot;); char* p = (char*)malloc(16); strcpy(p, &quot;I love you&quot;); free(p); return 0; } 使用cout和cin #include &lt;iostream&gt; #include &lt;cmath&gt; //使用的是标准库，所以要打开这个命名空间 using namespace std; int main(int argc, char *argv[]) { cout &lt;&lt; &quot;Hello world！&quot; &lt;&lt;endl; double a = 0; double b = 0; cout &lt;&lt; &quot;Input a: &quot;; cin &gt;&gt; a; cout &lt;&lt; &quot;Input b: &quot;; cin &gt;&gt; b; double c = sqrt(a*a + b*b); cout &lt;&lt; &quot;c = &quot; &lt;&lt; c &lt;&lt; endl; return 0; } 打印结果： Hello world! Input a: 3 Input a: 4 c = 5 小结 C++标准库是由类库和函数库组成的集合 C++标准库包含经典算法和数据结构的实现 C++标准库涵盖了C库的功能 C++标准库中的所有类库和函数都位于std这个命名空间当中 ","link":"https://leichen2552.github.io/post/hui-gu-32chu-tan-cbiao-zhun-ku/"},{"title":"回顾（31）：完善的复数类","content":" 完善的复数类 完善的复数类代码 Complex.h Complex.cpp main.cpp 注意事项 小结 完善的复数类 复试地位在数学里是很高的 复数类应该具有的操作 运算：+，-，*，/ 比较：== != 赋值：= 求模：modulus 利用操作符重载 统一复数与实数的运算方式 统一于实数的比较方式 Complex operator + (const Cpmplex&amp; c); Complex operator - (const Cpmplex&amp; c); Complex operator * (const Cpmplex&amp; c); Complex operator / (const Cpmplex&amp; c); bool operator == (const Cpmplex&amp; c); bool operator != (const Cpmplex&amp; c); Complex&amp; operator = (const Cpmplex&amp; c); 完善的复数类代码 Complex.h #ifndef _COMPLEX_H_ #define _COMPLEX_H_ class Complex { private: double a; double b; public: Complex(double a = 0, double b = 0);//函数声明时确定默认值，在cpp文件中实现时就不 //需要声明默认值 double getA(); double getB(); double getModulus(); Complex operator + (const Complex&amp; p); Complex operator - (const Complex&amp; p); Complex operator * (const Complex&amp; p); Complex operator / (const Complex&amp; p); bool operator == (const Complex&amp; p); bool operator != (const Complex&amp; p); Complex&amp; operator = (const Complex&amp; p); }; #endif Complex.cpp #include &quot;Complex.h&quot; #include &quot;math.h&quot; Complex::Complex(double a, double b)//在声明时声明默认值，实现这个函数时就不需要了 { this-&gt;a = a; this-&gt;b = b; } double Complex::getA() { return a; } double Complex::getB() { return b; } double Complex::getModulus() { return sqrt(a*a + b*b); } Complex Complex::operator + (const Complex&amp; p) { double na = this-&gt;a + p.a; double nb = this-&gt;b + p.b; Complex ret(na, nb); return ret; } Complex Complex::operator - (const Complex&amp; p) { double na = this-&gt;a - p.a; double nb = this-&gt;b - p.b; Complex ret(na, nb); return ret; } Complex Complex::operator * (const Complex&amp; p) { double na = this-&gt;a * p.a - this-&gt;b * p.b; double nb = this-&gt;a * p.b + this-&gt;b * p.a; Complex ret(na, nb); return ret; } Complex Complex::operator / (const Complex&amp; p) { double cm = p.a * p.a + p.b * p.b; double na = (this-&gt;a * p.a + this-&gt;b * p.b) / cm; double nb = (this-&gt;b * p.a - this-&gt;a * p.b) / cm; Complex ret(na, nb); return ret; } bool Complex::operator == (const Complex&amp; p) { return ((this-&gt;a == p.a) &amp;&amp; (this-&gt;b == p.b)); } bool Complex::operator != (const Complex&amp; p) { //这个实现方法非常巧妙，只需要他们相等的对立面 return !(*this == p); } Complex&amp; Complex::operator = (const Complex&amp; p) { if(this != &amp;p) { this-&gt;a = p.a; this-&gt;b = p.b; } return *this; } main.cpp #include &lt;iostream&gt; #include &lt;string&gt; #include &quot;Complex.h&quot; using namespace std; int main(int argc, char *argv[]) { Complex c1(1,2); Complex c2(3,6); Complex c3 = c2 - c1; cout &lt;&lt; &quot;c3 = &quot; &lt;&lt; &quot;(&quot; &lt;&lt; c3.getA() &lt;&lt; &quot;, &quot; &lt;&lt; c3.getB() &lt;&lt; &quot;)&quot; &lt;&lt;endl; Complex c4 = c1 * c3; cout &lt;&lt; &quot;c4 = &quot; &lt;&lt; &quot;(&quot; &lt;&lt; c4.getA() &lt;&lt; &quot;, &quot; &lt;&lt; c4.getB() &lt;&lt; &quot;)&quot; &lt;&lt;endl; Complex c5 = c2 / c1; cout &lt;&lt; &quot;c5 = &quot; &lt;&lt; &quot;(&quot; &lt;&lt; c5.getA() &lt;&lt; &quot;, &quot; &lt;&lt; c5.getB() &lt;&lt; &quot;)&quot; &lt;&lt;endl; Complex c6(2,4); cout &lt;&lt; &quot;c3 == c6 : &quot; &lt;&lt; (c3 == c6) &lt;&lt; endl;//这个(c3 == c6)是一定要加括号， //因为 &lt;&lt; 比 == 优先级高，但是复数类中又没有重载&lt;&lt;操作符，所以会报错 cout &lt;&lt; &quot;c3 == c4 : &quot; &lt;&lt; (c3 != c4) &lt;&lt; endl; (c3 = c2) = c1; cout &lt;&lt; &quot;c1 = &quot; &lt;&lt; &quot;(&quot; &lt;&lt; c1.getA() &lt;&lt; &quot;, &quot; &lt;&lt; c1.getB() &lt;&lt; &quot;)&quot; &lt;&lt;endl; cout &lt;&lt; &quot;c2 = &quot; &lt;&lt; &quot;(&quot; &lt;&lt; c2.getA() &lt;&lt; &quot;, &quot; &lt;&lt; c2.getB() &lt;&lt; &quot;)&quot; &lt;&lt;endl; cout &lt;&lt; &quot;c3 = &quot; &lt;&lt; &quot;(&quot; &lt;&lt; c3.getA() &lt;&lt; &quot;, &quot; &lt;&lt; c3.getB() &lt;&lt; &quot;)&quot; &lt;&lt;endl; return 0; } 注意事项 C++规定赋值操作符（=）只能重载为成员函数 操作符重载不能改变原操作符的优先级 操作符重载不能改变操作数的个数 操作符重载不能改变操作符的原有语义 小结 复数的概念可以通过自定义类实现 复数中的运算操作可以通过操作符重载实现 赋值操作符只能通过成员函数实现，是不能通过全局函数的 操作符重载的本质为函数定义 ","link":"https://leichen2552.github.io/post/hui-gu-31wan-shan-de-fu-shu-lei/"},{"title":"小插曲之“康斯特引用（const&）”","content":" 先来回顾下之前最后修改的复数类代码 #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; class Complex { private: int a; int b; public: Complex(int a = 0, int b = 0) { this-&gt;a = a; this-&gt;b = b; } int getA() { return a; } int getB() { return b; } Complex operator +(const Complex&amp; p)/********************/ { cout &lt;&lt; &quot;Complex operator +(Complex&amp; p2)&quot; &lt;&lt; endl; Complex ret; ret.a = this-&gt;a + p.a; ret.b = this-&gt;b + p.b; return ret; } friend Complex operator +(const Complex&amp; p1,const Complex&amp; p2); } ; Complex operator +(const Complex&amp; p1, const Complex&amp; p2)/********************/ { cout &lt;&lt; &quot;friend Complex operator +(Complex p1, Complex p2);&quot; &lt;&lt;endl; Complex ret; ret.a = p1.a + p2.a; ret.b = p1.b + p2.b; return ret; } int main(int argc, char *argv[]) { Complex c1(1,2); Complex c2(3,4); Complex c3 = c1 + c2;//编译器能自己选择用哪个函数 cout &lt;&lt; &quot;c3 = &quot; &lt;&lt; &quot;(&quot; &lt;&lt; c3.getA() &lt;&lt; &quot;,&quot; &lt;&lt; c3.getB() &lt;&lt; &quot;)&quot; &lt;&lt; endl; return 0; } 关注我在代码后面加了/********************/这个标记的，拿出来看下，就是这两行 Complex operator +(const Complex&amp; p) Complex operator +(const Complex&amp; p1, const Complex&amp; p2) 把这两行代码里的const去掉，像这样带回源代码，发现编译器就会报错 Complex operator +(Complex&amp; p) Complex operator +(Complex&amp; p1, Complex&amp; p2) //带回源代码 #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; class Complex { private: int a; int b; public: Complex(int a = 0, int b = 0) { this-&gt;a = a; this-&gt;b = b; } int getA() { return a; } int getB() { return b; } /* Complex operator +(const Complex&amp; p) { cout &lt;&lt; &quot;Complex operator +(Complex&amp; p2)&quot; &lt;&lt; endl; Complex ret; ret.a = this-&gt;a + p.a; ret.b = this-&gt;b + p.b; return ret; }*/ Complex operator +(Complex&amp; p) { cout &lt;&lt; &quot;Complex operator +(Complex&amp; p2)&quot; &lt;&lt; endl; Complex ret; ret.a = this-&gt;a + p.a; ret.b = this-&gt;b + p.b; return ret; } //friend Complex operator +(const Complex&amp; p1,const Complex&amp; p2); friend Complex operator +(Complex&amp; p1, Complex&amp; p2); } ; /* Complex operator +(const Complex&amp; p1, const Complex&amp; p2) { cout &lt;&lt; &quot;friend Complex operator +(Complex p1, Complex p2);&quot; &lt;&lt;endl; Complex ret; ret.a = p1.a + p2.a; ret.b = p1.b + p2.b; return ret; }*/ Complex operator +(Complex&amp; p1, Complex&amp; p2) { cout &lt;&lt; &quot;friend Complex operator +(Complex p1, Complex p2);&quot; &lt;&lt;endl; Complex ret; ret.a = p1.a + p2.a; ret.b = p1.b + p2.b; return ret; } int main(int argc, char *argv[]) { Complex c0; Complex c1(1,2); Complex c2(3,4); Complex c3 = c1 + c2; cout &lt;&lt; &quot;c3 = &quot; &lt;&lt; &quot;(&quot; &lt;&lt; c3.getA() &lt;&lt; &quot;,&quot; &lt;&lt; c3.getB() &lt;&lt; &quot;)&quot; &lt;&lt; endl; return 0; } //错误信息 //[Error] ..\\main.cpp:81: error: ambiguous overload for 'operator+' in 'c1 + c2' //[Warning] ..\\main.cpp:37: note: candidates are: Complex Complex::operator+(Complex&amp;) //[Warning] ..\\main.cpp:65: note: Complex operator+(Complex&amp;, Complex&amp;) 我在Linux平台下用g++编译器尝试，还是报一样的错误！ 这个问题我还没解决，去群里问了老师，他也没给出合理的解释！ 在我学C++的时候，有人说C++这门语言，连C++之父都没完全弄懂，我一开始不这样觉得，现在我懂了 ","link":"https://leichen2552.github.io/post/xiao-cha-qu-zhi-kang-si-te-yin-yong-constand/"},{"title":"回顾（30）：操作符重载的概念","content":" 复数的问题 思考 操作符重载 复数类代码修改 复数类再次修改 小结 复数的问题 上节课复数的类问题，重载最重要的意义之一就是可以拓展系统当中的功能 但是面对这个复数的加法，编译器肯定不知道怎么办，所以结合前面的友元等一些知识，利用函数显示加法来实现这一功能 #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; class Complex { private: int a; int b; public: Complex() { a = 0; b = 0; } Complex(int a, int b) { this-&gt;a = a; this-&gt;b = b; } int getA() { return a; } int getB() { return b; } friend Complex add(const Complex&amp; p1, const Complex&amp; p2); } ; Complex add(Complex p1, Complex p2) { Complex ret; ret.a = p1.a + p2.a; ret.b = p1.a + p2.b; return ret; } int main(int argc, char *argv[]) { Complex c1(1,2); Complex c2(3,4); Complex c3 = add(c1,c2); cout &lt;&lt; &quot;c3 = &quot; &lt;&lt; &quot;(&quot; &lt;&lt; c3.getA() &lt;&lt; &quot;,&quot; &lt;&lt; c3.getB() &lt;&lt; &quot;)&quot; &lt;&lt; endl; return 0; } 这个确实实现了这个功能，但是c3 = add(c1,c2)这种表现形式不好看，而且利用友元也大大破坏了类的封装性。所以总的来看，这样的解决方案也不是最好的解决方案。 思考 Add函数可以解决Complex对象相加的问题，但是Complex是现实世界中确实存在的复数，并且复数在数学中地位和普通的实数相同，那有没有办法让 + 这个操作符也支持复数相加呢？ 操作符重载 C++中能重载操作符的功能 操作符重载以函数的方式进行 本质： 用特殊形式的函数扩展操作符的功能，意思就是写一个函数，这个函数认为是＋操作符进行的动作 通过operator关键字可以定义特殊的函数 operator的本质是通过函数重载操作符 语法： Type operator Sign(const Type p1, const Type p2) { Type ret; return ret; } Sign为系统中预定义的操作符，如：+，-，*，/，等 复数类代码修改 friend Complex add(const Complex&amp; p1, const Complex&amp; p2); //改成 friend Complex operator +(Complex p1, Complex p2); Complex add(Complex p1, Complex p2) //改成 Complex operator +(Complex p1, Complex p2); Complex c3 = add(c1,c2); //先修改成 Complex c3 = operator +(c1,c2); //再修改成 Complex c3 = c1 + c2;//改成这样就十分完美了，就相当于编译器知道这是复数类相加了 但是这种解决方案依然使用了友元 复数类再次修改 使用类成员函数来代替全局函数，既保持了类的封装性，又不使用友元 #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; class Complex { private: int a; int b; public: Complex(int a = 0, int b = 0) { this-&gt;a = a; this-&gt;b = b; } int getA() { return a; } int getB() { return b; } Complex operator +(const Complex&amp; p) { cout &lt;&lt; &quot;Complex operator +(Complex&amp; p2)&quot; &lt;&lt; endl; Complex ret; ret.a = this-&gt;a + p.a; ret.b = this-&gt;b + p.b; return ret; } friend Complex operator +(const Complex&amp; p1,const Complex&amp; p2); } ; Complex operator +(const Complex&amp; p1, const Complex&amp; p2) { cout &lt;&lt; &quot;friend Complex operator +(Complex p1, Complex p2);&quot; &lt;&lt;endl; Complex ret; ret.a = p1.a + p2.a; ret.b = p1.b + p2.b; return ret; } int main(int argc, char *argv[]) { Complex c1(1,2); Complex c2(3,4); Complex c3 = c1 + c2;//编译器能自己选择用哪个函数 cout &lt;&lt; &quot;c3 = &quot; &lt;&lt; &quot;(&quot; &lt;&lt; c3.getA() &lt;&lt; &quot;,&quot; &lt;&lt; c3.getB() &lt;&lt; &quot;)&quot; &lt;&lt; endl; return 0; } 这部分代码在从编译器上复制到这篇博客上时，发生了一些小插曲，小插曲在下篇博客里面写。 小结 操作符重载是C++的最强大的特性之一 操作符重载的本质是通过函数拓展操作符的功能 operator关键字是实现操作符重载的关键，用operator实现特殊的函数 操作符重载遵循相同的函数重载规则 全局函数和成员函数都可以实现对操作符的重载 ","link":"https://leichen2552.github.io/post/hui-gu-30cao-zuo-fu-chong-zai-de-gai-nian/"},{"title":"回顾（29）：类中的函数重载","content":" 函数重载回顾 类中的成员函数可以进行重载 实验测试 深度的意义 实例演示 思考 复数类解决方案 小结 函数重载回顾 函数重载的本质为互相独立的不同函数 C++中通过函数名和函数参数确定函数调用 无法直接通过函数名得到重载函数的入口地址 函数重载必然发生在同一个作用域中 类中的成员函数可以进行重载 构造函数的重载 普通成员函数的重载 静态成员函数的重载 问题： 全局函数、普通成员函数以及静态成员函数之间是否可以构成重载？ 实验测试 #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; void func() { cout &lt;&lt; &quot;std::func()&quot; &lt;&lt; endl; } void func(int i) { cout &lt;&lt; &quot;std::func(),i = &quot; &lt;&lt; i &lt;&lt; endl; } class Test { private: int i; public: Test() { cout &lt;&lt; &quot;Test::Test()&quot; &lt;&lt; endl; } Test(int v) { this-&gt;i = v; cout &lt;&lt; &quot;Test::Test(int v),i = &quot; &lt;&lt; i &lt;&lt;endl; } Test(const Test&amp; obj) { this-&gt;i = obj.i; cout &lt;&lt; &quot;Test::Test(const int&amp; obj),i = &quot; &lt;&lt; i &lt;&lt; endl; } static void func() { cout &lt;&lt; &quot;Test::static void func()&quot; &lt;&lt; endl; } void func(int i) { cout &lt;&lt; &quot;Test::func(),i = &quot; &lt;&lt; i &lt;&lt; endl; } }; int main(int argc, char *argv[]) { func(); func(2); cout &lt;&lt; endl; Test t1; Test t2(2); Test t3(t1); cout &lt;&lt; endl; Test::func(); t1.func(); t1.func(3); return 0; } 打印结果： std::func() std::func(),i = 2 Test::Test() Test::Test(int v),i = 2 Test::Test(const int&amp; obj),i = 1998216124 Test::static void func() Test::static void func() Test::func(),i = 3 请按任意键继续. . . 万变不离其宗 重载函数的本质为多个不同的函数 函数名和参数列表是唯一的标识 函数重载必须发生在同一作用域中 静态成员函数和普通成员函数之间可以构成重载 全局函数和类的成员函数不能构成重载，因为命名空间不一样 深度的意义 重载的意义：就是通过函数名大概推出函数的功能，通过函数名提示开发者这个函数时干什么用的，通过参数列表告诉开发者这个函数该怎么使用 通过函数名对函数功能进行提示 通过参数列表对函数用法进行提示 扩展系统中已经存在的函数功能，本质上虽然是提供新的函数，但是从更高层次来说，还是扩展了函数功能 实例演示 实现字符串拷贝的功能 #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; int main(int argc, char *argv[]) { const char* s = &quot;D.T.Software&quot;; char buf[16] = {0}; strcpy(buf, s); cout &lt;&lt; buf &lt;&lt; endl; return 0; } 但是，如果把buf[16]换成buf[4]，像这样： #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; int main(int argc, char *argv[]) { const char* s = &quot;D.T.Software&quot;; char buf[4] = {0}; strcpy(buf, s); cout &lt;&lt; buf &lt;&lt; endl; return 0; } 运行结果就会出错，在Linux平台下肯定会出内存错误 所以，我们换一个函数strncpy #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; int main(int argc, char *argv[]) { const char* s = &quot;D.T.Software&quot;; char buf[4] = {0}; strncpy(buf, s, sizeof(buf)-1); cout &lt;&lt; buf &lt;&lt; endl; return 0; } 这样就只会复制&quot;D.T&quot;这三个字符 如果我们用上了重载，就扩展系统中已经存在的函数功能 #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; char* strcpy(char* buf, const char* str, unsigned int n) { return strncpy(buf, str, n); } int main(int argc, char *argv[]) { const char* s = &quot;D.T.Software&quot;; char buf[4] = {0}; strcpy(buf, s, sizeof(buf)-1);//对于开发者而言，调用的还是同一个函数 cout &lt;&lt; buf &lt;&lt; endl; return 0; } 思考 重载能够扩展系统中已经存在的函数功能！ 那么重载是否也能够扩展其他更多的功能？ 复数类解决方案 但是复数的相加减，C++的编译器是做不到的，这个下次再说 小结 类的成员函数之间可以进行重载 重载必须发生在同一作用域当中 全局函数和成员函数不能构成重载关系 重载的意义在于扩展已经存在的功能 ","link":"https://leichen2552.github.io/post/hui-gu-29lei-zhong-de-han-shu-chong-zai/"},{"title":"回顾（28）：友元的尴尬能力","content":" 友元的概念 友元的用法 友元的尴尬 注意事项 小结 友元的概念 什么是友元 友元是C++中的一种关系 友元关系发生在函数与类之间或者类与类之间 友元关系是单项的，不能传递 友元的用法 在类中以friend关键字声明友元 类的友元可以是其他类或者是具体函数 友元不是类的一部分 友元不受类中访问级别的限制 友元可以直接访问具体类的所有成员 在类中用friend关键字对函数或类进行声明 #include &lt;iostream&gt; #include &lt;math.h&gt; #include &lt;string&gt; using namespace std; class Point{ private: double x; double y; public: Point(double x, double y) { this-&gt;x = x; this-&gt;y = y; } double getX() { return x; } double getY() { return y; } friend double func(Point&amp; p1, Point&amp; p2); //体验了一下，main()函数也可以当做friend friend int main(int argc, char *argv[]); }; double func(Point&amp; p1, Point&amp; p2) { double ret = 0; //在C++初期，程序员都用C语言写代码，大家特别希望能够像p1.x一样调用， //而不是像这样调用八次函数，效率降低。早期的程序员看到C++这样，所以就不用了。 //并且C++自诞生就背负着一个重要的责任就是兼容C语言，所以就出现了friend关键字。 // ret = (p1.getX() - p2.getX())*(p1.getX() - p2.getX()) + // (p1.getY() - p2.getY())*(p1.getY() - p2.getY()); //有了friend关键字，就可以了无限制的访问类的私有成员 ret = (p1.x - p2.x)*(p1.x - p2.x) + (p1.y - p2.y)*(p1.y - p2.y); ret = sqrt(ret); return ret; } int main(int argc, char *argv[]) { Point p1(1,2); Point p2(10,20); //检测main()函数被friend cout &lt;&lt; &quot;p1(x,y) = &quot;&lt;&lt; &quot;(&quot; &lt;&lt; p1.x&lt;&lt; &quot;,&quot;&lt;&lt; p1.y &lt;&lt;&quot;)&quot;&lt;&lt; endl; cout &lt;&lt; &quot;p1(x,y) = &quot;&lt;&lt; &quot;(&quot; &lt;&lt; p1.getX()&lt;&lt; &quot;,&quot;&lt;&lt; p1.getY() &lt;&lt;&quot;)&quot;&lt;&lt; endl; cout &lt;&lt; &quot;p2(x,y) = &quot;&lt;&lt; &quot;(&quot; &lt;&lt; p2.getX()&lt;&lt; &quot;,&quot;&lt;&lt; p2.getY() &lt;&lt;&quot;)&quot;&lt;&lt; endl; cout &lt;&lt; &quot;|(p1, p2)| = &quot; &lt;&lt; func(p1,p2) &lt;&lt; endl; return 0; } 友元的尴尬 友元是为了兼顾C语言的高效而诞生的 友元的超能力直接破坏了面向对象的封装性 友元在实际产品中的高效是得不偿失的 友元在现在软件工程中已经逐渐被遗弃 注意事项 友元关系不具备传递性 类的友元可以是其他类的成员函数 类的友元可以是某个完整的类 所有的成员函数都是友元 #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; class classC { private: const char* n; public : classC(const char* n) { this-&gt;n = n; } friend class classB;//B是C的友元，那么B就可以访问C的私有成员 }; class classB { private: const char* n; public : classB(const char* n) { this-&gt;n = n; } void getClassCName(classC&amp; c) { cout &lt;&lt; &quot;classC : &quot; &lt;&lt; c.n &lt;&lt; endl; } friend class classA;//A是B的友元，那么A就可以访问B的私有成员 }; class classA { private: const char* n; public : classA(const char* n) { this-&gt;n = n; } void getClassBName(classB&amp; b) { cout &lt;&lt; &quot;classB : &quot; &lt;&lt; b.n &lt;&lt; endl; } /*那是B是C的友元，A是B的友元，那么A是C的友元吗？实验测试：不是 void getClassCName(classC&amp; c) { cout &lt;&lt; &quot;classB : &quot; &lt;&lt; c.n &lt;&lt; endl; } */ }; int main(int argc, char *argv[]) { classA A(&quot;classA&quot;); classC C(&quot;classC&quot;); classB B(&quot;classB&quot;); A.getClassBName(B); B.getClassCName(C); return 0; } 小结 友元是为了兼顾C语言的高效而诞生的 友元直接破坏了面向对象的封装性 友元关系不具备传递性 类的友元可以是其他类的成员函数 类的友元课以是某个完整的类 ","link":"https://leichen2552.github.io/post/hui-gu-you-yuan-de-gan-ga-neng-li/"},{"title":"回顾（27）：二阶构造模式","content":" 构造函数的回顾 关于构造函数 半成品对象的概念 解决方案：二阶构造 实例展示二阶构造 再次修改数组类 IntArray.h IntArray.cpp main.cpp 小结 构造函数的回顾 关于构造函数 类的构造函数用于对象的初始化 构造函数与类同名并且没有返回值 构造函数在对象定时自动被调用 问题： 1. 如何判断构造函数的执行结果？就目前来说是没有办法来捕捉这个执行结果! 2. 在构造函数中执行return语句会发生什么？ 3. 构造函数执行结束是否意味着对象构造成功？ 构造函数 只提供自动初始化成员变量的机会 不能保证初始化逻辑一定成功 执行return语句后构造函数立即结束 #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; class Test { private: int mi; int mj; bool mstatus;//强行让构造函数有个返回值，来判断构造函数是否构造成功 public: Test(int i, int j):mstatus(false) { return; mi = i; mj = j; mstatus = true; } int getI() { return mi; } int getJ() { return mj; } int status() { return mstatus; } }; int main(int argc, char *argv[]) { Test t1(1,2); if(t1.status()) { cout &lt;&lt; &quot;t1.mi = &quot; &lt;&lt; t1.getI() &lt;&lt; endl; cout &lt;&lt; &quot;t1.mj = &quot; &lt;&lt; t1.getJ() &lt;&lt; endl; } return 0; } 构造函数能决定的只是对象的初始状态，而不是对象的诞生！ 半成品对象的概念 初始化操作不能按照预期完成而得到的对象 半成品对象是合法的C++对象，也是Bug的重要来源 解决方案：二阶构造 工程开中的构造过程可分为 资源无关的初始化操作 不可能出现异常情况的操作 需要使用系统资源的操作 可能出现异常情况，如：内存申请，访问文件 class TwoPhaseCons { private: TwoPhaseCons() { //这个构造函数放在了private里面，就不能在外界被调用， //不能够直接地通过类名来定义变量 //第一阶段构造函数，与资源无关的初始化操作 } bool construct() { //第二阶段构造函数，与资源相关的初始化操作 return true; } public: static TwoPhaseCons* NewInstance();//静态的对象创建函数，返回一个对象指针， //就是真正意义上的创建函数，用于创建对象 }; TwoPhaseCons* TwoPhaseCons::NewInstance() { TwoPhaseCons* ret = new TwoPhaseCons(); //若第二阶段构造失败，返回NULL if( !(ret &amp;&amp; ret-&gt;construct()) ) { delete ret; ret = NULL; } return ret; } 实例展示二阶构造 #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; class Test { private: int mi; int* mp; Test() { mi = 0; } bool construct() { mp = new int; if(mp) { return true; } return false; } public: static Test* NewInstance(); }; Test* Test::NewInstance() { Test* ret = new Test(); if( !(ret &amp;&amp; ret-&gt;construct()) ) { delete ret; ret = NULL; } return ret; } int main(int argc, char *argv[]) { Test* t = Test::NewInstance();//静态成员函数只能通过类名::或者对象调用 cout &lt;&lt; &quot;t = &quot; &lt;&lt; t &lt;&lt; endl; return 0; } 静态成员函数只能通过类名::或者对象调用 再次修改数组类 IntArray.h #ifndef INTARRAY_H #define INTARRAY_H class IntArray{ private: int m_length; int* m_pointer; IntArray(int len); //IntArray(const IntArray&amp; ob); bool construct(); public: static IntArray* NewInstance(int length); int length(); bool get(int index, int&amp; value); bool set(int index, int value); ~IntArray(); }; #endif IntArray.cpp #include &quot;IntArray.h&quot; IntArray::IntArray(int len) { m_length = len; } bool IntArray::construct() { bool ret = true; m_pointer = new int[m_length]; if(m_pointer) { for(int i = 0;i &lt; m_length; i++) { m_pointer[i] = 0; } } else { ret = false; } return ret; } IntArray* IntArray::NewInstance(int length) { IntArray* ret = new IntArray(length); if( !(ret &amp;&amp; ret-&gt;construct()) ) { delete ret; ret = NULL; } return ret; } int IntArray::length() { return m_length; } bool IntArray::get(int index, int&amp; value) { bool ret = (0 &lt;= index)&amp;&amp;(index &lt; length()); if(ret) { value = m_pointer[index]; } return ret; } bool IntArray::set(int index, int value) { bool ret = (0 &lt;= index)&amp;&amp;(index &lt; length()); if(ret) { m_pointer[index] = value; } return ret; } IntArray::~IntArray() { delete[] m_pointer; } main.cpp #include &lt;iostream&gt; #include &quot;IntArray.h&quot; using namespace std; int main(int argc, char *argv[]) { IntArray* a = IntArray::NewInstance(5); for(int i=0; i&lt;a-&gt;length(); i++) { a-&gt;set(i,i+1);//这个函数返回的是bool类型值 } cout &lt;&lt; &quot;a-&gt;length() = &quot; &lt;&lt; a-&gt;length() &lt;&lt; endl; for(int i=0; i&lt;a-&gt;length(); i++) { int v = 0; a-&gt;get(i,v);//这个函数返回的是bool类型值 cout &lt;&lt; &quot;a[&quot;&lt;&lt; i &lt;&lt;&quot;] = &quot; &lt;&lt; v &lt;&lt; endl; } delete a; return 0; } #endif 大多数人又要问，使用了二阶构造之后，产生的对象只能在堆空间，就不能再栈空间了。这样恰恰是最好的，这些巨大的对象，是不适用于放在栈空间的，应该放在堆空间里面。 小结 构造函数只能决定对象的初始化状态 构造函数中初始化操作的失败不影响对象的诞生 初始化不完全的半成品对象是Bug的重要来源 二阶构造是人为的将初始化过程分为两部分 二阶构造能够确保创建的对象都是完整初始化的 ","link":"https://leichen2552.github.io/post/hui-gu-27er-jie-gou-zao-mo-shi/"},{"title":"回顾（26）：类的静态成员函数","content":" 未完成的需求 解决方案一 问题分析 静态成员函数 最终解决方案 小结 未完成的需求 先来看看上篇博客里面客户的三个需求： # 新的需求：小实例 1. 统计在程序期间某个类的对象数目【完成】 2. 保证程序的安全性（不能使用全局变量）【完成】 3. 随时获取当前对象的数目【未完成】 #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; class Test { private: static int mCount; public: Test() { mCount++; } ~Test() { mCount--; } int getCount() { return mCount; } }; int Test::mCount = 0; int main(int argc, char *argv[]) { return 0; } 问题：如果这个程序里面没有任何的对象，那么在主函数里面应该返回0个对象 解决方案一 class Test { private:--&gt;改成public static int mCount; public: } 但是这样又会面临一个问题：这个static int mCount变量就可以在外部任意地方改动 //比如：改成1000表示在程序中会有1000个对象吗？ int main(int argc, char *argv[]) { cout &lt;&lt; &quot;Test :: mCount = &quot; &lt;&lt; Test::mCount &lt;&lt; endl; Test::mCount = 1000; cout &lt;&lt; &quot;Test :: mCount = &quot; &lt;&lt; Test::mCount &lt;&lt; endl; return 0; } 所以这种解决方案失败！这样的代码安全性拿不出手，也拿不出手！ 问题分析 不依赖对象就可以访问静态成员变量 必须保证静态成员变量的安全性，像上面那种把属性改成public的方式太暴力 方便快捷的获取静态成员变量的值 静态成员函数 在C++中课以定义静态成员函数 静态成员函数是类中特殊的成员函数 静态成员函数属于整个类所有 可以通过类名直接访问共有静态成员函数 可以通过对象名访问共有静态成员函数 静态成员函数的定义 直接通过static关键字修饰成员函数 class Test { public : static void Func1() {} static int Func2() {} } int Test::Func2() { return 0; } 静态成员函数不能访问普通成员变量 静态成员函数 VS 普通成员函数 静态成员函数 普通成员函数 所有对象共享 Yes Yes 隐含this指针 No Yes 访问普通成员变量（函数） No Yes 访问静态成员变量（函数） Yes Yes 通过类名直接调用 Yes No 通过对象名直接调用 Yes Yes 最终解决方案 #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; class Test { private: static int mCount; public: Test() { mCount++; } ~Test() { mCount--; } static int getCount() { return mCount; } }; int Test::mCount = 0; Test gTest; int main(int argc, char *argv[]) { cout &lt;&lt; &quot;Test :: mCount = &quot; &lt;&lt; Test::getCount() &lt;&lt; endl; Test t; cout &lt;&lt; &quot;Test :: mCount = &quot; &lt;&lt; Test::getCount() &lt;&lt; endl; Test* p = new Test(); cout &lt;&lt; &quot;Test :: mCount = &quot; &lt;&lt; Test::getCount() &lt;&lt; endl; delete p; cout &lt;&lt; &quot;Test :: mCount = &quot; &lt;&lt; Test::getCount() &lt;&lt; endl; return 0; } 小结 静态成员函数是类中特殊的成员函数 静态成员函数没有隐藏的this指针 静态成员函数可以通过类名直接访问 静态成员函数只能访问静态成员变量与静态成员函数，也正是利用了这个特性，完成了客户的需求 ","link":"https://leichen2552.github.io/post/hui-gu-25lei-de-jing-tai-cheng-yuan-han-shu/"},{"title":"回顾（25）：类的静态成员变量","content":"成员变量回顾 通过对象名都能够访问public成员变量 每个对象的成员变量都是专属的 成员变量不能在对象之间共享 新的需求：小实例 统计在程序期间某个类的对象数目 保证程序的安全性（不能使用全局变量） 随时获取当前对象的数目 尝试第一种方案 #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; class Test { private: int mCount; public: Test():mCount(0) { mCount++; } ~Test() { mCount--; } int getCount() { return mCount; } }; Test gTest; int main(int argc, char *argv[]) { Test t1; Test t2; cout &lt;&lt; &quot;count = &quot; &lt;&lt; gTest.getCount() &lt;&lt; endl; cout &lt;&lt; &quot;count = &quot; &lt;&lt; t1.getCount() &lt;&lt; endl; cout &lt;&lt; &quot;count = &quot; &lt;&lt; t2.getCount() &lt;&lt; endl; return 0; } //结果是三个1，因为成员变量是每个对象私有一套的 尝试第二种方案 #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; int gCount; class Test { private: int mCount; public: Test():mCount(0) { gCount++; } ~Test() { gCount--; } int getCount() { return gCount; } }; Test gTest; int main(int argc, char *argv[]) { Test t1; Test t2; cout &lt;&lt; &quot;count = &quot; &lt;&lt; gTest.getCount() &lt;&lt; endl; cout &lt;&lt; &quot;count = &quot; &lt;&lt; t1.getCount() &lt;&lt; endl; cout &lt;&lt; &quot;count = &quot; &lt;&lt; t2.getCount() &lt;&lt; endl; return 0; } //打印结果三个3，但是用的是全局变量， //在当代的软件设计当中是不能使用全局变量的，因为在任何地方都能访问全局变量 //所以不能使用全局变量 静态成员变量 在C++中课以定义静态成员变量 静态成员变量属于整个类所有，是属于整个类 静态成员变量的生命期不依赖任何对象，就是程序的运行周期 可以通过类名直接访问共有静态成员变量 所有对象共享类的静态成员变量 可以通过对象名访问共有静态成员变量 静态成员变量的特性 在定义时直接通过static关键字修饰 静态成员变量需要在类外单独分配空间 静态成员变量在程序内部位于全局数据区 语法规则： Type ClassName::VarName = value; 尝试第三种方案 #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; class Test { private: static int mCount; public: Test() { mCount++; } ~Test() { mCount--; } int getCount() { return mCount; } }; //如果不加这句，编译器就会报链接器的错误 int Test::mCount = 0;//这是在类的外部单独定义这个静态成员变量并初始化为0 // Test gTest; int main(int argc, char *argv[]) { Test t1; Test t2; cout &lt;&lt; &quot;count = &quot; &lt;&lt; gTest.getCount() &lt;&lt; endl; cout &lt;&lt; &quot;count = &quot; &lt;&lt; t1.getCount() &lt;&lt; endl; cout &lt;&lt; &quot;count = &quot; &lt;&lt; t2.getCount() &lt;&lt; endl; Test* pt = new Test(); cout &lt;&lt; &quot;count = &quot; &lt;&lt; pt-&gt;getCount() &lt;&lt; endl; delete pt; cout &lt;&lt; &quot;count = &quot; &lt;&lt; gTest.getCount() &lt;&lt; endl; return 0; } //[Error] E:\\User\\exercise_Cpp\\25jingtaichengyuan\\main.cpp:(.text$_ZN4TestD1Ev[Test::~Test()]+0x5): undefined reference to `Test::mCount' //[Error] E:\\User\\exercise_Cpp\\25jingtaichengyuan\\main.cpp:(.text$_ZN4Test8getCountEv[Test::getCount()]+0x4): undefined reference to `Test::mCount' //[Error] E:\\User\\exercise_Cpp\\25jingtaichengyuan\\main.cpp:(.text$_ZN4TestC1Ev[Test::Test()]+0x5): undefined reference to `Test::mCount' //[Error] collect2: ld returned 1 exit status //这是链接器找不到static int mCount的内存空间， //需要在类的外部单独定义，以便于分配空间 小结 类中可以通过static关键字定义静态成员变量 静态成员变量隶属于类所有，需要在外部进行分配空间 每一个对象都可以访问静态成员变量 静态成员变量在全局数据区分配空间 静态成员变量的生命期为程序运行期 ","link":"https://leichen2552.github.io/post/hui-gu-25lei-de-jing-tai-cheng-yuan-bian-liang/"},{"title":"回顾（24）：经典问题解析二","content":" 关于析构的疑问 关于const对象的疑问 关于类成员的疑问 小结 关于析构的疑问 单个对象创建时构造函数的调用顺序 调用父类的构造过程（后续课程中会讲解） 调用成员变量的构造函数（调用顺序和声明顺序相同） 调用类自身的构造函数 析构函数与对应构造函数的调用顺序相反 多个对象析构时 析构顺序与构造顺序相反 #include &lt;iostream&gt; using namespace std; class Member { private: const char* ms; public: Member(const char* s) { cout &lt;&lt; &quot;Member(const char* s): &quot; &lt;&lt; s &lt;&lt; endl; ms = s; } ~Member() { cout &lt;&lt; &quot;~Member(): &quot; &lt;&lt; ms &lt;&lt; endl; } }; class Test { private: Member mA; Member mB; public: Test():mA(&quot;mA&quot;),mB(&quot;mB&quot;) { cout &lt;&lt; &quot;Test()&quot; &lt;&lt; endl; } ~Test() { cout &lt;&lt; &quot;~Test()&quot; &lt;&lt; endl; } }; Member gA(&quot;gA&quot;); int main(int argc, char *argv[]) { Test t; return 0; } 打印结果： Member(const char* s): gA Member(const char* s): mA Member(const char* s): mB Test() ~Test() ~Member(): mB ~Member(): mA ~Member(): gA 果然，析构顺序与构造顺序相反 对于栈对象和全局对象，类似于入栈与出栈的顺序，最后构造的对象最先被析构 堆对象的析构发生在使用delete的时候，与delete的使用顺序相关 关于const对象的疑问 const关键字能否修饰类的对象？ 如果可以，有什么特性？ const关键字能够修饰对象 const修饰的对象为只读对象 只读对象的成员变量不允许被改变 只读对象是编译阶段的概念，运行时无效，但还可以被改变的 C++中的const函数 const对象只能调用const的成员函数 const成员函数中只能调用const成员函数 const成员函数中不能直接改写成员变量的值 const成员函数的定义：在函数之后加const Type ClassName::function(Type p) const 类中的函数声明与实际函数声明中必须带const关键字 #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; class Test { private: int mi; public: int mj; Test(int i); Test(const Test&amp; t); int getMI()const; //const对象只能调用const的成员函数 }; Test::Test(int i) { mi = i; } Test::Test(const Test&amp; t)//这个t是const引用，使的这个t具有只读属性， //所以t必须访问const成员函数 { mi = t.getMI(); } int Test::getMI()const//const对象只能调用const的成员函数 { //mi = 2;// error: assignment of data-member `Test::mi' in read-only structure //const成员函数中不能直接改写成员变量的值 return mi; } int main(int argc, char *argv[]) { const Test t(1);//const对象只能调用const的成员函数 //t.mj = 1000;//error: assignment of data-member `Test::mj' in read-only structure cout &lt;&lt; &quot;t.getMI() = &quot; &lt;&lt; t.getMI() &lt;&lt; endl; //error: passing `const Test' as `this' argument of `int Test::getMI()' discards qualifiers return 0; } 关于类成员的疑问 成员函数和成员变量都是隶属于具体对象的吗？ 从面向对象的角度 对象由属性（成员变量）和方法（成员函数）构成，每个对象都拥有自己的一套成员变量，但是所有的对象共享一套成员函数 从程序运行的角度 对象由数据和函数构成 数据只可能可以位于栈、堆和全局数据区 函数只能位于代码段。代码段是只读的，在程序运行的时候是不能被改变的。程序被编译好之后，对象可以被动态地创建和动态地删除，对数据而言，栈数据、堆数据也可以被创建或者删除。对于代码段来说，是不能随意添加或者删除的。由于程序的特性，天生的决定成员函数不是每个对象都有一套的，所以只有每个对象共享一套成员函数。 疑问：既然所有对象都共享一套成员函数，那成员函数是怎么知道是哪个对象调用的呢？ 答案：既然是成员函数，肯定不同于普通的全局函数，主要区别在于成员函数里面有一个你看不见的但是隐藏了的参数，这个参数是一个指针，并且这个指针有名字：this，this指针指代当前调用这个函数的对象 结论 每个对象拥有自己独立的属性（成员变量） 所有对象共享类的方法（成员函数） 方法能够直接访问对象的属性 方法中隐藏参数 this用于指代当前对象 #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; class Test { private: int mi; public: int mj; Test(int i); Test(const Test&amp; t); int getMI(); int print(); }; Test::Test(int i) { mi = i; } Test::Test(const Test&amp; t) { mi = t.mi; } int Test::getMI() { return mi; } int Test::print()//this指代当前调用这个函数的对象的地址 { cout &lt;&lt; &quot;this = &quot; &lt;&lt; this &lt;&lt; endl; } int main(int argc, char *argv[]) { Test t1(1); Test t2(2); Test t3(3); cout &lt;&lt; &quot;t1.getMI() = &quot; &lt;&lt; t1.getMI() &lt;&lt; endl; cout &lt;&lt; &quot;&amp;t1 = &quot; &lt;&lt; &amp;t1 &lt;&lt; endl;//t1对象地址 t1.print();//this指针指代当前指向的对象的地址，就是t1的地址 cout &lt;&lt; &quot;t2.getMI() = &quot; &lt;&lt; t2.getMI() &lt;&lt; endl; cout &lt;&lt; &quot;&amp;t2 = &quot; &lt;&lt; &amp;t2 &lt;&lt; endl;//t2对象地址 t2.print();//this指针指代当前指向的对象的地址，就是t2的地址 cout &lt;&lt; &quot;t3.getMI() = &quot; &lt;&lt; t3.getMI() &lt;&lt; endl; cout &lt;&lt; &quot;&amp;t2 = &quot; &lt;&lt; &amp;t2 &lt;&lt; endl;//t3对象地址 t3.print(); //this指针指代当前指向的对象的地址，就是t3的地址 return 0; } 小结 对象的析构顺序和构造顺序相反 const关键字能够修饰对象，得到只读对象 只读对象只能调用const成员函数 所有对象共享类的成员函数 同一套成员函数怎么分辨不同的对象呢，有一个特殊的参数，这个特殊的参数指向当前调用成员函数的对象，隐藏的this指针用于指向当前对象 ","link":"https://leichen2552.github.io/post/hui-gu-24jing-dian-wen-ti-jie-xi-er/"},{"title":"回顾（23）：神秘的临时对象","content":"神秘的临时对象 问题 class Test { private : int mi; public : Test(int v) { mi = v; } Test() { Test(0); } void print() { printf(&quot;mi = %d\\n&quot;, mi); } }; int main() { Test t; t.print(); return 0; } 程序意图 在Test()中以0作为参数调用Test(int i) 将成员变量mi的初始值设置为0 运行结果 成员变量mi的值为随机值 究竟什么地方出了问题？ 思考 构造函数是一个特殊的函数 是否可以直接调用？这个是可以的，之前初始化一个数组的时候就是手工调用构造函数 是否可以在构造函数中调用构造函数？ 直接调用构造函数的行为是什么？ 答案 直接调用构造函数将产生一个临时对象 临时对象的生命周期只有一条语句的时间 临时对象的作用域只在一条语句当中 临时对象是C++中值得警惕的灰色地带 //上面的代码中 Test() { Test(0);//这条语句产生了一个临时对象 } //上面有问题的代码需要这样改：提供一个init()函数 class Test { private : int mi; void init(int i) { mi = i; } public : Test(int v) { init(v); } Test() { init(0); } void print() { printf(&quot;mi = %d\\n&quot;, mi); } }; int main() { Test t; t.print(); return 0; } 练习 class Test { private : int mi; void init(int i) { mi = i; } public : Test(int v) { cout &lt;&lt; &quot;Test(int v)&quot; &lt;&lt; endl; init(v); } Test() { cout &lt;&lt; &quot;Test()&quot; &lt;&lt; endl; init(0); } void print() { printf(&quot;mi = %d\\n&quot;, mi); } ~Test() { cout &lt;&lt; &quot;~Test()&quot; &lt;&lt; endl; init(0); } }; int main() { Test();//临时对象 Test(10);//临时对象 Test().print();//临时对象的print() Test(10).print();//临时对象的print() return 0; } 打印结果： Test() ~Test() Test(int v) ~Test() Test() mi = 0; ~Test() Test(int v) mi = 10; ~Test() 现在的C++编译器会减少临时对象的产生，C++继承了C语言的高效，所以该杜绝临时对象的地方就会杜绝 #include &lt;stdio.h&gt; class Test { int mi; public: Test(int i) { printf(&quot;Test(int i) : %d\\n&quot;, i); mi = i; } Test(const Test&amp; t) { printf(&quot;Test(const Test&amp; t) : %d\\n&quot;, t.mi); mi = t.mi; } Test() { printf(&quot;Test()\\n&quot;); mi = 0; } int print() { printf(&quot;mi = %d\\n&quot;, mi); } ~Test() { printf(&quot;~Test()\\n&quot;); } }; Test func() { return Test(20); } int main() { Test t = Test(10); // ==&gt; Test t = 10（这也是推荐写法）; //本来应该是拷贝构造函数出现临时对象， //但是当代的C++编译器会尽力避开临时对象的产生 Test tt = func(); // ==&gt; Test tt = Test(20); ==&gt; Test tt = 20; t.print(); tt.print(); return 0; } 小结 直接调用构造函数将产生一个临时对象。在C语言中出现bug的原因就是野指针，而在C++中的bug就是临时对象 临时对象是性能的瓶颈，也是bug的来源之一 现代C++编译器会尽力避开临时对象 实际工程开发需要人为的避开临时对象 ","link":"https://leichen2552.github.io/post/hui-gu-23shen-mi-de-lin-shi-dui-xiang/"},{"title":"回顾（22）：对象的销毁","content":"对象的销毁 生活中的对象都是被初始化之后才上市的 生活中的对象被销毁前会做一些清理工作 问题：C++中如何清理需要销毁的对象？ 添加public的free函数 一般而言，需要销毁的对象都应该被清理 解决方案： 为每个类都提供一个public的free函数 对象不需要时立即调用free函数进行清理 class Test { int* p; public: Test() {p = new int} void free() {delete p;} } 存在的问题 free只是一个普通的函数，必须显示调用 对象销毁没有做处理，很可能造成资源泄露 想法：C++编译器能否自动调用某个特殊函数进行对象的清理？ 析构函数 C++的类中可以定义个特殊的清理函数 这个特殊的清理函数叫做析构函数 析构函数的功能与构造函数相反 定义：~ClassName() 析构函数没有参数也没有返回值类型，直接推出这个函数不能被重载 析构函数在对象销毁时自动被调用 class Test { int i; public: Test(int v) { i = v; printf(&quot;Test(): i = %d\\n&quot;,i); } ~Test() { printf(&quot;~Test(): i = %d\\n&quot;,i); } } int main() { Test t(1); Test* p = new Test(2); delete p; return 0; } 修改之前的数组类 InrArray.h #ifndef INTARRAY_H #define INTARRAY_H class IntArray{ private: int m_length; int* m_pointer; public: IntArray(int len); IntArray(const IntArray&amp; ob); int length(); bool get(int index, int&amp; value); bool set(int index, int value); ~IntArray(); }; #endif IntArray.cpp #include &quot;IntArray.h&quot; #include &lt;iostream&gt; using namespace std;//命名空间声明在此 IntArray::IntArray(int len) { m_pointer = new int[len]; for(int i = 0;i &lt; len; i++) { m_pointer[i] = 0; } m_length = len; } IntArray::IntArray(const IntArray&amp; ob) { m_length = ob.m_length; m_pointer = new int[ob.m_length]; for(int i = 0;i &lt; ob.m_length;i++) { m_pointer[i] = ob.m_pointer[i]; } } int IntArray::length() { return m_length; } bool IntArray::get(int index, int&amp; value) { bool ret = (0 &lt;= index)&amp;&amp;(index &lt; length()); if(ret) { value = m_pointer[index]; } return ret; } bool IntArray::set(int index, int value) { bool ret = (0 &lt;= index)&amp;&amp;(index &lt; length()); if(ret) { m_pointer[index] = value; } return ret; } IntArray::~IntArray() { cout &lt;&lt; &quot;~IntArray()&quot; &lt;&lt; endl;//在数组类实现细节的代码中加入输入输出， //必须要有命名空间的声明 delete[] m_pointer; } main.c #include &lt;iostream&gt; #include &quot;IntArray.h&quot; using namespace std; int main(int argc, char *argv[]) { IntArray a(5); for(int i=0; i&lt;a.length(); i++) { a.set(i,i+1); } for(int i=0; i&lt;a.length(); i++) { int value = 0; if(a.get(i,value)) { cout &lt;&lt; &quot;a[&quot;&lt;&lt; i&lt;&lt; &quot;]= &quot; &lt;&lt;value &lt;&lt; endl; } } IntArray b = a; for(int i=0; i&lt;b.length(); i++) { int value = 0; if(b.get(i,value)) { cout &lt;&lt; &quot;b[&quot;&lt;&lt; i&lt;&lt; &quot;]= &quot; &lt;&lt;value &lt;&lt; endl; } } return 0; } 析构函数的定义准则 当类中自定义了构造函数并且构造函数中使用了系统资源（如：内存申请，文件打开，等），需要自定义析构函数 小结 析构函数是对象销毁时进行清理的特殊函数 析构函数在对象销毁时自动被调用 析构函数是对象释放系统资源的保障，意义非常重要，可以让我们编写的软件能更加稳定！ ","link":"https://leichen2552.github.io/post/hui-gu-22dui-xiang-de-xiao-hui/"},{"title":"回顾（21）：对象构造顺序","content":"对象的构造顺序 C++中的类可以定义多个对象，那么对象构造的顺序是怎样的？ 对于局部对象 当程序执行流到达对象的定义语句时进行构造 class Test { private: int mi; public: Test() { mi = i; printf(&quot;Test(int i): %d\\n&quot;, mi); } Test() { mi = obj.mi; printf(&quot;Test(const Test&amp; obj): %d\\n&quot;, mi); } }; int main { int i = 0; Test a1 = i; while(i&lt;3) { Test a2 = ++i; } if(i &lt; 4) { Test a = a1; } else { Test a(100); } return 0; } 对于堆对象 当程序执行流到达new语句时创建对象 使用new创建对象将自动触发构造函数的调用 int main { int i = 0; Test* a1 = new Test(i); while(++i&lt;10) { if(i % 2) new Test(i); } if(i &lt; 4) { new Test(*a1); } else { new Test a(100); } return 0; } 对于全局对象 全局对象的构造顺序是不确定的 全局对象的构造顺序是不确定的 全局对象的构造顺序是不确定的 不同的编译器使用不同的规则确定构造顺序 小结 局部对象的构造顺序依赖于程序的执行流，goto语句会破坏程序的执行流 堆对象的构造顺序依赖于new的使用顺序 全局对象的构造顺序是不确定的，也是日常工程开发bug的主要来源之一 ","link":"https://leichen2552.github.io/post/hui-gu-21dui-xiang-gou-zao-shun-xu/"},{"title":"回顾（20）：初始化列表的使用","content":" 问题 初始化列表 注意事项 初始化和赋值不同 小结 问题 问题：类中能否定义const成员变量？ #include &lt;iostream&gt; using namespace std; class Test { private: const int ci; public: Test() { ci = 10; } int getI() { return ci; } }; int main(int argc, char *argv[]) { Test t; return 0; } //如果没有构造函数，编译器会报错，因为t中存在没有初始化的const成员变量 //如果有构造函数对ci进行初始化，编译器会报错，只读变量是不能出现在赋值符号的左边 初始化列表 C++中提供了初始化列表对成员变量进行初始化 语法规则 className::className():m1(v1),m2(v1,v2),m3(v3) { //some other initialize operation } #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; class Test { private: const int ci; public: Test():ci(10) { } int getI() { return ci; } }; int main(int argc, char *argv[]) { Test t; cout &lt;&lt; &quot;t.getI() = &quot;&lt;&lt; t.getI() &lt;&lt;endl; return 0; } //这个const变量是只读变量，依然是可以通过指针来修改值 Test():ci(10) { int* p = const_cast&lt;int*&gt;(&amp;ci); *p = 5; } 注意事项 成员的初始化顺序与成员的声明顺序相同 成员的初始化顺序与初始化列表的位置无关 初始化列表先于构造函数的函数体执行 #include &lt;stdio.h&gt; class Value { private: int mi; public: Value(int i) { printf(&quot;i = %d\\n&quot;, i); mi = i; } int getI() { return mi; } }; class Test { private: Value m2; Value m3; Value m1; public: Test() : m1(1), m2(2), m3(3)//成员的初始化顺序与成员的声明顺序相同,2,1,3 { printf(&quot;Test::Test()\\n&quot;); } }; 类中的const成员会被分配空间 类中的const成员的本质是只读变量 类中的const成员只能在初始化列表中指定初始值 编译器无法得到const成员的初始值，因为无法进入符号表成为真正意义上的常量 初始化和赋值不同 初始化：对正在创建的对象进行初值设置 赋值：对已经存在的对象进行值设置 小结 类中可以使用初始化列表对成员进行初始化 初始化列表先于构造函数体执行 类中可以定义const成员变量 const成员变量必须在初始化列表中指定初值 const成员变量为只读变量，依然可以通过指针来修改 ","link":"https://leichen2552.github.io/post/hui-gu-20chu-shi-hua-lie-biao-de-shi-yong/"},{"title":"回顾（19）：对象的构造（下）","content":" 特殊的构造函数 无参构造函数 拷贝构造函数 拷贝构造函数的意义 什么时候需要深拷贝 数组类改进 IntArray.h IntArray.cpp main.cpp 小结 特殊的构造函数 无参构造函数 没有参数的构造函数 当类中没有定义构造函数，编译器默认提供一个无参构造函数，并且其函数体为空 #include &lt;stdio.h&gt; class Test { private: int i; int j; public: int getI(){ return i;} int getJ(){ return j;} //编译器为什么能编译器通过。 //我们没有定义任何的构造函数时，编译器就提供了默认的无参构造函数 /* Test() {} */ //类中并没有手工构造函数，就提供一个默认的拷贝构造函数， //但是如果只有一个手工拷贝构造函数，编译器就不会提供默认的无参构造函数 //但是编译会出错，还需要一个手工无参构造函数 /* Test(const Test&amp; t) { i = t.i; j = t.j; } */ }; int main() { Test t1; Test t2 = t1; cout &lt;&lt; &quot;t1.i = &quot; &lt;&lt; t1.i &lt;&lt; &quot;t1.j&quot; &lt;&lt; t1.j; cout &lt;&lt; &quot;t2.i = &quot; &lt;&lt; t2.i &lt;&lt; &quot;t2.j&quot; &lt;&lt; t2.j; return 0; } 拷贝构造函数 参数为const class_name&amp; 的构造函数 当类中没有定义拷贝构造函数，编译器默认提供一个拷贝构造函数，简单的进行成员变量的值的赋值 拷贝构造函数的意义 兼容C语言的初始化方式 初始化行为能够符合预期的逻辑 浅拷贝 拷贝后对象的物理状态相同 深拷贝 拷贝后对象的逻辑状态相同 编译器提供的拷贝构造函数只进行浅拷贝 #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; #include &lt;stdio.h&gt; class Test { private: int i; int j; int* p; public: int getI(){ return i;} int getJ(){ return j;} int* getP(){return p;} Test(int v) { i = 1; j = 2; p = new int; *p = v; } Test(const Test&amp; t) { i = t.i; j = t.j; p = new int; *p = *t.p; } void free() { delete p; } }; //类的创建一定要加分号 int main() { Test t1(3); Test t2 = t1; cout &lt;&lt; &quot;t1.i = &quot; &lt;&lt; t1.getI() &lt;&lt; &quot;,t1.j =&quot; &lt;&lt; t1.getJ() &lt;&lt; &quot;,t1.p = &quot;&lt;&lt; t1.getP() &lt;&lt; &quot;,*t1.p = &quot;&lt;&lt; *t1.getP() &lt;&lt; endl; cout &lt;&lt; &quot;t2.i = &quot; &lt;&lt; t2.getI() &lt;&lt; &quot;,t2.j =&quot; &lt;&lt; t2.getJ() &lt;&lt; &quot;,t2.p = &quot;&lt;&lt; t2.getP() &lt;&lt; &quot;,*t2.p = &quot;&lt;&lt; *t2.getP() &lt;&lt; endl; t1.free(); t2.free(); return 0; } 这两个指针指向了一个内存空间，并且被释放了两次，采用浅拷贝编译器会报错，如图所示 什么时候需要深拷贝 对象中有成员指代了系统中的资源 成员指向了动态内存空间 成员打开了外存中的文件 成员使用了系统中的网络端口 数组类改进 因为上一节课的数组类中有对堆空间的申请，所以需要添加深拷贝构造函数 IntArray.h #ifndef INTARRAY_H #define INTARRAY_H class IntArray{ private: int m_length; int* m_pointer; public: IntArray(int len); int length(); bool get(int index, int&amp; value); bool set(int index, int value); IntArray(const IntArray&amp; ob); void free(); };//类的创建一定要加分号！！！ #endif IntArray.cpp #include &quot;IntArray.h&quot; IntArray::IntArray(int len) { m_pointer = new int[len]; for(int i = 0;i &lt; len; i++) { m_pointer[i] = 0; } m_length = len; } IntArray::IntArray(const IntArray&amp; ob) { m_length = ob.m_length; m_pointer = new int[ob.m_length]; for(int i = 0;i &lt; ob.m_length;i++) { m_pointer[i] = ob.m_pointer[i]; } } int IntArray::length() { return m_length; } bool IntArray::get(int index, int&amp; value) { bool ret = (0 &lt;= index)&amp;&amp;(index &lt; length()); if(ret) { value = m_pointer[index]; } return ret; } bool IntArray::set(int index, int value) { bool ret = (0 &lt;= index)&amp;&amp;(index &lt; length()); if(ret) { m_pointer[index] = value; } return ret; } void IntArray::free() { delete[] m_pointer; } main.cpp #include &lt;iostream&gt; #include &quot;IntArray.h&quot; using namespace std; int main(int argc, char *argv[]) { IntArray a(5); for(int i=0; i&lt;a.length(); i++) { a.set(i,i+1); } for(int i=0; i&lt;a.length(); i++) { int value = 0; if(a.get(i,value)) { cout &lt;&lt; &quot;a[&quot;&lt;&lt; i&lt;&lt; &quot;]= &quot; &lt;&lt;value &lt;&lt; endl; } } IntArray b = a; for(int i=0; i&lt;b.length(); i++) { int value = 0; if(b.get(i,value)) { cout &lt;&lt; &quot;b[&quot;&lt;&lt; i&lt;&lt; &quot;]= &quot; &lt;&lt;value &lt;&lt; endl; } } a.free(); b.free(); return 0; } 小结 C++编译器会默认提供构造函数 无参构造函数用于定义对象的默认初始状态，编译器发现没有任何的构造函数时，才会提供无参构造函数 拷贝构造函数在创建对象时拷贝对象的状态 对象的拷贝有深拷贝和浅拷贝两种方式 浅拷贝使得对象的物理状态相同 深拷贝使得对象的逻辑状态相同，如果使用了系统资源，就必须手动提供深拷贝函数 ","link":"https://leichen2552.github.io/post/hui-gu-19dui-xiang-de-gou-zao-xia/"},{"title":"回顾（18）：对象的构造（中）","content":" 构造函数 友情提醒 构造函数的调用 小实例 IntArray.h IntArray.cpp main.cpp 小结 构造函数 带有参数的构造函数 构造函数可以根据需要定义参数 一个类中可以存在多个重载的构造函数 构造函数的重载遵循C++重载的规则 class Test { private: int i; int j; public: Test() { } Test(int v) {//use v to initialize member } }; 友情提醒 对象定义和对象声明时不同的 对象定义：申请对象的空间并调用构造函数 对象声明：告诉编译器存在这样一个对象 Test t;//定义对象并调用构造函数 int main() { extern Test t;//告诉编译器存在名为 t 的 Test 对象 return 0; } 构造函数的自动调用 class Test { public: Test() { printf(&quot;Test()&quot;); } Test(int v) {//use v to initialize member printf(&quot;Test(int v)，v = %d\\n&quot;,v); } }; int main() { Test t; //调用Test() Test t1(1); //调用Test(int v) Test t2 = 1; //调用Test(int v) t = t2;//赋值 //啰嗦几句！ int i = 1;//这个叫定义并且初始化 int j;//这个初始化赋值是随机的 j = 2;//这个叫做赋值 int z(100);//这样子的初始化也合法 printf(&quot;z = %d\\n&quot;, z); return 0; } 赋值和初始化是不相同！！！ 构造函数的调用 一般情况下，构造函数在对象定义时被自动调用 一些特殊情况下，需要手工调用构造函数 如何创建一个对象数组？ class Test { private: int m_value; public: Test() { printf(&quot;Test()&quot;); m_value = 0; } Test(int v) {//use v to initialize member printf(&quot;Test(int v)，v = %d\\n&quot;,v); m_value = v; } }; int main() { Test ta[3] = {Test(), Test(1), Test(2)};//手工调用构造函数， //对数组中的每一个元素初始化 for(int i = 0; i&lt;3; i++) { printf(&quot;ta[%d].getValue() = %d\\n&quot;, i, ta[i].getValue()); } //从打印结果也能清晰的看出初始化时的调用函数情况 Test t = Test(100);//手工调用构造函数进行初始化 printf(&quot;t.getValue() = %d\\n&quot;, t.getValue()); } 小实例 需求：开发一个数组类解决原生数组地安全性问题 提供函数获取数组长度 提供函数获取数组元素 提供函数设置数组元素 IntArray.h #ifndef INTARRAY_H #define INTARRAY_H class IntArray{ private: int m_length; int* m_pointer; public: IntArray(int len); int length(); bool get(int index, int&amp; value); bool set(int index, int value); void free(); };//类的创建一定要加分号！！！ #endif IntArray.cpp #include &quot;IntArray.h&quot; IntArray::IntArray(int len) { m_pointer = new int[len]; for(int i = 0;i &lt; len; i++) { m_pointer[i] = 0; } m_length = len; } int IntArray::length() { return m_length; } bool IntArray::get(int index, int&amp; value) { bool ret = (0 &lt;= index)&amp;&amp;(index &lt; length()); if(ret) { value = m_pointer[index]; } return ret; } bool IntArray::set(int index, int value) { bool ret = (0 &lt;= index)&amp;&amp;(index &lt; length()); if(ret) { m_pointer[index] = value; } return ret; } void IntArray::free() { delete[] m_pointer; } main.cpp #include &lt;iostream&gt; #include &quot;IntArray.h&quot; using namespace std; int main(int argc, char *argv[]) { IntArray a(5); for(int i=0; i&lt;a.length(); i++) { a.set(i,i+1); } for(int i=0; i&lt;a.length(); i++) { int value = 0; if(a.get(i,value)) { cout &lt;&lt; &quot;a[&quot;&lt;&lt; i&lt;&lt; &quot;]= &quot; &lt;&lt;value &lt;&lt; endl; } } a.free(); return 0; } 其实这个类并不完善，以后会慢慢完善的 小结 构造哈数可以根据需要定义参数 构造函数之间可以存在重载关系 构造函数遵循C++中重载函数规则 对象定义时会触发构造函数的调用 在一些情况下可以手动调用构造函数 ","link":"https://leichen2552.github.io/post/hui-gu-18dui-xiang-de-gou-zao-zhong/"},{"title":"回顾（17）：对象的构造（上）","content":"对象的初始化 问题：对象中的成员变量初始值是多少？ 试验一下就知道了！ class Test { private: int i; int j; public: void int getI() {return i;} void int getJ() {return j;} } //类得到的其实是数据类型 Test gt;//因为存储空间在全局数据区 int main() { printf(&quot;gt.i = %d\\n&quot;,gt.getI()); printf(&quot;gt.j = %d\\n&quot;,gt.getJ()); Test t1;//因为存储空间在栈上面 printf(&quot;t1.i = %d\\n&quot;,t1.getI()); printf(&quot;t1.j = %d\\n&quot;,t1.getJ()); Test* pt = new Test; printf(&quot;pt-&gt;i = %d\\n&quot;,pt-&gt;getI()); printf(&quot;pt-&gt;j = %d\\n&quot;,pt-&gt;getJ()); delete pt; return 0; } //打印结果 //i = 0 //j = 0 //i = 1236584 //j = 1256981 //i = 0，这个0只是一个巧合 //j = 0，这个0只是一个巧合 从程序设计角度，对象只是变量，因此： 在栈上创建对象，成员变量初始为随机值 在堆上创建对象，成员变量初始为随机值 在静态存储区创建对象，成员变量初始值为0 对象如何初始化 生活中的对象都是初始化后上市的 初始状态（出厂设置）是对象普遍存在的一个状态 问题：程序中如何对一个对象进行初始化 一个public的initialize函数 一般而言，对象需要一个确定的初始状态 解决方案 再类中提供一个public的initialize函数 对象创建后理解调用initialize函数进行初始化 class Test { private: int i; int j; public: void initialize() {i = 0; j = 0;} void int getI() {return i;} void int getJ() {return j;} }; 存在的问题 initialize只是一个普通函数，必须显示调用 如果未调用initialize函数，运行结果是不确定的 通过人手工来调用这个初始化函数太麻烦了！有没有那种刚创建完对象就自动来调用初始化的函数 构造函数 C++中可以定义与类名相同的特殊成员函数 这种特殊的成员函数叫做构造函数 构造函数没有任何返回类型的声明 构造函数在对象定义时自动被调用 class Test { private: int i; int j; public: void int getI() {return i;} void int getJ() {return j;} Test() { printf(&quot;Test() Enter\\n&quot;); i = 0; j = 0; printf(&quot;Test() Exit\\n&quot;); } }; 小结 每个对象在使用之前都应该初始化 类的构造函数用于对象的初始化 构造函数与类同名并且没有返回值 构造函数在对象定义时自动被调用 ","link":"https://leichen2552.github.io/post/hui-gu-17dui-xiang-de-gou-zao-shang/"},{"title":"回顾（16）：类的真正形态","content":" 类的关键字 小实例 类的真正形态 Operator.h Operator.cpp main.cpp 小结 类的关键字 经过不停地改进，结构体struct变得越来越不像它在C语言中的样子 但是struct在C语言中已经有了自己的含义，必须继续兼容 在C++中提供了行的关键字class用于类定义 class和struct的用法是完全相同的 class和struct有什么区别呢？ 在struct定义类时，所有成员的默认访问级别是public 在class定义类时，所有成员的默认访问级别为private struct A { //default to public int i; //default to public int getI() { return i; } }; class A { //default to private int i; //default to private int getI() { return i; } }; 小实例 需求：开发一个用于四则运算的类 提供setOperator函数设置运算类型 提供setParameter函数设置运算参数 提供result函数进行运算 其返回值表示运算的合法性 通过引用参数来返回结果 类的真正形态 C++中的类支持声明和实现的分离 将类的实现和定义分开 .h头文件中只有类的声明 成员变量和成员函数的声明 .cpp源文件中完成类的其他实现 成员函数的具体实现 使用方式与实现细节相分离 Operator.h #ifndef OPEARTOR_H #define OPERATOR_H class Operator { private: char mOp; int mPa; int mPb; public: bool setOperator(char mop); bool setParameter(int mpa, int mpb); bool getresult(double&amp; r); }; Operator.cpp #include &quot;Operator.h&quot; bool Operator::setOperator(char mop) { bool ret = true; if((mop == '/') || (mop == '+')||(mop == '-')||(mop == '*')) { ret = true; mOp = mop; } else { ret = false; mOp = '\\0' } return ret; } bool Operator::setParameter(int mpa, int mpb) { mPa = mpa; mPb = mpb; } bool Operator::getresult(double&amp; r) { bool ret = true; if( mOp == '/' &amp;&amp; mPb != 0 ) { r = mPa/mPb; } else { ret = false; } if(mOp == '+') { r = mPa+mPb; } if(mOp == '-') { r = mPa-mPb; } if(mOp == '*') { r = mPa*mPb; } return ret; } main.cpp #include &lt;iostream&gt; #include &quot;Operator.h&quot; using namespace std; int main(int argc, char *argv[]) { Operator o; double r = 0; o.setOperator('/'); o.setParameter(6, 3); if(o.getresult(r)) { cout &lt;&lt; r &lt;&lt; endl; } return 0; } 小结 C++引进新的关键字class用于定义类 struct和class的区别在于默认访问级别不同 C++中的类支持声明和实现的分离 在.h头文件中声明类的使用方式 在.cpp源文件中实现类的实现细节 ","link":"https://leichen2552.github.io/post/hui-gu-16lei-de-zhen-zheng-xing-tai/"},{"title":"回顾（15）：类与封装的概念","content":" 类的组合 类通常分为以下两个部分 类的封装 封装的基本概念 C++中类的封装 类的成员作用域 小结 类就是日常生活中分类的思想 类的组合 电脑这个类是由硬盘、内存、CPU、主板这些类组成的 类通常分为以下两个部分 类的实现细节 类的使用方式 类的封装 当使用类时，不需要关心其实现细节 当创建类时，才需要考虑其内部实现细节 普通用户使用手机，只需要学习如何发短信、打电话、拍照等等 手机开发工程师，需要知道细节功能是如何实现的 封装的基本概念 根据经验，并不是类的每个属性都是对外公开的 如：女孩子不希望别人知道自己的体重和年龄 如：男孩子不希望别人知道自己的身高和收入 而一些类的属性是对外公开的 如：人的姓名，学历，国籍，等 必须在类的表示法中定义属性和行为的公开级别 类似文件系统中文件的权限 C++中类的封装 成员变量：C++中表示类属性的变量 成员函数：C++中用于表示类行为的函数 C++中可以给成员变量和成员函数定义访问级别 public：成员变量和成员函数可以在类的内部和外界访问和调用 private：成员变量和成员函数只能在类的内部被访问和调用 #include &lt;stdio.h&gt; struct Biology { bool living; }; struct Animal : Biology { bool movable; void findFood() { } }; struct Plant : Biology { bool growable; }; struct Beast : Animal { void sleep() { } }; struct Human : Animal { void sleep() { } void work() { } }; struct Girl : Human{ private: int age; int weight; public: void print() { age = 22; weight = 48; printf(&quot;I'm girl, I'm %d years old\\n&quot;,age); printf(&quot;My weight is %d kg\\n&quot;,weight); } }; struct Boy : Human{ private: int height; int salary; public: int age; int weight; void print() { height = 175; salary = 9000; age = 22; weight = 48; printf(&quot;I'm boy, my height is %d cm\\n&quot;,height); printf(&quot;My salary is %d RMB\\n&quot;,salary); } }; int main(int argc, char *argv[]) { Girl g;//从C++语言的角度：创建了一个类的对象， Boy b; g.print(); b.age = 19; b.weight = 120; b.print(); return 0; } 成员函数可以访问类的的成员变量 类的成员作用域 类成员的作用域只在类的内部，外部是无法访问的 成员函数可以直接访问成员变量和调用成员函数 类的外部可以通过类变量访问public成员 类成员的作用域与访问级别没有任何关系 C++中用struct定义的类中所有成员默认为public #include &lt;stdio.h&gt; int i = 1; struct Test { private: int i; public: int j; int getI() { i = 3; return i; } }; int main() { int i = 2; Test test; test.j = 4; printf(&quot;i = %d\\n&quot;, i); //局部 i = 2; printf(&quot;::i = %d\\n&quot;, ::i); //全局 ::i = 1; // printf(&quot;test.i = %d\\n&quot;, test.i); //不能访问 Error printf(&quot;test.j = %d\\n&quot;, test.j); //public可以访问 test.j = 4 printf(&quot;test.getI() = %d\\n&quot;, test.getI()); // test.getI() = 3， //类成员的作用域和类成员的访问级别是两个概念 return 0; } 小结 类通常可以分为使用方式和内部细节两部分 类的封装机制使得使用方式和内部细节相分离 C++中通过定义类成员的访问级别实现封装机制 public成员可以在类的背部和外界访问和调用 private成员只能在类的内部被访问和调用 ","link":"https://leichen2552.github.io/post/hui-gu-15lei-yu-feng-zhuang-de-gai-nian/"},{"title":"回顾（14）：进阶面对对象（下）","content":" 类之间的关系 类的表示法 如何让编译器读懂这些类的表示法 小结 类之间的关系 继承 从已存在细分出来的类和原类之间有继承关系 继承的类（子类）拥有原类（父类）的所有属性和行为 组合 一些类的存在必须依赖于其他的类，这种关系叫组合 组合的类在某一个局部上有其他的类组成 继承：惠普电脑、苹果电脑继承了电脑的所有属性 组合：电脑这个类需要硬盘、内存、主板、CPU这些类组合起来 类的表示法 如何让编译器读懂这些类的表示法 类的表示法 类的表示法-改进1 类的表示法-改进2 类的表示法-改进3 类的表示法-改进4 类的表示法-改进5 貌似大功告成，好像看着编译器可以识别了！ 小结 类之间课已存在继承关系或者组合关系 继承关系中子类拥有父类的一切属性和行为 组合关系是类之间整体和部分的关系 类及类之间的关系可以有不同的表示法 编译器对类的表示法有具体的要求 ","link":"https://leichen2552.github.io/post/hui-gu-14jin-jie-mian-dui-dui-xiang-xia/"},{"title":"回顾（13）：进阶面向对象（上）","content":"面向对象基本概念 面向对象的意义在于 将日常生活中习惯的思维引入程序设计中 将需求中的概念只管的映射到解决方案中 以模块为中心构建可复用的软件系统 提高软件产品的可维护性和可拓展性 类和对象是面向对象的两个基本概念 类：指的是一类事物，是一个抽象的概念 对象：指的是属于某个类的具体实体 类是一种模型。这种模型课以创建出不同的对象实体 对象实体是类模型的一个具体事例 一个类可以有很多对象，而一个对象必然属于某个类 对象就是一个具体实体，老虎分为华南虎、东北虎、孟加拉虎，这些是老虎的类别，成都动物园里的花花就是具体的对象 类和对象的意义 类用于抽象的描述一类事物所特有的属性和行为 如：电脑拥有CPU，内存和硬盘，并且课以开机和运行程序 对象是具体的事物，拥有所属类中描述一些属性和行为 如：每一只老虎都有各自的体重、食量和惰性 一些有趣的问题 类一定存在实际的对象吗？ 类的对象数目是确定的吗？ 类一定都来源于现实生活吗？ 类都是独立的吗？类之间存在关系吗？ 对象实例一定只属于一个类吗？ 对象实例可能完全相同吗？ 小结 面向对象是当今软件开发中的重要方法 类和对象是面向对象理论中的基本概念 类和对象均来源于日常生活中 每个类可以有很多对象 每个对象必然属于某个类 ","link":"https://leichen2552.github.io/post/hui-gu-13jin-jie-mian-xiang-dui-xiang-shang/"},{"title":"回顾（12）：经典问题解析一","content":"const 什么时候是只读变量？ 什么时候是常量？ const常量的判别标准 只有用字面量初始化的const常量才会进入符号表 使用其他变量初始化的const常量仍然是只读变量 被volatile修饰的const常量不会进入符号表，volatile修饰的就是易变的，是可能发生变化，可能会在外部被改变，所以通过volatile去访问这个变量就会去访问这个变量的内存。所以const修饰只是当前文件下的这个变量是只读属性 在编译期间不能直接确定初始值的const标识符，都被作为只读变量 关于const的提问 const引用的类型与初始化变量的类型 相同：初始化变量成为只读变量 不同：生成一个新的只读变量 #include &lt;stdio.h&gt; int main() { const int x = 2; const int&amp; rx = x; int&amp; nrx = const_cast&lt;int&amp;&gt;(rx); nrx = 5; printf(&quot;x = %d\\n&quot;,x); printf(&quot;rx = %d\\n&quot;,rx); printf(&quot;nrx = %d\\n&quot;,nrx); printf(&quot;&amp;x = %d\\n&quot;,&amp;x); printf(&quot;&amp;rx = %d\\n&quot;,&amp;rx); printf(&quot;&amp;nrx = %d\\n&quot;,&amp;nrx); volatile const int y = 2; int* p = const_cast&lt;int*&gt;(&amp;y) *p = 6; printf(&quot;y = %d\\n&quot;,y); printf(&quot;p = %p\\n&quot;,p); const int z = y; p = const_cast&lt;int*&gt;(&amp;z); *p = 7; printf(&quot;z= %d\\n&quot;, z); printf(&quot;p = %p\\n&quot;, p); char c = 'c'; char&amp; rc = c; const int&amp; trc = c;//这已经是一个新的只读变量了 rc = 'a'; printf(&quot;c= %d\\n&quot;, c); //a printf(&quot;rc = %p\\n&quot;, rc); //a printf(&quot;trc = %p\\n&quot;, trc); //c //const引用的类型与初始化变量的类型不同，会生成一个新的只读变量 return 0; } 引用和指针有什么关系 如何理解引用的本质就是指针常量 指针就是一个变量 值为一个内存地址，不需要初始化，可以保存不同的地址 通过指针访问对应内存地址中的值 指针可以被const修饰成为常量或者只读变量 引用只是一个变量的新名字 对引用的操作（赋值，取地址等）都会传递到代表的变量上 const引用使其代表的变量具有只读属性 引用必须在定义时初始化，之后无法代表其他变量 从不同的角度来看 从使用C++语言角度的角度来看 引用于指针没有任何的关系 引用是变量的新名字，操作引用就是操作对应的变量 从C++编译器的角度来看 为了支持新概念“引用”必须要一个有效的解决方案 在编译器内部，使用指针常量来实现引用 因此“引用”在定义时必须初始化 在工程项目开发中 当进行C++编程时，直接站在使用的角度看待引用，与指针毫无关系，引用就是变量的别名 当对C++代码进行调试分析时，一些特殊情况，可以考虑站在C++编译器的角度看待引用 #include &lt;stdio.h&gt; int a = 1; struct SV { int&amp; x; int&amp; y; int&amp; z; }; int main() { int b = 2; int* pc = new int(3); SV sv = {a, b, *pc}; int&amp; array[] = {a, b, *pc}; // &amp;array[1] - &amp;array[0] = ? Expected ==&gt; 4 /* C语言中的数组在内存中是依次顺序排放的。 当然在C++中，也是需要兼容C语言中的这个特性，但是唯有引用数组就破坏了这个特性。 比如上面的， &amp;array[1] - &amp;array[0]是不为4的，可以利用结构体SV查看x、y、z的地址。 所以说，C++中不支持引用数组！！！ */ printf(&quot;&amp;sv.x = %p\\n&quot;, &amp;sv.x); printf(&quot;&amp;sv.y = %p\\n&quot;, &amp;sv.y); printf(&quot;&amp;sv.z = %p\\n&quot;, &amp;sv.z); delete pc; return 0; } 所以说，C++中不支持引用数组！ 小结 指针是一个变量 引用就是一个变量的新名字 const引用能够生成新的只读变量 在编译器内部使用指针常量实现引用，C++中为了兼容C语言数组特性——地址之差不是所期望的，所以只能抛弃引用数组 编译时不能直接确定初始值的const标识符都是只读变量 ","link":"https://leichen2552.github.io/post/hui-gu-12jing-dian-wen-ti-jie-xi-yi/"},{"title":"回顾（11）：新型的类型转换","content":"强制类型转换 C方式的强制类型转换 ( Type ) ( Expression ) Type( Expression ) C方式强制类型转换存在的问题 过于粗暴 任意类型之间都可以进行转换，编译器很难判断其正确性 难于定位 在源代码中无法快速定位所有使用强制类型转换的语句 强制类型在实际工程中是很难完全避免的！！！ 新式类型转换 static_cast const_cast dynamic_cast reinterpret_cast static_cast 用于基本类型间的转换 不能用于基本类型指针间的转换 用于有继承关系类对象之间的转换和类指针之间的转换 void static_cast_demo() { int i = 0x12345; char c = 'c'; int* pi = &amp;i; char* pc = &amp;c; c = static_cast&lt;char&gt;(i); pc = static_cast&lt;char*&gt;(pi);//Error } const_cast 用于去除变量的只读属性 强制转换的目标类型必须是指针或引用 void const_cast_demo() { const int&amp; j = 1; int&amp; k = const_cast&lt;int&amp;&gt;(j); const int x = 2; int&amp; y = const_cast&lt;int&amp;&gt;(x); int z = const_cast&lt;int&gt;(x);//Error k = 5; printf(&quot;k = %d\\n&quot;, k); printf(&quot;j = %d\\n&quot;, j); y = 8; printf(&quot;x = %d\\n&quot;, x); printf(&quot;y = %d\\n&quot;, y); printf(&quot;&amp;x = %p\\n&quot;, &amp;x); printf(&quot;&amp;y = %p\\n&quot;, &amp;y); } reinterpret_cast 用于指针类型间的强制转换 用于整数和指针类型间的强制转换 void reinterpret_cast_demo() { int i = 0; char c = 'c'; int* pi = &amp;i; char* pc = &amp;c; pc = reinterpret_cast&lt;char*&gt;(pi); pi = reinterpret_cast&lt;int*&gt;(pc); pi = reinterpret_cast&lt;int*&gt;(i); c = reinterpret_cast&lt;char&gt;(i); //Error } dynamic_cast 用于有继承关系的类指针间的转换 用于有交叉关系的类指针间的转换 具有类型检查的功能 需要虚函数的支持 具有类型检查的功能，如果类型转换失败的话，会被转换成空指针 void dynamic_cast_demo() { int i = 0; int* pi = &amp;i; char* pc = dynamic_cast&lt;char*&gt;(pi);//Error } int main() { static_cast_demo(); const_cast_demo(); reinterpret_cast_demo(); dynamic_cast_demo(); return 0; } 小结 C方式的强制类型转换 过于粗暴 潜在的问题不易被发现 不易在代码中定位 新式类型转换以C++关键字的方式出现 编译器能够帮助检查潜在的问题 非常方便的在代码中定位 支持动态类型识别（dynamic_cast） ","link":"https://leichen2552.github.io/post/hui-gu-11xin-xing-de-lei-xing-zhuan-huan/"},{"title":"回顾（10）：C++中的新成员","content":"动态内存分配 C++中的动态内存分配 C++中通过new关键字进行动态内存申请 C++中的动态内存申请是基于类型进行的 delete关键字用于内存释放 //变量申请 Type* pointer = new Type; //...... delete pointer; //数组申请 Type* pointer = new Type[N]; //...... delete[] pointer; 怎么申请的就怎么释放！有没有[]要注意！！！ int p = new int; p = new int[10];//这句动态内存申请，并不是表示p指向的是40个字节的一片内存空间 //这样说的话，面试官会不给你过 //因为动态内存分配时，分配的可能会比你申请的空间要大 //应该这样说，p指向的内存空间至少40个字节 new关键字与malloc函数的区别 new关键字是C++的一部分 malloc是由C库提供的函数 new以具体类型为单位进行内存分配 malloc以字节为单位进行内存分配 new在申请单个类型变量时可进行初始化 malloc不具备内存初始化的特性 new关键字的初始化 int* pi = new int(1); float* pf = new float(2.0f); char* pc = new char('c'); C++中的命名空间 在C语言中只有一个全局作用域 C语言所有的全局标识符共享同一个作用域 标识符之间可能发生冲突 C++中提出了命名空间的概念 命名空间将全局作用域分成不同部分 不同命名空间中的标识符可以同名而不会发生冲突 命名空间可以相互嵌套 全局作用域也叫做默认命名空间 C++命名空间的定义 namespace Name { namespace Internal { /* */ } /**/ } C++命名空间的使用 使用整个命名空间： using namespace name; 使用命名空间中的变量： using name::varible; 使用默认命名空间中的变量： ::varible #include &lt;stdio.h&gt; namespace First { int i = 0; } namespace Second { int i =1; namespace Internal { struct P { int x; int y; }; } } int main() { using namespace First; using Second::Internal::P; printf(&quot;First::i = %d\\n&quot;, i); printf(&quot;Second::i = %d\\n&quot;, Second::i); P p = {2, 3}; printf(&quot;p.x = %d\\n&quot;, p.x); printf(&quot;p.y = %d\\n&quot;, p.y); return 0; } 小结 C++中内置的动态内存分配的专用关键字 C++中的动态内存分配可以同时进行初始化 C++中的动态内存分配时基于类型进行的 C++中命名空间概念用于解决名称冲突问题 ","link":"https://leichen2552.github.io/post/hui-gu-10czhong-de-xin-cheng-yuan/"},{"title":"回顾（9）：函数重载分析（下）","content":" 重载与指针 函数重载遇上函数指针 C++和C相互调用 注意事项 小结 问题 重载与指针 下面的函数指针将保存哪个函数的地址？ int func(int x) { return x; } int func(int a, int b) { return a +b; } int func(const char* s) { return strlen(s); } typedef int(*PFUNC)(int a);//函数指针类型为int int c = 0; PFUNC p = func; c = p(1); 函数重载遇上函数指针 将重载函数名赋值给函数指针时 根据重载规则挑选与函数指针参数列表一致的候选者 严格匹配候选者的函数类型与函数指针的函数类型 这也体现出C++是强类型的语言 注意 函数重载必然发生在同一个作用域 编译器需要用参数列表或函数类型进行函数选择 无法直接通过函数名得到重载函数的入口地址 int func(int a, int b, int c) { return a * b * c; } int func(int a, int b) { return a + b; } int main() { printf(&quot;%p\\n&quot;,(int(*)(int, int))add); printf(&quot;%p\\n&quot;,(int(*)(int, int, int))add); //下面这两句就饿没有指定函数指针的函数类型和参数列表的类型，所以肯定会报错 printf(&quot;%p\\n&quot;,add); printf(&quot;%p\\n&quot;,add); return 0; } //打印出两个函数地址不同 C++和C相互调用 实际工程中C++和C代码相互调用时不可避免的 C++编译器能够兼容C语言的编译方式 C++编译器会优先使用C++的编译的方式 extern关键字能强制让C++编译器进行C方式的编译 extern &quot;C&quot; { //do C-style compilation here } __cplusplus是C++内置的标准宏定义 __cplusplus的意义 确保C代码以统一的C方式被编译成目标文件 #ifdef __cplusplus extern &quot;C&quot;{ #endif //C code #ifdef __cplusplus } #endif 注意事项 C++编译器不能以C的方式编译重载函数 编译方式决定函数名被编译后的目标名 C++编译方式将函数名和参数列表编译成目标名 C编译方式只将函数名作为目标名进行编译 //1 int func(int a, int b, int c) { return a * b * c; } int func(int a, int b) { return a + b; } //2 extern &quot;C&quot;{ int func(int a, int b, int c) { return a * b * c; } int func(int a, int b) { return a + b; } } 利用这句g++ -c test.cpp -o test.oo将上面两部分代码进行编译后 用 nm 命令查看test.oo中的符号表，nm test.oo 结果第一部分代码能编译通过，二部分代码编译报错 所以C++编译方式将函数名和参数列表编译成目标名，C编译方式只将函数名作为目标名进行编译 小结 函数重载是C++对C的一个重要升级 函数重载通过函数参数列表区分不同的同名函数 extern关键字能够实现C和C++的相互调用 编译方式决定符号表中的函数名的最终目标名 问题 C中如何调用C++函数？ ","link":"https://leichen2552.github.io/post/hui-gu-9han-shu-chong-zai-fen-xi-xia/"},{"title":"回顾（8）：函数重载分析（上）","content":" 自然语言中的上下文 “洗”字的含义 结论 重载（overload） C++中的函数重载 函数重载 函数重载条件 编译器调用重载函数的准则 函数重载本质 小结 自然语言中的上下文 “洗”字的含义 洗衣服、洗脑、洗车、洗脸、洗马桶 结论 能和“洗”字搭配的词汇有很多 “洗”字和不同的词汇搭配有不同的含义 重载（overload） 同一个标识符在不同的上下文有不同的意义 如： “洗”字和不同的词汇搭配有不同的含义： 洗衣服、洗脑、洗车、洗脸、洗马桶。。。 “play”和不同的单词搭配后有不同的含义：play chess, play piano, play basketball, ... 思考： 重载在自然语言中随处可见的，那在程序设计中是否也有重载呢？ C++中的函数重载 函数重载 用同一个函数名定义不同的函数 当函数名和不同参数搭配时函数的含义不同 其实不止在C++中，在java、D语言、C#中，重载都是这么定义的 int func(int x) { return x; } int func(int a, int b) { return a + b; } int func(const char* s) { return strlen(s); } 函数重载条件 参数个数不同 参数类型不同 参数顺序不同 int func(int a, const char* s) { return a; } int func(const char* s, int a) { return strlen(s); } //以上两个函数可以构成重载 问题： 当函数默认参数遇上函数重载会发生什么？ int func(int a, int b, int c = 0) { return a * b *c } int func(int a, int b) { return a + b; } int main() { int c = func(1, 2);// which one? return 0; } //编译器编译出错，就是编译器抱怨了，因为编译器不知道该去匹配哪个函数，出现了二义性！！！ //C++中有很多特性都是冲突的，所以我们要知道如何去避开这些特性冲突 编译器调用重载函数的准则 将所有同名函数作为候选者 尝试寻找可行的候选函数 精确匹配实参 通过默认参数能够匹配实参 通过默认类型转换匹配实参 匹配失败 最终寻找到的候选函数不唯一，则出现二义性，编译失败 无法匹配所有候选者，函数未定义，编译失败 函数重载本质 重载函数在本质上是相互独立的不同函数 重载函数的函数类型不同 函数返回值不能作为函数重载的依据 函数重载是由函数名和参数列表决定的，跟函数返回值没有半毛钱关系! int func(int a, int b, int c) { return a * b * c; } int func(int a, int b) { return a + b; } int main() { printf(&quot;%p\\n&quot;,(int(*)(int, int))add); printf(&quot;%p\\n&quot;,(int(*)(int, int, int))add); return 0; } //打印出两个函数地址不同 小结 函数重载是C++中引入的概念 函数重载用于模拟自然语言中的词汇搭配 函数重载使得C++具有更加丰富的语义表达能力 函数重载的本质为相互独立的不同函数 C++中通过函数名和函数参数确定究竟调用那一个函数 ","link":"https://leichen2552.github.io/post/hui-gu-8han-shu-chong-zai-fen-xi/"},{"title":"回顾（7）：函数参数拓展","content":"函数参数的默认值 C++中可以在函数声明时为参数提供一个默认值 当函数调用时没有提供参数的值，则使用默认值 int mul(int x = 0);//提供一个参数默认值 int main() { printf(&quot;%d\\n&quot;, mul()); //mul(0) return 0; } int mul(int x) { return x*x; } 参数默认值必须在函数声明中指定，那么问题来了 问题： 函数定义是否可以出现函数参数的默认值？ 当函数声明和定义中的参数默认值不同会发生什么？ int mul(int x = 0); //... int mul(int x = 5) { return x*x; } 函数参数默认值只能在声明时设置 函数默认参数的规则 参数默认值必须从右向左提供 函数调用时使用了默认值，则后续参数必须使用默认值 int add(int x, int y = 1, int z = 2) { return x + y+ z; } add(0); //x = 0 add(2, 3); //x = 2, y = 3 add(3, 2, 1); //x = 3, y = 2, z = 1 C++是强类型语言 函数的占位参数 占位参数只有参数类型声明，而没有参数名声明 一般情况下，在函数体内部无法使用占位参数 int func(int x, int) { return x; } // ... func(1, 2); 函数占位参数的意义 占位参数与默认参数结合起来使用 兼容C语言程序中可能出现的不规范写法 举个例子： #include &lt;stdio.h&gt; void func() { } int main() { func(); func(1, 2); return 0; } //这部分代码在C语言里是可以编译通过的 但是移植到C++环境里面，是编译不通过的，但是C++为了兼容C语言 #include &lt;stdio.h&gt; void func(int = 0, int = 0) { } int main() { func(); func(1, 2); return 0; } 小结 C++中支持函数参数的默认值 如果函数调用时没有提供参数，则使用默认值 参数的默认值必须从右向左提供 函数调用使用了默认值，则后续参数必须使用默认值 C++中支持占位参数，用于兼容C语言中的不规范写法 ","link":"https://leichen2552.github.io/post/hui-gu-7han-shu-can-shu-tuo-zhan/"},{"title":"回顾（6）：内联函数分析","content":" 常量与宏回顾 问题： 内联函数 内联函数特性 内联函数初探 内联请求 C++中inline内联编译的限制 常量与宏回顾 C++中的const常量可以代替宏常数定义，如： const int A = 3; ←→\\leftarrow\\rightarrow←→#define A 3 问题： C++中是否有解决方案代替宏代码片段呢？ 内联函数 宏代码块使用会有副作用的 C++中推荐使用内联函数代替宏代码片段 C++中使用inline关键字声明内联函数 内联函数声明时inline关键字必须和函数定义结合在一起，否则编译器会直接忽略内敛请求，这只是一种请求，编译器也可以拒绝 inline int func(int a, int b) { return a &lt; b ? a : b } 内联函数特性 C++编译器可以将一个函数进行内敛编译 被C++编译器内联编译的函数叫做内联函数 C++编译器直接将函数体插入函数调用的地方 内联函数没有普通函数调用时的额外开销（压栈、跳转、返回） C++编译器不一定满足函数的内敛请求 内联函数初探 #include &lt;stdio.h&gt; #define FUNC(a,b) ((a) &lt; (b) ? (a) : (b)) inline int func(int a, int b) { return a &lt; b ? a :b } int main() { int a = 1; int b = 3; int c = FUNC(++a, b); printf(&quot;a = %d\\n&quot;, a); printf(&quot;b = %d\\n&quot;, b); printf(&quot;c = %d\\n&quot;, c); return 0; } //如果调用FUNC(a, b)，打印3, 3, 3 //如果调用func(a, b)， 打印2, 3, 3 内联函数具有普通函数的特征（参数检查，返回类型） 函数的内联请求可能被编译器拒绝 函数被内联编译后，函数体直接扩展到调用的地方 宏代码片段由预处理处理，进行简单的文本替换，没有任何编译过程，因此可能出现副作用 内联请求 现代C++编译器能够进行编译优化，一些函数即使没有inline声明，也可能被内联编译 一些现代C++编译器提供了扩展语法，能够对函数进行强制内联，如： g++：__attribute__((always_inline))属性 MSVC：__forceinline C++中inline内联编译的限制 不能存在任何形式的循环语句 不能存在过多的条件判断语句 函数体不能过于庞大 不能对函数进行取址操作 函数内联声明必须在调用语句之前 #小结 内联函数的提出是为了替代宏代码块的，原因是高效 C++中可以通过inline声明内联函数 编译器直接将内联函数体扩展到函数调用的地方 inline只是一种请求，编译器不一定允许这种请求 内联函数省去了函数调用时的压栈、跳转和返回的开销 ","link":"https://leichen2552.github.io/post/hui-gu-6nei-lian-han-shu-fen-xi/"},{"title":"回顾（5）：引用本质分析","content":"C++中的引用 引用的意义 引用作为变量别名而存在，因此在一些场合可以代替指针 引用相对于指针来说具有更好的可读性和实用性 Example：Swap函数的实现对比 void Swap(int&amp; a, int&amp; b) { int t = a; a = b; b = t; } void Swap(int* a, int* b) { int t = *a; *a = *b; *b = t; } 这两种就好像手动挡的车与自动挡的车，自动挡的车好开，这就好比是引用 注意： 函数的引用形参不需要进行初始化，它的初始化发生在函数调用的时候 特殊的引用 const引用 在C++中可以声明const引用 语法：const Type&amp; name = var; const 引用让变量拥有只读属性 int a = 4; const int&amp; b = a; int* p = (int*)&amp;b; b = 5; // Error，只读变量 *p = 5; //OK，修改变量 a 的值 现在已经知道引用是另一个变量的别名，因此一个引用绝对不可能是常量值的别名。换句话说，就是不能定义一个引用然后用常量值来初始化，这里的常量是字面常量，因为从概念上来说是不可行的。但是有一个例外，就是const引用，我么可以用字面常量来对一个const引用初始化，编译器这个时候就会真真正正产生一个只读变量。 const int&amp; b = 1; //ok int* p = (int*)&amp;b; b = 5; //Error，只读变量 *p = 5; //OK，修改变量 b 的值 当使用常量对const引用进行初始化时，C++编译器会为这个常量分配空间，并将引用名作为这段空间的别名 结论：使用常量对const引用初始化后将生成一个只读变量 引用有自己的存储空间吗 小测试： #include &lt;stdio.h&gt; struct TRef { char&amp; r; }; int main() { char c = 'c'; char&amp; rc = c; TRef ref = {c}; printf(&quot;sizeof(char&amp;) = %d\\n&quot;,sizeof(char&amp;)); //1 printf(&quot;sizeof(rc) = %d\\n&quot;,sizeof(rc)); //1 printf(&quot;sizeof(TRef) = %d\\n&quot;,sizeof(TRef)); //4 printf(&quot;sizeof(ref.r) = %d\\n&quot;,sizeof(ref.r)); //1 return 0; } 引用的本质 引用在C++内部实现是一个指针常量 Type&amp; name ←→\\leftarrow \\rightarrow←→ Type* const name void f(int&amp; a) void f(int* const a) { { a = 5; *a = 5 } } 注意： C++编译器在编译过程中用指针常量作为引用的内部实现，因此引用所占的空间大小与指针相同 从使用的角度，引用只是一个别名，C++为了实用性而隐藏了引用的存储空间这一细节 引用的意义 C++中的引用旨在大多数情况下代替指针 功能性：可以满足多数需要使用指针的场合 安全性：可以避开由于指针操作不当而带来的内存错误 操作性：简单易用，又不失功能强大 实例解读 不能返回局部变量的引用 int&amp; demo() //int* const { int d = 0; printf(&quot;demo : d = %d\\n&quot;, d); return d; //return &amp;d，返回一个局部变量的地址就是有问题 } 可以返回在全局存储区内变量的引用 int&amp; func() //int* const { static int s = 0; printf(&quot;func : s = %d\\n&quot;, s); return s; //return &amp;s，静态的局部变量的存储空间是一个全局的存储区， //所以说它的空间不会以为函数调用而摧毁，由于引用的本质是指针， //所以返回一个全局存储区中的地址是完全可以的 } #小结 引用作为别名而存在旨在代替指针 const引用可以使得变量具有只读属性 引用在一起内部使用指针常量实现 引用的最终本质为指针 引用尽可能的避开内存错误 ","link":"https://leichen2552.github.io/post/hui-gu-5yin-yong-ben-zhi-fen-xi/"},{"title":"回顾（4）：布尔类型和引用","content":" C语言中的布尔类型 C++中的布尔类型 布尔类型的值 布尔类型 布尔类型是C++中的基本数据类型 三目运算符 C++对三目运算符进行了升级 C语言中的三目运算符返回的是变量值 C++中的三目运算符返回的是变量本身（注意是变量本身） C++中的引用 变量名回顾 C++对三目运算符做了什么 小结 C语言中的布尔类型 C语言中没有布尔类型 C++中的布尔类型 C++在C语言的基础类型系统里增加了bool C++中的bool可取的值只有true和false 理论上bool只占用了一个字节 注意： true代表真值，编译器内部用1来表示 false代表非真值，编译器内部用0来表示 C++的两个加号，一个加号就是类型上面的增强，另一个加号就是面向对象的加强 所以C语言中没有的布尔类型，在C++中就提供了这种bool类型 布尔类型的值 bool类型只有true（非0）和false（0）两个值 C++编译器会将非0值转换为true，0值转换为false //下面的代码会输出什么？ bool b = 0; printf(&quot;b = %d&quot;,b);//0 b++; printf(&quot;b = %d&quot;,b);//1 b = b - 3; printf(&quot;b = %d&quot;,b);//1 但是C++中的布尔类型的内部实现还是用一个字节(byte)的整型来实现的。 #include &lt;stdio.h&gt; int main() { bool b = false; int a = b; printf(&quot;sizeof(b) = %d\\n&quot;, sizeof(b));//1 printf(&quot;b = %d, a = %d&quot;, b, a);//0,0 b = 3; a = b; printf(&quot;b = %d, a = %d&quot;, b, a);//1,1 b = -5; a = b; printf(&quot;b = %d, a = %d&quot;, b, a);//1,1 a = 10; b = a; printf(&quot;a = %d, b = %d&quot;, a, b);//10,1 a = 0; b = a; printf(&quot;a = %d, b = %d&quot;, a, b);//0,0 return 0; } 布尔类型 布尔类型是C++中的基本数据类型 可以定义bool类型的全局变量 可以定义bool类型的常量 可以定义bool类型的指针 可以定义bool类型的数组 其他基本类型能干的事情，bool类型都能干 三目运算符 C++对三目运算符进行了升级 #include &lt;stdio.h&gt; int main() { int a = 1; int b = 2; (a &lt; b ? a : b) = 3;//等价于a = 3; printf(&quot;a = %d, b = %d\\n&quot;, a, b); } C语言中的三目运算符返回的是变量值 不能作为左值使用 C++中的三目运算符返回的是变量本身（注意是变量本身） 既可以作为右值使用，又可以作为左值使用 牢记： 三目运算符就只有在所有的可能返回都是变量的时候才能作为左值使用 如果混搭，编译器就会报错，像如下： int a = 1; int b = 2; (a &lt; b ? a : 2) = 3;//这句就会报错 注意： 三目运算符可能返回的值中如果有一个常量值，则不能作为左值使用 C++中的引用 变量名回顾 变量是一段实际连续存储空间的别名 程序是通过变量来申请并命名存储空间 通过变量的名字可以使用存储空间 问题：一段连续的存储空间只能有一个别名吗？答案：不一定 ###在C++中新增加了引用的概念 引用可以看做是一个已定义变量的别名 引用的语法：Type&amp; name = var; int a = 4; int&amp; b = a;//b为a的别名 b = 5; //操作b就是操作a 注意： 普通引用在定义时必须用同类型的变量进行初始化。初始化一定是其他同类型（一定要同类型，不然编译器报错）变量的别名，不能用字面常量进行初始化（不然编译器报错） #include &lt;stdio.h&gt; int main() { int a = 4; int&amp; b = a; printf(&quot;a = %d\\n&quot;, a); printf(&quot;b = %d\\n&quot;, b);//a、b值一样 printf(&quot;&amp;a = %p\\n&quot;, &amp;a); printf(&quot;&amp;b = %p\\n&quot;, &amp;b);//a、b地址也一样 } C++对三目运算符做了什么 当三目运算符的可能返回都是变量时，返回的就是变量引用 当三目运算府的可能返回中有常量时，返回的是值 int a = 1; int b = 2; (a &lt; b ? a : b) = 3;//正确，返回 a 或 b 的引用，可作为左值 (a &lt; b ? a : b) = 4;//错误，返回 1 或 b 的值，不能作为左值 小结 bool类型是C++新增加的基础类型 bool类型的值只能是true和false C++中的三目运算符可作为左值使用 C++中的引用可以看做是变量的别名来使用 三目运算符的可能返回都是变量时，返回的是引用 ","link":"https://leichen2552.github.io/post/hui-gu-4bu-er-lei-xing-he-yin-yong/"},{"title":"回顾（3）：进化后的const分析","content":" 进化后的const分析 C语言中的const C++语言中的const C语言中的const变量 C++中的const变量 小结 进化后的const分析 C语言中的const const修饰的变量是只读的，本质还是变量 const修饰的局部变量在栈上分配空间 const修饰的全局变量在只读存储器分配空间 const只在编译器有用，在运行期无用 const修饰的变量不是真正的常量，它只告诉编译器该变量不能出现在赋值符号的左边 C语言中的const使得变量具有只读属性 const将具有全局生命周期的变量存储于只读存储区 const不能定义真正意义上面的常量！ C语言上定义真正意义上的常量只能用枚举 C++语言中的const C++在C的基础上对const进行了进化处理 当碰见const声明时在符号表中放入常量 编译过程中若发现使用常量则直接以符号表中的值替换 编译过程中若发现下述情况则给对应的常量分配存储空间 对const常量使用了extern 对const常量使用&amp;操作符 C++编译器虽然可能为const分配空间，但不会使用其存储空间的值 C语言中的const变量 C语言中的const变量是只读变量，本质仍然是变量，会分配存储空间 C++中的const变量 可能会分配存储空间。当const常量为全局，并且需要其他文件中使用。当使用 &amp; 操作符对const常量取地址 C++中的const常量类似于宏定义。const int c = 5;≈\\approx≈#define c 5 C++中的const常量在与宏定义不同。const常量是由编译器处理，编译器对const常量进行类型检查和作用域检查 宏定义由预处理器处理，单纯的文本替换 小结 与C语言不同，C++中的const不是只读变量，而C语言中const只带了只读属性，本质上还是一个变量。 C++中的const是一个真正意义上的常量 C++编译器可能会为const常量分配空间 C++完全兼容C语言const常量的语法特性 ","link":"https://leichen2552.github.io/post/hui-gu-3jin-hua-hou-de-const-fen-xi/"},{"title":"回顾（2）：C到C++的升级","content":" C与C++的关系 C到C++的升级 变量定义 register关键字 全局变量的定义 struct关键词的加强 C语言中的struct C++中的struct int f()与int f(void)的区别 类型 在C语言中 在C++中 小结 C与C++的关系 C++继承了所有的C特性 C++在C的基础上提供了更多的语法和特性 C++的设计目标是运行效率与开发效率的统一 以C语言为基础，+面对对象支持，+类型加强、函数加强、异常处理等等 = C + + C到C++的升级 变量定义 C++更强调语言的实用性 所有变量都可以在需要使用时在定义，对比C语言中的所有变量必须在作用域开始的位置定义 register关键字 register关键字请求编译器将局部变量存储在寄存器中，在C++中依然支持register关键字，但是在C++编译器有自己的优化方式，C语言中无法获取register变量的地址，C++中可以取得register变量的地址 C++编译器发现程序中需要取register变量的地址时，register对变量的声明变得无效 在早期C语言编译器不会对代码进行优化，因此register变量是一个很好的补充 全局变量的定义 在C语言中，重复定义多个同名的全局变量是合法的。C语言中多个同名的全局变量最终会被链接到同一个地址空间上 在C++中，不允许定义多个同名的全局变量 struct关键词的加强 C语言中的struct定义了一组变量的集合 C语言中的struct定义的标识符并不是一种新的类型 C++中的struct用于定义一个全新的类型 C语言中的struct struct _tag_student//这只是定义一个标签，并不是一个全新的类型 { const char* name; int age; } ; typedef struct _tag_student Student;//C语言只是利用typedef把一个标签变成一个类型， //只是当做一个类型来用，而C语言并不认为Student是一个类型 C++中的struct struct Student//直接就是一个全新的类型 { const char* name; int age; }; int f()与int f(void)的区别 类型 C++中所有的标识符都必须显示的声明类型 C语言中的默认类型在C++中是不合法的 f(i) { printf(&quot;i = %d\\n&quot;,i); } g() { return 5; } //函数f的返回值和参数分别是什么类型？函数在没有给出返回值时，默认类型为int //函数g可以接受多少个参数？任意多的参数 思考题：int f() 与 int f(void)有什么区别？ 解答：他们有没有区别看什么编译器 如果是C语言编译器，那么f()f()f()就是接受任意多的参数，并且返回值是int类型的函数，f(void)f(void)f(void)是不接收参数并且返回值是int类型的函数 如果是C++编译器，那它们两个就没什么区别 在C语言中 int f() 表示返回值为int类型，接受任意参数的函数 f(void)表示返回值为int的无参函数 在C++中 int f() 和 int f(void)具有相同的意义，表示返回值为int的无参函数 小结 C++更强调实用性，可以在任意地方声明变量 C++中的register只是一个兼容的作用，C++兼容C语言只是为了兼容C语言，因为C++有自己的优化方式，他不需要register这个关键字来指示优化 C++编译器能够更好的进行优化 C++中任意的标识符都必须显示的指明类型 ","link":"https://leichen2552.github.io/post/hui-gu-2/"},{"title":"回顾（1）：学习C++的意义","content":" 常见观点： 软件方法论的发展 面向过程的程序设计 面向对象的程序设计 是否需要新的语言 C语言的加强 小结 常见观点： 操作系统和驱动程序都是C写的，学好C就够了 C++在应用层用的多，学嵌入式没有必要 linus大神认为C++一无是处，还学它干嘛 我以后就做驱动开发，没有精力也没有必要学C++ Unix诞生之初是汇编语言写的，但是汇编语言的开发效率太低。 所以两个大神对B语言进行改进，C语言就诞生了！ C语言的诞生只是为了开发操作系统，所以C语言里有很多灰色地带。 软件方法论的发展 面向过程的程序设计 特点 分析解决问题所需要的步骤 利用函数实现各个步骤 依次调用函数解决问题 问题 软件可重用性差 软件可维护性差 面向对象的程序设计 将现实中的事物直接映射到程序中去，可直接满足用户需求 特点： 直接分析用户需求中涉及的各个实体 在代码中描述显示师姐中的实体 在代码中关联各个实体协同工作解决问题 优势： 构建的软件能够适应用户需求的不断变化 直接利用面向过程方法的优势而避开其劣势 是否需要新的语言 高效的面对对象语言，并且能够兼容已经存在的代码。 C语言 + 面向对象方法论，Obiective-C，C++ C语言的加强 C语言和C++并不是对立竞争的关系 C++是C语言的加强，是一种更好的C语言 C++是以C语言为基础的，并且完全兼容C语言的特性 小结 所有的软件系统都是为了满足用户需求开发的 对于一个团队而言，在短期内内开发出用户满意的软件系统是其核心竞争力的体现 对于一个开发者而言，能够胜任系统中的任意一个模块的开发是其核心价值的体现 对于一个架构师的而言，掌握各种语言的优势并合理运用到系统中，由此化繁为简，是其核心价值的体现 ","link":"https://leichen2552.github.io/post/xue-xi-cde-yi-yi/"},{"title":"ESP8266入门体验","content":"由于项目需要把有线传输改成无线传输，蓝牙传输容易丢包，所以就用现在很火的WiFi芯片——ESP8266。 前前后后购置了三样东西 随机打开安信可串口调试助手，发送AT+RST，一定要先发这个保证初始化。 看到最后的ready。这时，固件启动完成。 中间有一串乱码，这串乱码可以再74880的波特率下查看系统日志信息。 rst cause : 红框种的数值 1 上电 2 外部复位 3 硬件看门狗复位 Boot mode : 启动模式后面有两个参数，只看第一个参数即可 1 下载模式 3 运行模式 chksum : chksum和csum值相等，表明启动过程中flash读值准确 ","link":"https://leichen2552.github.io/post/esp8266-ru-men-ti-yan/"},{"title":"markdownNotes","content":"目录 Markdown 笔记 生成目录 代码高亮 无序标号和有序标号 文字加粗 斜体字 自定义字体大小 字体变大变小标签 换行 字体大小与颜色 表格 latex 笔记 latex调大字体 积分号、下标、上下限 罗马字符 Markdown 笔记 生成目录 @[toc] 或者 [toc] 代码高亮 tab键上面的的那个按键 ```C ``` void function1() \\\\就是C语言高亮 { } 无序标号和有序标号 星号*加一个空格 我 爱 RTOS 数字后面一个点再一个空格 我 爱 RTOS 文字加粗 **这时加粗字体** 斜体字 *这是斜体字* 自定义字体大小 我是变大字体 字体变大变小标签 字体变小 字体变大 换行 空格+空格+回车 字体大小与颜色 我是黑体字 我是微软雅黑 我是华文彩云 color=#0099ff size=72 face=&quot;黑体&quot; color=#00ffff color=gray 表格 | 一个普通标题 | 一个普通标题 | 一个普通标题 | | ------ | ------ | ------ | | 短文本 | 中等文本 | 稍微长一点的文本 | | 稍微长一点的文本 | 短文本 | 中等文本 | 一个普通标题 一个普通标题 一个普通标题 短文本 中等文本 稍微长一点的文本 稍微长一点的文本 短文本 中等文本 latex 笔记 latex调大字体 七号 5.25pt 1.845mm \\tiny 六号 7.875pt 2.768mm \\scriptsize 小五号 9pt 3.163mm \\footnotesize 五号 10.5pt 3.69mm \\small 小四号 12pt 4.2175mm \\normalsize 四号 13.75pt 4.83mm \\large 三号 15.75pt 5.53mm \\Large 二号 21pt 7.38mm \\LARGE 一号 27.5pt 9.48mm \\huge 小初号 36pt 12.65mm \\Huge 积分号、下标、上下限 \\Large {\\int_{birth}^{death} study dtime = life} ∫birthdeathstudydtime=life\\Large {\\int_{birth}^{death} study dtime = life} ∫birthdeath​studydtime=life 罗马字符 首先展示几个小写的罗马数字： \\romannumeral1 \\romannumeral3、 \\romannumeral6； 下面看对应的大写罗马数字： \\uppercase\\expandafter{\\romannumeral1}、 \\uppercase\\expandafter{\\romannumeral3}、 \\uppercase\\expandafter{\\romannumeral6}。 更新会继续添加！ ","link":"https://leichen2552.github.io/post/markdownnotes/"},{"title":"从0到1写RTOS","content":"目录 从0到1写RTOS 单任务系统的弊端 引入RTOS Cortex-M3内核机制 RTOS中的任务 任务的表征 任务的栈 任务的定义 任务的初始化 任务的切换 &quot;tinyOS.h&quot; &quot;switch.c&quot; &quot;main.c&quot; 任务切换机制 实现两个任务的切换 双任务延时原理与空闲任务 tinyOS.h main.c 对于共享资源的保护 临界区保护 调度锁保护 位图数据结构实现任务优先级 任务的延时队列 支持任务同优先级 任务的挂起 任务信息的查询 事件控制块的实现 计数信号量的实现 邮箱的实现 存储块的实现 事件标志组的实现 互斥信号量的实现 软件定时器的实现 堆栈测量的检测 CPU使用量检测 内核裁剪 Hooks拓展 从0到1写RTOS 在这非常感谢某个大佬出的《从0到1写RTOS》的教程，本文只是个人的学习总结。基于Cortex-M3实现一个微型的实时操作系统内核，主要适用于那些以Cortex-M3为内核的硬件平台，比如STM32、LPC等等。现在市场上也不乏有一些优秀的嵌入式实时操作系统，大多收费，免费的像Freertos、RT-thread，但是这些系统已经高度封装并且集成化，初学者一般见到就直接放弃，很难上手。所以笔者的这篇学习总结简述了更易学习的tinyOS，用一句成语来说——麻雀虽小五脏俱全，它不到2000行代码，具有实时操作系统应有的功能模块，比如事件控制块、计数信号量、互斥信号量等等。同时也希望大家能更快学习这个系统！ 单任务系统的弊端 单任务系统即裸机程序，也就是说平时说的前后台程序，这种程序是把所有的完成某一功能的函数都放在一个while循环里面，在这个循环里面完成所有的处理，有的时候还需要一些中断来完成一些处理。但是单任务系统的实时性非常差，所有的任务都是排着队轮流执行，但是有的任务需要实时性非常高，有的任务则不需要，单任务系统的弊端就一点点地显现出来。 int flag1; int flag2; int flag3; void function1() { flag1 = 0; delay(); flag1 = 1; delay(); } void function2() { flag1 = 0; delay(); flag1 = 1; delay(); } void function3() { flag1 = 0; delay(); flag1 = 1; delay(); } void main() { while(1) { function1(); function2(); function3(); } } 看上面的这的小工程，完成这个工程需要顺序执行三个函数——function1()、function2()和function3()，并且是顺序执行，要执行function3()就必须等待function1()和function2()的delay()函数延时结束。从这点就能看出这个顺序执行方式真的不行。 做硬件开发的人应该知道，为了提高实时性，可以使用定时器中断，把实时性需求很高的函数放入定时器中断服务函数里面，这样就能看成是function3()在与主循环中的函数在并行运行。但是硬件资源有限，可移植性也不高。这时就需要介绍实时性操作系统（RTOS）。 引入RTOS 因为单任务系统的弊端，就需要多任务系统（以下称RTOS）来解决这些弊端。打个比方：RTOS就像孙悟空的分身术，把一个自己变成十个，让这十个自己去完成不同的任务。但是我们的硬件内核Cortex-M3只有一个内核，并没有分身术，不能变出来十个，但是我们可以通过一些手段，让Cortex-M3看起来像是虚拟出来另外九个核，并发地处理不同的任务。其实这里的并发处理任务不是说同一时刻执行不同的任务，而是每个任务的执行时间间隔非常短，看起来像是同一时间执行了很多任务。这里就出现一个大问题，什么时刻执行什么任务，什么任务先执行，什么任务后执行，这个功能模块在RTOS里面叫做调度器，这个下面会说，它的作用就是合理地进行每个任务的调度。 Cortex-M3内核机制 这个调度就是合理地切换任务，Cortex-M3内核提供了一种机制用来切换前后任务——PendSV异常。 PendSV 的典型使用场合是在上下文切换时（在不同任务之间切换）。例如，一个系统中有两个就绪的任务，上下文切换被触发的场合可以是： 执行一个系统调用。 系统滴答定时器（SYSTICK）中断,（轮转调度中需要）。 让我们举个简单的例子来辅助理解。假设有这么一个系统，里面有两个就绪的任务，并且通过 SysTick 异常启动上下文切换。 上图是两个任务轮转调度的示意图。但若在产生 SysTick 异常时正在响应一个中断，则SysTick异常会抢占其ISR。在这种情况下，OS不得执行上下文切换，否则将使中断请求被延迟，而且在真实系统中延迟时间还往往不可预知——任何有一丁点实时要求的系统都决不能容忍这种事。因此，如下图：在CM3中也是严禁没商量——如果OS在某中断活跃时尝试切入线程模式，将触犯用法fault异常。 为解决此问题，早期的OS大多会检测当前是否有中断在活跃中，只有没有任何中断需要响应时，才执行上下文切换（切换期间无法响应中断）。然而，这种方法的弊端在于，它可以把任务切换动作拖延很久（因为如果抢占了IRQ，则本次SysTick在执行后不得作上下文切换，只能等待下一次SysTick异常），尤其是当某中断源的频率和SysTick异常的频率比较接近时，会发生“共振”。 现在好了，PendSV来完美解决这个问题了。PendSV异常会自动延迟上下文切换的请求，直到其它的ISR都完成了处理后才放行。为实现这个机制，需要把PendSV编程为最低优先级的异常。如果OS检测到某IRQ正在活动并且被 SysTick 抢占，它将悬起一个PendSV异常，以便缓期执行上下文切换。 这个过程中的事件的流水账记录如下： 1. 任务 A 呼叫 SVC 来请求任务切换（例如，等待某些工作完成）； 2. OS 接收到请求，做好上下文切换的准备，并且 pend 一个 PendSV 异常； 3. 当 CPU 退出 SVC 后，它立即进入 PendSV，从而执行上下文切换； 4. 当 PendSV 执行完毕后，将返回到任务 B，同时进入线程模式； 5. 发生了一个中断，并且中断服务程序开始执行； 6. 在 ISR 执行过程中，发生 SysTick 异常，并且抢占了该 ISR； 7. OS 执行必要的操作，然后 pend 起 PendSV 异常以做好上下文切换的准备； 8. 当 SysTick 退出后，回到先前被抢占的 ISR 中， ISR 继续执行； 9. ISR 执行完毕并退出后， PendSV 服务例程开始执行，并且在里面执行上下文切换； 10. 当 PendSV 执行完毕后，回到任务 A，同时系统再次进入线程模式。 以上PendSV介绍来自《Cortex-M3权威指南》，喜欢研究内核的读者可以去看看！ 介绍完了这个内核机制，我么就知道Cortex-M3提供了一种完美的切换任务的方法，在这个方法的基础上来完善RTOS。 RTOS中的任务 有了RTOS的简介和PendSV异常，还差一些东西——就是任务。任务可是RTOS中最重要的东西。 任务的表征 RTOS中的任务，如代码所示：一个任务表征就是一个永不返回的函数。其实我第一眼看到这么个东西的时候，我的内心是疑惑的，明明是一个死循环的函数，却可以被切换到另外一个任务，到底是怎么切换的，这个在下面会说。 int taskFlag; void taskEntry(void* param) { for(;;) { taskFlag = 0; delay(); taskFlag = 1; delay(); } } 这个任务中利用延时函数和改变taskFlag的数值来模拟任务的运行。 一个任务的执行会包含许多东西，比如栈、堆、数据区、代码区，这些都是在任务执行时状态数据，数据区和代码区由编译器自动分配，栈和堆可以由程序员分配。当CPU在执行这个任务的时候，是无法顾及其他任务的的，这也就是我们通常说的”该任务占据了CPU的使用权“，或者说”CPU被当前任务占有，无暇他顾“。当任务占据CPU的时候，Cortex-M3内核寄存器会在某些时刻把这些数据保存到栈中，那么每个任务都需要各自独立的栈空间，但是Cortex-M3硬件上只支持两个栈空间，这个问题该如何解决？ 任务的栈 所谓栈就是一片连续的内存空间（类似C语言中的数组：int stack[1024] = {0}），就像你买了一套房子，你可以在这个房子里面吃饭睡觉，这个房子就相当于栈。RTOS需要每个任务拥有自己单独的栈，就是每个任务有属于自己单独的活动空间，也就是说每个任务有属于自己的内存空间。这个内存空间用于保存这个任务所有的独立数据。当每个任务拥有了自己独立的栈，这时候就进行任务初始化了。 任务的定义 前面我们说了一个任务表征就是一个永不返回的函数。但是一个任务到底应该包含那些东西呢，我们定义一个任务结构体，并利用typedef重新命名一个栈类型，目前任务的结构体里面只有栈这一个成员变量，以后如果需要还会继续添加成员变量。这是C语言面向对象的编程思想，用一个结构体来统一管理某类对象。 // Cortex-M的堆栈单元类型：堆栈单元的大小为32位，所以使用uint32_t typedef uint32_t tTaskStack; // 任务结构：包含了一个任务的所有信息 typedef struct _tTask { // 任务所用堆栈的当前堆栈指针。每个任务都有他自己的堆栈，用于在运行过程中存储临时变量等一些环境参数 // 在tinyOS运行该任务前，会从stack指向的位置处，会读取堆栈中的环境参数恢复到CPU寄存器中，然后开始运行 // 在切换至其它任务时，会将当前CPU寄存器值保存到堆栈中，等待下一次运行该任务时再恢复。 // stack保存了最后保存环境参数的地址位置，用于后续恢复 tTaskStack * stack; }tTask; 任务的初始化 之前上面提到，任务在占据CPU运行的时候，Cortex-M3内核会保存任务的运行状态到任务自己的内存空间也就是栈里面，但是对于那些从未占据过CPU的任务，CPU如何取出该任务的运行状态并运行呢？ 其实在想这个问题的时候，很多人都苦恼怎么做，在看了下面代码的时候，又苦恼为什么要这么做？这是一个追本溯源的过程。打个比方，当这个世界上没有实时操作系统只有裸机程序和中断的时候，当时的人们肯定也苦恼这个问题，后来有一个人想到了解决这个问题的办法。 然而我们现在作为学习者，想明白人家为什么这么做，然后举一反三就可以了。再回到刚才那个问题，CPU如何取出该之前从未被执行的任务的运行状态并运行呢？答案就是我们做一个“虚假的”现场给CPU，然后使用这个现场来恢复。 因为Arm采用的是满降栈模式，我们从栈顶逐一向下做一个虚假的现场。 这个虚假的现场包含哪些信息呢？ 1. xPSR状态寄存器的值：《CM3权威指南》里有详细描述 2. 程序的入口地址 3. 传给程序的入口参数 4. 栈的地址 我们把这些设置好，CPU就能从这个虚假的地址开始执行任务，xPSR来自《CM3权威指南》，读者可以去了解一下。 /********************************************************************************************************** ** Function name : tTaskInit ** Descriptions : 初始化任务结构 ** parameters : task 要初始化的任务结构 ** parameters : entry 任务的入口函数 ** parameters : param 传递给任务的运行参数 ** Returned value : 无 ***********************************************************************************************************/ void tTaskInit (tTask * task, void (*entry)(void *), void *param, uint32_t * stack) { // 为了简化代码，tinyOS无论是在启动时切换至第一个任务，还是在运行过程中在不同间任务切换 // 所执行的操作都是先保存当前任务的运行环境参数（CPU寄存器值）的堆栈中(如果已经运行运行起来的话)，然后再 // 取出从下一个任务的堆栈中取出之前的运行环境参数，然后恢复到CPU寄存器 // 对于切换至之前从没有运行过的任务，我们为它配置一个“虚假的”保存现场，然后使用该现场恢复。 // 注意以下两点： // 1、不需要用到的寄存器，直接填了寄存器号，方便在IDE调试时查看效果； // 2、顺序不能变，要结合PendSV_Handler以及CPU对异常的处理流程来理解 *(--stack) = (unsigned long)(1&lt;&lt;24); // XPSR, 设置了Thumb模式，恢复到Thumb状态而非ARM状态运行 *(--stack) = (unsigned long)entry; // 程序的入口地址 *(--stack) = (unsigned long)0x14; // R14(LR), 任务不会通过return xxx结束自己，所以未用 *(--stack) = (unsigned long)0x12; // R12, 未用 *(--stack) = (unsigned long)0x3; // R3, 未用 *(--stack) = (unsigned long)0x2; // R2, 未用 *(--stack) = (unsigned long)0x1; // R1, 未用 *(--stack) = (unsigned long)param; // R0 = param, 传给任务的入口函数 *(--stack) = (unsigned long)0x11; // R11, 未用 *(--stack) = (unsigned long)0x10; // R10, 未用 *(--stack) = (unsigned long)0x9; // R9, 未用 *(--stack) = (unsigned long)0x8; // R8, 未用 *(--stack) = (unsigned long)0x7; // R7, 未用 *(--stack) = (unsigned long)0x6; // R6, 未用 *(--stack) = (unsigned long)0x5; // R5, 未用 *(--stack) = (unsigned long)0x4; // R4, 未用 task-&gt;stack = stack; // 保存最终的值 } 这个虚假的现场做好后，任务初始化完毕，就可以进行接下来的一步，任务切换。 任务的切换 任务切换的本质：保存前一个任务的运行状态数据，恢复后一个任务之前的状态数据。 1. 举个例子，假设有两个任务task1、task2在交替运行。 2. 当task1在运行的时候，也就是说task1占据了CPU的使用权，task1的数据运行在CPU的那些寄存器中。 3. 当系统中某中断触发了PendSV异常，这时RTOS就会把当前task1的运行数据存储进入task1的独立栈中，这些数据也代表了task1的运行状态。所以这个过程叫做保存前一个任务的状态数据。 4. 接着就是恢复下一个任务的运行状态，把task2的独立栈中的数据弹入CPU的寄存器中，让task2占据CPU运行。 5. 当PendSV异常被触发时，这时会保存tsak2的运行状态，恢复task1的运行状态。 6. 上述就是任务切换的流程 Cortex-m3的PendSV异常切换任务代码如下，采用C语言和中内嵌汇编的方式。 // 在任务切换中，主要依赖了PendSV进行切换。PendSV其中的一个很重要的作用便是用于支持RTOS的任务切换。 // 实现方法为： // 1、首先将PendSV的中断优先配置为最低。这样只有在其它所有中断完成后，才会触发该中断； // 实现方法为：向NVIC_SYSPRI2写NVIC_PENDSV_PRI // 2、在需要中断切换时，设置挂起位为1，手动触发。这样，当没有其它中断发生时，将会引发PendSV中断。 // 实现方法为：向NVIC_INT_CTRL写NVIC_PENDSVSET // 3、在PendSV中，执行任务切换操作。 #define NVIC_INT_CTRL 0xE000ED04 // 中断控制及状态寄存器 #define NVIC_PENDSVSET 0x10000000 // 触发软件中断的值 #define NVIC_SYSPRI2 0xE000ED22 // 系统优先级寄存器 #define NVIC_PENDSV_PRI 0x000000FF // 配置优先级 #define MEM32(addr) *(volatile unsigned long *)(addr) #define MEM8(addr) *(volatile unsigned char *)(addr) /********************************************************************************************************** ** Function name : PendSV_Handler ** Descriptions : PendSV异常处理函数。很有些会奇怪，看不到这个函数有在哪里调用。实际上，只要保持函数头不变 ** void PendSV_Handler (), 在PendSV发生时，该函数会被自动调用 ** parameters : 无 ** Returned value : 无 ***********************************************************************************************************/ __asm void PendSV_Handler () { IMPORT currentTask // 使用import导入C文件中声明的全局变量 IMPORT nextTask // 类似于在C文文件中使用extern int variable MRS R0, PSP // 加载特殊功能寄存器到通用功能寄存值，获取当前任务的堆栈指针 CBZ R0, PendSVHandler_nosave // if 这是由tTaskSwitch触发的(此时，PSP肯定不会是0了，0的话必定是tTaskRunFirst)触发 // 不清楚的话，可以先看tTaskRunFirst和tTaskSwitch的实现 STMDB R0!, {R4-R11} // 那么，我们需要将除异常自动保存的寄存器这外的其它寄存器自动保存起来{R4, R11} // 保存的地址是当前任务的PSP堆栈中，这样就完整的保存了必要的CPU寄存器,便于下次恢复 // 含义:依次压栈r0 = r0 - 4，先压r11，r0 = r11（即将r11中的内容放入r0所指的内存地址）， // 再r0 = r0 - 4， // 再压r10，r0 = r10......r0 = r0 - 4， // 最后压r4，r0 = r4。 // 则r0中就保存最新的栈顶指针值 LDR R1, =currentTask // 保存好后，将最后的堆栈顶位置，保存到currentTask-&gt;stack处 LDR R1, [R1] // 由于stack处在结构体stack处的开始位置处，显然currentTask和stack在内存中的起始 STR R0, [R1] // 地址是一样的，这么做不会有任何问题 PendSVHandler_nosave // 无论是tTaskSwitch和tTaskSwitch触发的，最后都要从下一个要运行的任务的堆栈中恢复 // CPU寄存器，然后切换至该任务中运行 LDR R0, =currentTask // 好了，准备切换了 LDR R1, =nextTask LDR R2, [R1] STR R2, [R0] // 先将currentTask设置为nextTask，也就是下一任务变成了当前任务 LDR R0, [R2] // 然后，从currentTask中加载stack，这样好知道从哪个位置取出CPU寄存器恢复运行 LDMIA R0!, {R4-R11} // 恢复{R4, R11}。为什么只恢复了这么点，因为其余在退出PendSV时，硬件自动恢复 MSR PSP, R0 // 存储通用寄存器的值到特殊功能寄存器，最后，恢复真正的堆栈指针到PSP ORR LR, LR, #0x04 // 标记下返回标记，指明在退出LR时，切换到PSP堆栈中(PendSV使用的是MSP) BX LR // 最后返回，此时任务就会从堆栈中取出LR值，恢复到上次运行的位置 } /********************************************************************************************************** ** Function name : tTaskRunFirst ** Descriptions : 在启动tinyOS时，调用该函数，将切换至第一个任务运行 ** parameters : 无 ** Returned value : 无 ***********************************************************************************************************/ void tTaskRunFirst() { // 这里设置了一个标记，PSP = 0, 用于与tTaskSwitch()区分，用于在PEND_SV // 中判断当前切换是tinyOS启动时切换至第1个任务，还是多任务已经跑起来后执行的切换 __set_PSP(0); MEM8(NVIC_SYSPRI2) = NVIC_PENDSV_PRI; // 向NVIC_SYSPRI2写NVIC_PENDSV_PRI，设置其为最低优先级 MEM32(NVIC_INT_CTRL) = NVIC_PENDSVSET; // 向NVIC_INT_CTRL写NVIC_PENDSVSET，用于PendSV // 可以看到，这个函数是没有返回 // 这是因为，一旦触发PendSV后，将会在PendSV后立即进行任务切换，切换至第1个任务运行 // 此后，tinyOS将负责管理所有任务的运行，永远不会返回到该函数运行 } /********************************************************************************************************** ** Function name : tTaskSwitch ** Descriptions : 进行一次任务切换，tinyOS会预先配置好currentTask和nextTask, 然后调用该函数，切换至 ** nextTask运行 ** parameters : 无 ** Returned value : 无 ***********************************************************************************************************/ void tTaskSwitch() { // 和tTaskRunFirst, 这个函数会在某个任务中调用，然后触发PendSV切换至其它任务 // 之后的某个时候，将会再次切换到该任务运行，此时，开始运行该行代码, 返回到 // tTaskSwitch调用处继续往下运行 MEM32(NVIC_INT_CTRL) = NVIC_PENDSVSET; // 向NVIC_INT_CTRL写NVIC_PENDSVSET，用于PendSV } 在这里有了这部分切换代码，就可以实现在两个任务的切换了，先上代码，再来讲解，主要看注释。 &quot;tinyOS.h&quot; #ifndef __TINYOS_H_ #define __TINYOS_H_ #include &lt;stdint.h&gt; // Cortex-M的堆栈单元类型：堆栈单元的大小为32位，所以使用uint32_t typedef uint32_t tTaskStack; typedef struct _tTask//任务结构体 { // 任务所用堆栈的当前堆栈指针。每个任务都有他自己的堆栈，用于在运行过程中存储临时变量等一些环境参数 // 在tinyOS运行该任务前，会从stack指向的位置处，会读取堆栈中的环境参数恢复到CPU寄存器中，然后开始运行 // 在切换至其它任务时，会将当前CPU寄存器值保存到堆栈中，等待下一次运行该任务时再恢复。 // stack保存了最后保存环境参数的地址位置，用于后续恢复 tTaskStack * stack; }tTask; extern tTask* currentTask; extern tTask* nextTask; void tTaskRunFirst(void); void tTaskSwitch(void); #endif &quot;switch.c&quot; #include &quot;tinyOS.h&quot; #include &quot;ARMCM3.h&quot; // 在任务切换中，主要依赖了PendSV进行切换。PendSV其中的一个很重要的作用便是用于支持RTOS的任务切换。 // 实现方法为： // 1、首先将PendSV的中断优先配置为最低。这样只有在其它所有中断完成后，才会触发该中断； // 实现方法为：向NVIC_SYSPRI2写NVIC_PENDSV_PRI // 2、在需要中断切换时，设置挂起位为1，手动触发。这样，当没有其它中断发生时，将会引发PendSV中断。 // 实现方法为：向NVIC_INT_CTRL写NVIC_PENDSVSET // 3、在PendSV中，执行任务切换操作。 #define NVIC_INT_CTRL 0xE000Ed04 #define NVIC_PENDSVSET 0x10000000 #define NVIC_SYSPRI2 0xE000ED22 #define NVIC_PENDSV_PRI 0x000000FF #define MEM32(addr) *(volatile unsigned long *)(addr) #define MEM8(addr) *(volatile unsigned char *)(addr) // 下面的代码中，用到了C文件嵌入ARM汇编 // 基本语法为:__asm 返回值 函数名(参数声明) {....}， 更具体的用法见Keil编译器手册，此处不再详注。 __asm void PendSV_Handler(void) { IMPORT currentTask // 使用import导入C文件中声明的全局变量， IMPORT nextTask // 类似于在C文文件中使用extern int variable MRS R0, PSP //加载特殊功能寄存器到通用功能寄存器，获取当前任务的堆栈指针 CBZ R0, PendSVHander_nosave //判断R0的值是否为0，是0就跳转PendSVHander_nosave段 //如果这是由tTaskSwitch触发的(此时，PSP肯定不会是0了， //0的话必定是tTaskRunFirst)触发 STMDB R0!, {R4-R11} // 那么，我们需要将除异常自动保存的寄存器这外的其它寄存器 // 自动保存起来{R4, R11} // 保存的地址是当前任务的PSP堆栈中，这样就完整的保存了必要的 // CPU寄存器,便于下次恢复 LDR R1, =currentTask // 保存好后，将最后的堆栈顶位置，保存到currentTask-&gt;stack处 LDR R1, [R1] // 由于stack处在结构体stack处的开始位置处，显然currentTask和 // stack在内存中的起始 STR R0, [R1] // 地址是一样的，这么做不会有任何问题 // 无论是tTaskSwitch和tTaskSwitch触发的，最后都要从下一个要运行的任务的堆栈中恢复 // CPU寄存器，然后切换至该任务中运行 // 好了，准备切换了 PendSVHander_nosave LDR R0, =currentTask //加载当前任务到R0 LDR R1, =nextTask //加载下个任务到R1 LDR R2, [R1] //把nextTask寄存器值给R2 STR R2, [R0] //把nextTask值给currentTask //先将currentTask设置为nextTask，也就是下一任务变成了当前任务 LDR R0, [R2] //然后，从currentTask中加载stack，这样好知道从哪个位置取出CPU寄存器恢复运行 LDMIA R0!, {R4-R11} //恢复{R4, R11}。为什么只恢复了这么点，因为其余在退出PendSV时，硬件自动恢复 MSR PSP, R0 //最后，恢复真正的堆栈指针到PSP ORR LR, LR, #0x04 //标记下返回标记，指明在退出LR时，切换到PSP堆栈中(PendSV使用的是MSP) BX LR //最后返回，此时任务就会从堆栈中取出LR值，恢复到上次运行的位置 } void tTaskRunFirst(void) { //这里设置了一个标记，PSP = 0，用于与tTaskSwitch()区分，用于在PEND_SV //中判断当前切换是tinyOS启东时切换至第一个任务，还是多任务已经跑起来后执行的切换 __set_PSP(0);//用于标记初始任务，如果是跑起来的多任务，PSP栈肯定是指向用户级栈的某个位置肯定不为0 MEM8(NVIC_SYSPRI2) = NVIC_PENDSV_PRI; MEM32(NVIC_INT_CTRL) = NVIC_PENDSVSET; //可以看到，这个函数没有返回 //这是因为，一旦触发PEND_SV后，将会在PendSV后立即进行任务切换，切换至第一个任务运行 //此后，TinyOS将负责管理所有的任务运行，永远不会返回该函数运行 } void tTaskSwitch() { // 和tTaskRunFirst, 这个函数会在某个任务中调用，然后触发PendSV切换至其它任务 // 之后的某个时候，将会再次切换到该任务运行，此时，开始运行该行代码, 返回到 // tTaskSwitch调用处继续往下运行 MEM32(NVIC_INT_CTRL) = NVIC_PENDSVSET; // 向NVIC_INT_CTRL写NVIC_PENDSVSET，用于PendSV } &quot;main.c&quot; #include &quot;tinyOS.h&quot; tTask* currentTask; tTask* nextTask; tTask* taskTable[2]; //就绪表 /*任务初始化函数*/ void tTaskInit(tTask* task, void (*entry)(void *), void* param, tTaskStack* stack) { // 为了简化代码，tinyOS无论是在启动时切换至第一个任务，还是在运行过程中在不同间任务切换 // 所执行的操作都是先保存当前任务的运行环境参数（CPU寄存器值）的堆栈中(如果已经运行运行起来的话)， // 然后再取出从下一个任务的堆栈中取出之前的运行环境参数，然后恢复到CPU寄存器 // 对于切换至之前从没有运行过的任务，我们为它配置一个“虚假的”保存现场，然后使用该现场恢复。 // 注意以下两点： // 1、不需要用到的寄存器，直接填了寄存器号，方便在IDE调试时查看效果； // 2、顺序不能变，要结合PendSV_Handler以及CPU对异常的处理流程来理解 *(--stack) = (unsigned long)(1 &lt;&lt; 24);//xPSR寄存器，必须置为1，否则进入ARM模式，运行异常 *(--stack) = (unsigned long)entry; //pc寄存器 //任务的入口函数 *(--stack) = (unsigned long)0x14; //未用，填入便于识别的数值，对应寄存器号 *(--stack) = (unsigned long)0x12; //未用，填入便于识别的数值，对应寄存器号 *(--stack) = (unsigned long)0x03; //未用，填入便于识别的数值，对应寄存器号 *(--stack) = (unsigned long)0x02; //未用，填入便于识别的数值，对应寄存器号 *(--stack) = (unsigned long)0x01; //未用，填入便于识别的数值，对应寄存器号 *(--stack) = (unsigned long)param; //任务的入口参数会传给R0 //以上是硬件自动保存 *(--stack) = (unsigned long)0x11; //未用，填入便于识别的数值，对应寄存器号 *(--stack) = (unsigned long)0x10; //未用，填入便于识别的数值，对应寄存器号 *(--stack) = (unsigned long)0x09; //未用，填入便于识别的数值，对应寄存器号 *(--stack) = (unsigned long)0x08; //未用，填入便于识别的数值，对应寄存器号 *(--stack) = (unsigned long)0x07; //未用，填入便于识别的数值，对应寄存器号 *(--stack) = (unsigned long)0x06; //未用，填入便于识别的数值，对应寄存器号 *(--stack) = (unsigned long)0x05; //未用，填入便于识别的数值，对应寄存器号 *(--stack) = (unsigned long)0x04; //未用，填入便于识别的数值，对应寄存器号 task-&gt;stack = stack; } void tTaskSched() { // 这里的算法很简单。 // 一共有两个任务。选择另一个任务，然后切换过去 if(currentTask == taskTable[0]) { nextTask = taskTable[1]; } else { nextTask = taskTable[0]; } tTaskSwitch(); } void delay(int count) { while(--count &gt; 0); } tTask tTask1; tTask tTask2; tTaskStack task1Env[1024]; tTaskStack task2Env[1024]; int task1Flag; void task1Entry(void * param) { for(;;) { task1Flag = 0; delay(100); task1Flag = 1; delay(100); tTaskSched(); } } int task2Flag; void task2Entry(void * param) { for(;;) { task2Flag = 0; delay(100); task2Flag = 1; delay(100); tTaskSched(); } } int main() { //初始化任务1和任务2结构，传递任务运行的起始地址，想要给任意参数，以及运行堆栈空间 tTaskInit(&amp;tTask1, task1Entry, (void *)0x11111111, &amp;task1Env[1024]); tTaskInit(&amp;tTask2, task2Entry, (void *)0x22222222, &amp;task2Env[1024]); //接着，将任务加入到任务表中 taskTable[0] = &amp;tTask1; taskTable[1] = &amp;tTask2; //我们期望先运行tTask1, 也就是void task1Entry (void * param) nextTask = taskTable[0]; //切换到nextTask， 这个函数永远不会返回 tTaskRunFirst(); return 0; } 这里主函数的代码很简单，就是在任务tTask1执行完毕之后，去主动触发任务调度tTaskSched()，在tTaskSched()里面触发tTaskSwitch()从而来从当前任务跳转到另一个任务，taskTable[2]被称之为就绪表，这个小实验就是在两个任务中来回切换。 之前上面提到任务切换由在任务中主动调用tTaskSched()来触发PendSV异常，但是tTaskSched()总是在任务中被调用，并不是很理想，而且目前任务中还有软件延时，对于实时操作系统来说，简直就是灾难。 任务切换机制 这里有两种触发方式，事件触发和时间触发。这里举个例子，一个医院有十个病人，每个病人配有一个护工，还有一个主治医生，如果病人出现小问题，如果护工能解决就不需要去叫主治医生来解决，如果护工不能解决就需要去求助主治医生。事件触发就是护工不能解决来求助主治医生，时间触发就是主治医生每隔一个小时就是查看每个病人。试想一下，如果同时三个护工同时来找主治医生，主治医生必然一个接着一个，但是这三个病人必须立马手术，不进行手术就会死亡，所以这时主治医生就分身乏术。所以事件触发相比时间触发来说，没有时间触发高效。那么PendSV异常的触发就用Cortex-M3内核自带的SysTick定时器，我们选择10ms触发一次。 SysTick的配置： /********************************************************************************************************* ** 系统时钟节拍定时器System Tick配置 ** 在我们目前的环境（模拟器）中，系统时钟节拍为12MHz ** 请务必按照本教程推荐配置，否则systemTick的值就会有变化，需要查看数据手册才了解 **********************************************************************************************************/ void tSetSysTickPeriod(uint32_t ms) { SysTick-&gt;LOAD = ms * SystemCoreClock / 1000 - 1; NVIC_SetPriority (SysTick_IRQn, (1&lt;&lt;__NVIC_PRIO_BITS) - 1); SysTick-&gt;VAL = 0; SysTick-&gt;CTRL = SysTick_CTRL_CLKSOURCE_Msk | SysTick_CTRL_TICKINT_Msk | SysTick_CTRL_ENABLE_Msk; } /********************************************************************************************************** ** Function name : SysTick_Handler ** Descriptions : SystemTick的中断处理函数。 ** parameters : 无 ** Returned value : 无 ***********************************************************************************************************/ void SysTick_Handler () { // 什么都没做，除了进行任务切换 // 由于tTaskSched自动选择另一个任务切换过去，所以其效果就是 // 两个任务交替运行，与上一次例子不同的是，这是由系统时钟节拍推动的 // 如果说，上一个例子里需要每个任务主动去调用tTaskSched切换，那么这里就是不管任务愿不愿意，CPU // 的运行权都会被交给另一个任务。这样对每个任务就很公平了，不存在某个任务拒不调用tTaskSched而一直占用CPU的情况 tTaskSched(); } /********************************************************************************************************** ** Function name : tTaskSched ** Descriptions : 任务调度接口。tinyOS通过它来选择下一个具体的任务，然后切换至该任务运行。 ** parameters : 无 ** Returned value : 无 ***********************************************************************************************************/ void tTaskSched () { // 这里的算法很简单。 // 一共有两个任务。选择另一个任务，然后切换过去 if (currentTask == taskTable[0]) { nextTask = taskTable[1]; } else { nextTask = taskTable[0]; } tTaskSwitch(); } 实现两个任务的切换 有了任务的切换机制，再有两个任务，task1、task2两个任务，依靠SyTick触发PendSV异常来切换任务，那任务代码就可以简化： /********************************************************************************************************** ** 应用示例 ** 有两个任务，分别执行task1Entry和task2Entry。功能是分别对相应的变量进行周期性置0置1. ** 每个任务都可以占用一段时间的CPU，一旦用完了，就会被强制暂停，切换到另一个任务中去。 **********************************************************************************************************/ void delay (int count) { while (--count &gt; 0); } int task1Flag; void task1Entry (void * param) { tSetSysTickPeriod(10); for (;;) { task1Flag = 1; delay(100); task1Flag = 0; delay(100); } } int task2Flag; void task2Entry (void * param) { for (;;) { task2Flag = 1; delay(100); task2Flag = 0; delay(100); } } 此时这个任务中的延时依然采用软件延时函数（如图）。 下面是对红绿两块进行放大后的效果：可以看见task1执行多次之后被SysTick的10ms打断，从而进入任务切换，然后task2占据CPU的使用权，继续执行，然后在进入task1。 但是软件延时依然会有很高的风险，比如这个任务延时1秒，难道其他任务也得等着吗？ 双任务延时原理与空闲任务 因为SysTick定时的时间是10ms，所以采用这个延时，比如延时几个10ms。在任务初始化的时候添加一个变量delayTicks，当任务遇到延时函数的时候，就把延时的时间变量传给这个delayTicks，然后就进行任务调度。在SysTick的定时中断里面对这两个任务的delayTicks自减，再进行任务调度（如图6）。如果这两个任务都进行延时，这时候需要一个空闲任务，这个空闲任务来执行一些堆栈测量或者是cpu使用量测量，这些具体下面再分析。 tinyOS.h 所以在任务的结构体里面需要添加一个变量delayTicks，用来记录延时几个10ms。 // 任务结构：包含了一个任务的所有信息 typedef struct _tTask { // 任务所用堆栈的当前堆栈指针。每个任务都有他自己的堆栈，用于在运行过程中存储临时变量等一些环境参数 // 在tinyOS运行该任务前，会从stack指向的位置处，会读取堆栈中的环境参数恢复到CPU寄存器中，然后开始运行 // 在切换至其它任务时，会将当前CPU寄存器值保存到堆栈中，等待下一次运行该任务时再恢复。 // stack保存了最后保存环境参数的地址位置，用于后续恢复 tTaskStack * stack; // 任务延时计数器 uint32_t delayTicks; }tTask; main.c 添加一个空闲任务以及因为空闲任务的加入导致调度函数代码变化 // 用于空闲任务的任务结构和堆栈空间 tTask tTaskIdle; tTaskStack idleTaskEnv[1024]; void idleTaskEntry (void * param) { for (;;) { // 空闲任务什么都不做 } } /********************************************************************************************************** ** Function name : tTaskSched ** Descriptions : 任务调度接口。tinyOS通过它来选择下一个具体的任务，然后切换至该任务运行。 ** parameters : 无 ** Returned value : 无 ***********************************************************************************************************/ void tTaskSched () { // 空闲任务只有在所有其它任务都不是延时状态时才执行 // 所以，我们先检查下当前任务是否是空闲任务 if (currentTask == idleTask) { // 如果是的话，那么去执行task1或者task2中的任意一个 // 当然，如果某个任务还在延时状态，那么就不应该切换到他。 // 如果所有任务都在延时，那么就继续运行空闲任务，不进行任何切换了 if (taskTable[0]-&gt;delayTicks == 0) { nextTask = taskTable[0]; } else if (taskTable[1]-&gt;delayTicks == 0) { nextTask = taskTable[1]; } else { return; } } else { // 如果是task1或者task2的话，检查下另外一个任务 // 如果另外的任务不在延时中，就切换到该任务 // 否则，判断下当前任务是否应该进入延时状态，如果是的话，就切换到空闲任务。否则就不进行任何切换 if (currentTask == taskTable[0]) { if (taskTable[1]-&gt;delayTicks == 0) { nextTask = taskTable[1]; } else if (currentTask-&gt;delayTicks != 0) { nextTask = idleTask; } else { return; } } else if (currentTask == taskTable[1]) { if (taskTable[0]-&gt;delayTicks == 0) { nextTask = taskTable[0]; } else if (currentTask-&gt;delayTicks != 0) { nextTask = idleTask; } else { return; } } } tTaskSwitch(); } int main () { // 初始化任务1和任务2结构，传递运行的起始地址，想要给任意参数，以及运行堆栈空间 tTaskInit(&amp;tTask1, task1Entry, (void *)0x11111111, &amp;task1Env[1024]); tTaskInit(&amp;tTask2, task2Entry, (void *)0x22222222, &amp;task2Env[1024]); // 接着，将任务加入到任务表中 taskTable[0] = &amp;tTask1; taskTable[1] = &amp;tTask2; // 创建空闲任务 tTaskInit(&amp;tTaskIdle, idleTaskEntry, (void *)0, &amp;idleTaskEnv[1024]); idleTask = &amp;tTaskIdle; // 我们期望先运行tTask1, 也就是void task1Entry (void * param) nextTask = taskTable[0]; // 切换到nextTask， 这个函数永远不会返回 tTaskRunFirst(); return 0; } 看下图。任务运行的标志反转是齐头并进的，与之前两个任务的切换图不一样，那个是间断的。这个是连续不断的。 将此图放大，可见系统的实时性提高了，没有像之前那样高达1s的延时。这才是我们理想期望的那样，两个任务齐头并进的效果。 对于共享资源的保护 不同的任务会对同一片共享资源进行访问，或者说任务和中断也会对同一片资源进行访问，比如任务修改了所需要的某个全局变量的值，这时候中断又把这个值改了回去，那么这个时候任务修改的就失效了。这时就需要一种机制来保护这片共享资源。 临界区保护 临界区保护就是在访问这片资源前先屏蔽所有中断，然后对共享资源进行操作，访问结束后再开启所有中断。 // 下面的代码中，用到了C文件嵌入ARM汇编 // 基本语法为:__asm 返回值 函数名(参数声明) {....}， 更具体的用法见Keil编译器手册，此处不再详注。 /********************************************************************************************************** ** Function name : tTaskEnterCritical ** Descriptions : 进入临界区 ** parameters : 无 ** Returned value : 进入之前的临界区状态值 ***********************************************************************************************************/ uint32_t tTaskEnterCritical (void) { uint32_t primask = __get_PRIMASK(); __disable_irq(); // CPSID I return primask; } /********************************************************************************************************** ** Function name : tTaskExitCritical ** Descriptions : 退出临界区,恢复之前的临界区状态 ** parameters : status 进入临界区之前的CPU ** Returned value : 进入临界区之前的临界区状态值 ***********************************************************************************************************/ void tTaskExitCritical (uint32_t status) { __set_PRIMASK(status); } 调度锁保护 调度锁保护在这种开关中断保护之上，比如在访问这片共享资源的时候禁止关闭中断，所以只能采取调度锁保护，就是在访问资源前关闭调度，再对资源资源进行操作，接着开启调度。这两种方法在以后用会很常见。 位图数据结构实现任务优先级 上面的代码才支持两个任务，一个多任务操作系统怎么能支持两个任务，这里引入一种数据结构来支持任务的优先级——位图数据结构。 任务的延时队列 任务的延时采用上面所说的延时原理。延时队列是什么？其实是一个双向链表，比如一个任务有延时发生，就会把这个任务插入延时队列的尾部，并把这个任务从就绪态切换为延时态，这时会继续扫描优先级任务表，取出最高优先级的任务占据CPU运行。但是如果所有的任务都在延时态，就如上面所说会执行一个空闲任务。随着SysTick触发中断，这时会去遍历这个延时队列，找出这个延时队列中的处于延时态的任务，并递减这个任务的延时变量，当延时变量递减到0时，就唤醒这个任务并转变为就绪态，并把它插入任务表中，会继续执行任务调度函数，找出最高优先级的任务，并占据CPU运行。 支持任务同优先级 也就是多任务共优先级的时间片运行：什么叫时间片，就是把一秒钟给具体分配给这个任务假设执行多久。为了完成这个功能，在任务初始化的时候，把同优先级的任务插入每个优先级位的双向链表，这里就称之为任务队列。假设ABC三个任务，A的优先级最高，B、C的优先级相同。在任务初始化的时候，把同优先级的任务放入一个双向链表中，并初始化时间片是10（Keil代码中设定是10），B、C任务的延时是普通依靠减一个数的delay延时，A是依靠时钟节拍的延时。A任务优先级最高会占据CPU运行，A遇到延时的时候，会被插入延时列表的尾部，并清除A任务在就绪表中的位（位图数据结构），A任务从就绪态变为延时态。这时会进入调度函数，找出此时优先级最高的是B和C，会从初始化时链表的头部取出一个任务并一直占据CPU运行，这时就等待系统的SysTick中断，在中断函数里，会先遍历延时队列，检测有没有延时完成的任务，然后对当前任务的时间片进行递减和0比较，如果有延时完成的任务并且优先级比当前任务高，会让延时完成的任务占据CPU运行，如果没有延时任务会继续让当前任务运行；如果当前任务的时间片运行结束，会把这个队列中处于头节点任务移除，并插入表尾。这时会继续进入调度函数，找出最高优先级的任务占据CPU运行。 任务的挂起 任务的挂起就是就是暂停任务运行，任务的恢复就是就是恢复任务运行，任务的删除就是释放任务资源。 任务信息的查询 事件控制块的实现 上面已经说过，操作系统就是为任务进行合理地调度，重点就是合理，不同的任务有不同的功能，比如这个任务需要与其他的任务进行同步、这个任务里面删除其他任务、这个任务要继承其他任务的优先级等等，但是这些操作首先要被操作系统了解，我们称这些操作叫做事件，所以用一个大的结构来管理——事件控制块。事件控制块里很多类型，也就是说下面要介绍的：计数信号量事件类型、邮箱事件类型、存储块管理事件类型、事件标志组事件类型和互斥信号量事件类型。 计数信号量的实现 计数信号量是事件控制块加一个计数器。计数器负责技术控制，事件控制块用于控制任务等待和唤醒。如果一个任务A中有信号量等待，就解除就绪态并移除就绪表，就把这个任务插入事件控制块的等待队列，如果这个任务还设置了超时等待，就插入延时队列。接着就会进入其他任务，任务B中会通知任务A，把任务A唤醒，并移除事件控制块的等待队列进入就绪态，如果唤醒的这个任务优先级更高就进行任务调度。关于时间控制块中设置超时任务，因为他在两个队列中，延时队列和事件控制块的等待队列，等待超时结束，就会在中断里进行唤醒。信号量一般用于两个任务的同步。 邮箱的实现 邮箱的功能是满足多个任务之间传递消息。邮箱里面就有两个队列，一个是等待消息的任务队列，另一就是消息缓存队列，所以邮箱应当建立在事件控制块的基础之上。邮箱无消息，任务等待；邮箱内没有任务收消息，消息缓存；考虑效率问题，保存消息的起始地址。 存储块的实现 内存中会有很多大量细小无法使用的碎片，频繁地进行任意大小的内存分配可能会产生很多不连续的细小的外部碎片，导致无法再分配。并且代码实现比较复杂，分配和释放过程操作时间不确定。是否真的需要分配任意大小的存储空间？从程序最底层往上应用层，所有东西开发都是完全可见的，针对特定场合开发，有时存储空间分配大小的种类通常只有少量几种。比如某个任务需要4个20k的内存块，有的任务需要3个80K的内存块，有的需求3个256B的存储块。但是缺点就是这些内存块无法彼此共享。牺牲了一定的存储空间换来简单、快速、确定的分配方式。存储块结构由两部分组成，空闲存储链表和事件控制块，空闲存储列表是空闲存储块链表，事件控制块为等待存储块的任务列表。 事件标志组的实现 如何在中断ISR与任务之间传递多个任务标志？每个任务都只有它等待特有的事件集合；当没有事件没有发生时，任务就进入这个列表中等待；当任务需要等待的这个事件发生，就唤醒任务。 事件标志组是实现多任务同步的有效机制之一。也许有不理解的初学者会问采用事件标志组多麻烦，搞个全局变量不是更简单？其实不然，在裸机编程时，使用全局变量的确比较方便，但是在加上RTOS后就是另一种情况了。使用全局变量相比事件标志组主要有如下三个问题： 使用事件标志组可以让RTOS内核有效地管理任务，而全局变量是无法做到的，任务的超时等机制需要用户自己去实现。 使用了全局变量就要防止多任务的访问冲突，而使用事件标志组则处理好了这个问题，用户无需担心。 使用事件标志组可以有效地解决中断服务程序和任务之间的同步问题。 互斥信号量的实现 如何在多个任务共享资源冲突的问题？之前给过关中断、调度锁保护的解决方案，但是如果访问资源的时候净值关闭中断、或者说调度锁也不能长时间关闭的情况下，这两种方案就失效了。之前还讲过计数信号量的解决方式，但是这个方式不支持嵌套使用，也不支持该型号量的所有者，也无法解决优先级反转的问题。 解释一下优先级反转问题：比如初始时一个资源被一个低优先级任务占有。高优先级任务期望占有资源，所以必须等待低优先级的任务释放资源后才能去占有，这个时候有多个中等优先级的任务并不需要占用资源，占用CPU的使用权，这样低优先级和高优先级都无法运行，一直是中等优先级的任务在运行。 所以这里引入一个全新的概念——互斥信号量，它有四个组成部分：用于嵌套调用的锁定次数计数器，当前已经获取信号量的任务，支持有优先级继承的原始优先级和一个事件控制块。 软件定时器的实现 软定时器解决某个任务需要周期性的运行，这样就节省了硬件资源。创建一个定时器任务，它维护了一个定时器列表，定时器列表去周期性的查询一个又一个的软定时器，但是定时器任务可能被更高优先级的任务抢占运行，导致刷新定时器列表的时间滞后，这个滞后的时间是不确定的。为了解决这个问题又添加了一个定时器列表，这个定时器列表在系统中断节拍的服务函数里扫描的，这个定时器列表里的任务需要执行时间较短，而定时器任务列表中的函数可以执行时间较长。 堆栈测量的检测 栈的使用量：初始化栈的时候为0，因为ARM栈的使用是满降栈模式，所以从栈的起始地址开始到第一个不为零的地址结束就是栈的使用量。 CPU使用量检测 统计单位时间内CPU分别有多少时间在执行应用任务的代码和空闲任务的代码，但是这个无法实现，无法得到单位时间里执行了哪些指令，硬件不支持。所以换个思路，在系统空闲时运行的时候，设计一个特殊代码块（如图26）里有个执行计数器，仅特殊代码块的计数值MAX，正常运行时获取计数值Cnt，所以cpu的百分比≈100 - Cnt*100/Max。 内核裁剪 到这里，微型操作系统的内核差不多就实现了，为什么要裁剪呢？就是保留你需要用的功能，留下你需要用的功能。这里使用条件编译的方式，需要什么功能就使能这个功能的宏。 Hooks拓展 Hooks，即钩子函数，用于在某些内核代码中插入一个占位，当执行到该位置时，执行自定义的功能代码，避免直接就该原始的内核代码。 ","link":"https://leichen2552.github.io/post/rtos_from_zero_to_one/"},{"title":"Hello Gridea","content":"👏 欢迎使用 Gridea ！ ✍️ Gridea 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ... Github Gridea 主页 示例网站 特性👇 📝 你可以使用最酷的 Markdown 语法，进行快速创作 🌉 你可以给文章配上精美的封面图和在文章任意位置插入图片 🏷️ 你可以对文章进行标签分组 📋 你可以自定义菜单，甚至可以创建外部链接菜单 💻 你可以在 Windows，MacOS 或 Linux 设备上使用此客户端 🌎 你可以使用 𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌 或 Coding Pages 向世界展示，未来将支持更多平台 💬 你可以进行简单的配置，接入 Gitalk 或 DisqusJS 评论系统 🇬🇧 你可以使用中文简体或英语 🌁 你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力 🖥 你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步 🌱 当然 Gridea 还很年轻，有很多不足，但请相信，它会不停向前 🏃 未来，它一定会成为你离不开的伙伴 尽情发挥你的才华吧！ 😘 Enjoy~ ","link":"https://leichen2552.github.io/post/hello-gridea/"}]}